var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// node_modules/unenv/dist/runtime/_internal/utils.mjs
// @__NO_SIDE_EFFECTS__
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
// @__NO_SIDE_EFFECTS__
function notImplemented(name) {
  const fn = /* @__PURE__ */ __name(() => {
    throw /* @__PURE__ */ createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn, { __unenv__: true });
}
// @__NO_SIDE_EFFECTS__
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
var init_utils = __esm({
  "node_modules/unenv/dist/runtime/_internal/utils.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
    __name(notImplementedClass, "notImplementedClass");
  }
});

// node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance;
var init_performance = __esm({
  "node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
    nodeTiming = {
      name: "node",
      entryType: "node",
      startTime: 0,
      duration: 0,
      nodeStart: 0,
      v8Start: 0,
      bootstrapComplete: 0,
      environment: 0,
      loopStart: 0,
      loopExit: 0,
      idleTime: 0,
      uvMetricsInfo: {
        loopCount: 0,
        events: 0,
        eventsWaiting: 0
      },
      detail: void 0,
      toJSON() {
        return this;
      }
    };
    PerformanceEntry = class {
      static {
        __name(this, "PerformanceEntry");
      }
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name, options) {
        this.name = name;
        this.startTime = options?.startTime || _performanceNow();
        this.detail = options?.detail;
      }
      get duration() {
        return _performanceNow() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    PerformanceMark = class PerformanceMark2 extends PerformanceEntry {
      static {
        __name(this, "PerformanceMark");
      }
      entryType = "mark";
      constructor() {
        super(...arguments);
      }
      get duration() {
        return 0;
      }
    };
    PerformanceMeasure = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceMeasure");
      }
      entryType = "measure";
    };
    PerformanceResourceTiming = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceResourceTiming");
      }
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
      responseStatus = 0;
    };
    PerformanceObserverEntryList = class {
      static {
        __name(this, "PerformanceObserverEntryList");
      }
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type) {
        return [];
      }
    };
    Performance = class {
      static {
        __name(this, "Performance");
      }
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = void 0;
      timing = void 0;
      timerify(_fn, _options) {
        throw createNotImplementedError("Performance.timerify");
      }
      get nodeTiming() {
        return nodeTiming;
      }
      eventLoopUtilization() {
        return {};
      }
      markResourceTiming() {
        return new PerformanceResourceTiming("");
      }
      onresourcetimingbufferfull = null;
      now() {
        if (this.timeOrigin === _timeOrigin) {
          return _performanceNow();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter((e) => e.entryType !== "resource" || e.entryType !== "navigation");
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name, type) {
        return this._entries.filter((e) => e.name === name && (!type || e.entryType === type));
      }
      getEntriesByType(type) {
        return this._entries.filter((e) => e.entryType === type);
      }
      mark(name, options) {
        const entry = new PerformanceMark(name, options);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start;
        let end;
        if (typeof startOrMeasureOptions === "string") {
          start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
          end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
        }
        const entry = new PerformanceMeasure(measureName, {
          startTime: start,
          detail: {
            start,
            end
          }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      addEventListener(type, listener, options) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type, listener, options) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
      toJSON() {
        return this;
      }
    };
    PerformanceObserver = class {
      static {
        __name(this, "PerformanceObserver");
      }
      __unenv__ = true;
      static supportedEntryTypes = [];
      _callback = null;
      constructor(callback) {
        this._callback = callback;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
      bind(fn) {
        return fn;
      }
      runInAsyncScope(fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      asyncId() {
        return 0;
      }
      triggerAsyncId() {
        return 0;
      }
      emitDestroy() {
        return this;
      }
    };
    performance = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();
  }
});

// node_modules/unenv/dist/runtime/node/perf_hooks.mjs
var init_perf_hooks = __esm({
  "node_modules/unenv/dist/runtime/node/perf_hooks.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_performance();
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
var init_performance2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs"() {
    init_perf_hooks();
    globalThis.performance = performance;
    globalThis.Performance = Performance;
    globalThis.PerformanceEntry = PerformanceEntry;
    globalThis.PerformanceMark = PerformanceMark;
    globalThis.PerformanceMeasure = PerformanceMeasure;
    globalThis.PerformanceObserver = PerformanceObserver;
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;
  }
});

// node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default;
var init_noop = __esm({
  "node_modules/unenv/dist/runtime/mock/noop.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop_default = Object.assign(() => {
    }, { __unenv__: true });
  }
});

// node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";
var _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console, _times, _stdoutErrorHandler, _stderrErrorHandler;
var init_console = __esm({
  "node_modules/unenv/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_noop();
    init_utils();
    _console = globalThis.console;
    _ignoreErrors = true;
    _stderr = new Writable();
    _stdout = new Writable();
    log = _console?.log ?? noop_default;
    info = _console?.info ?? log;
    trace = _console?.trace ?? info;
    debug = _console?.debug ?? log;
    table = _console?.table ?? log;
    error = _console?.error ?? log;
    warn = _console?.warn ?? error;
    createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
    clear = _console?.clear ?? noop_default;
    count = _console?.count ?? noop_default;
    countReset = _console?.countReset ?? noop_default;
    dir = _console?.dir ?? noop_default;
    dirxml = _console?.dirxml ?? noop_default;
    group = _console?.group ?? noop_default;
    groupEnd = _console?.groupEnd ?? noop_default;
    groupCollapsed = _console?.groupCollapsed ?? noop_default;
    profile = _console?.profile ?? noop_default;
    profileEnd = _console?.profileEnd ?? noop_default;
    time = _console?.time ?? noop_default;
    timeEnd = _console?.timeEnd ?? noop_default;
    timeLog = _console?.timeLog ?? noop_default;
    timeStamp = _console?.timeStamp ?? noop_default;
    Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
    _times = /* @__PURE__ */ new Map();
    _stdoutErrorHandler = noop_default;
    _stderrErrorHandler = noop_default;
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole, assert, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, console_default;
var init_console2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_console();
    workerdConsole = globalThis["console"];
    ({
      assert,
      clear: clear2,
      context: (
        // @ts-expect-error undocumented public API
        context
      ),
      count: count2,
      countReset: countReset2,
      createTask: (
        // @ts-expect-error undocumented public API
        createTask2
      ),
      debug: debug2,
      dir: dir2,
      dirxml: dirxml2,
      error: error2,
      group: group2,
      groupCollapsed: groupCollapsed2,
      groupEnd: groupEnd2,
      info: info2,
      log: log2,
      profile: profile2,
      profileEnd: profileEnd2,
      table: table2,
      time: time2,
      timeEnd: timeEnd2,
      timeLog: timeLog2,
      timeStamp: timeStamp2,
      trace: trace2,
      warn: warn2
    } = workerdConsole);
    Object.assign(workerdConsole, {
      Console,
      _ignoreErrors,
      _stderr,
      _stderrErrorHandler,
      _stdout,
      _stdoutErrorHandler,
      _times
    });
    console_default = workerdConsole;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console"() {
    init_console2();
    globalThis.console = console_default;
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime;
var init_hrtime = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
      const now = Date.now();
      const seconds = Math.trunc(now / 1e3);
      const nanos = now % 1e3 * 1e6;
      if (startTime) {
        let diffSeconds = seconds - startTime[0];
        let diffNanos = nanos - startTime[0];
        if (diffNanos < 0) {
          diffSeconds = diffSeconds - 1;
          diffNanos = 1e9 + diffNanos;
        }
        return [diffSeconds, diffNanos];
      }
      return [seconds, nanos];
    }, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
      return BigInt(Date.now() * 1e6);
    }, "bigint") });
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
var ReadStream;
var init_read_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ReadStream = class {
      static {
        __name(this, "ReadStream");
      }
      fd;
      isRaw = false;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      setRawMode(mode) {
        this.isRaw = mode;
        return this;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
var WriteStream;
var init_write_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    WriteStream = class {
      static {
        __name(this, "WriteStream");
      }
      fd;
      columns = 80;
      rows = 24;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      clearLine(dir3, callback) {
        callback && callback();
        return false;
      }
      clearScreenDown(callback) {
        callback && callback();
        return false;
      }
      cursorTo(x, y, callback) {
        callback && typeof callback === "function" && callback();
        return false;
      }
      moveCursor(dx, dy, callback) {
        callback && callback();
        return false;
      }
      getColorDepth(env2) {
        return 1;
      }
      hasColors(count3, env2) {
        return false;
      }
      getWindowSize() {
        return [this.columns, this.rows];
      }
      write(str, encoding, cb) {
        if (str instanceof Uint8Array) {
          str = new TextDecoder().decode(str);
        }
        try {
          console.log(str);
        } catch {
        }
        cb && typeof cb === "function" && cb();
        return false;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/tty.mjs
var init_tty = __esm({
  "node_modules/unenv/dist/runtime/node/tty.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_read_stream();
    init_write_stream();
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs
var NODE_VERSION;
var init_node_version = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    NODE_VERSION = "22.14.0";
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";
var Process;
var init_process = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    init_utils();
    init_node_version();
    Process = class _Process extends EventEmitter {
      static {
        __name(this, "Process");
      }
      env;
      hrtime;
      nextTick;
      constructor(impl) {
        super();
        this.env = impl.env;
        this.hrtime = impl.hrtime;
        this.nextTick = impl.nextTick;
        for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
          const value = this[prop];
          if (typeof value === "function") {
            this[prop] = value.bind(this);
          }
        }
      }
      // --- event emitter ---
      emitWarning(warning, type, code) {
        console.warn(`${code ? `[${code}] ` : ""}${type ? `${type}: ` : ""}${warning}`);
      }
      emit(...args) {
        return super.emit(...args);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      // --- stdio (lazy initializers) ---
      #stdin;
      #stdout;
      #stderr;
      get stdin() {
        return this.#stdin ??= new ReadStream(0);
      }
      get stdout() {
        return this.#stdout ??= new WriteStream(1);
      }
      get stderr() {
        return this.#stderr ??= new WriteStream(2);
      }
      // --- cwd ---
      #cwd = "/";
      chdir(cwd2) {
        this.#cwd = cwd2;
      }
      cwd() {
        return this.#cwd;
      }
      // --- dummy props and getters ---
      arch = "";
      platform = "";
      argv = [];
      argv0 = "";
      execArgv = [];
      execPath = "";
      title = "";
      pid = 200;
      ppid = 100;
      get version() {
        return `v${NODE_VERSION}`;
      }
      get versions() {
        return { node: NODE_VERSION };
      }
      get allowedNodeEnvironmentFlags() {
        return /* @__PURE__ */ new Set();
      }
      get sourceMapsEnabled() {
        return false;
      }
      get debugPort() {
        return 0;
      }
      get throwDeprecation() {
        return false;
      }
      get traceDeprecation() {
        return false;
      }
      get features() {
        return {};
      }
      get release() {
        return {};
      }
      get connected() {
        return false;
      }
      get config() {
        return {};
      }
      get moduleLoadList() {
        return [];
      }
      constrainedMemory() {
        return 0;
      }
      availableMemory() {
        return 0;
      }
      uptime() {
        return 0;
      }
      resourceUsage() {
        return {};
      }
      // --- noop methods ---
      ref() {
      }
      unref() {
      }
      // --- unimplemented methods ---
      umask() {
        throw createNotImplementedError("process.umask");
      }
      getBuiltinModule() {
        return void 0;
      }
      getActiveResourcesInfo() {
        throw createNotImplementedError("process.getActiveResourcesInfo");
      }
      exit() {
        throw createNotImplementedError("process.exit");
      }
      reallyExit() {
        throw createNotImplementedError("process.reallyExit");
      }
      kill() {
        throw createNotImplementedError("process.kill");
      }
      abort() {
        throw createNotImplementedError("process.abort");
      }
      dlopen() {
        throw createNotImplementedError("process.dlopen");
      }
      setSourceMapsEnabled() {
        throw createNotImplementedError("process.setSourceMapsEnabled");
      }
      loadEnvFile() {
        throw createNotImplementedError("process.loadEnvFile");
      }
      disconnect() {
        throw createNotImplementedError("process.disconnect");
      }
      cpuUsage() {
        throw createNotImplementedError("process.cpuUsage");
      }
      setUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
      }
      hasUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
      }
      initgroups() {
        throw createNotImplementedError("process.initgroups");
      }
      openStdin() {
        throw createNotImplementedError("process.openStdin");
      }
      assert() {
        throw createNotImplementedError("process.assert");
      }
      binding() {
        throw createNotImplementedError("process.binding");
      }
      // --- attached interfaces ---
      permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
      report = {
        directory: "",
        filename: "",
        signal: "SIGUSR2",
        compact: false,
        reportOnFatalError: false,
        reportOnSignal: false,
        reportOnUncaughtException: false,
        getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
        writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
      };
      finalization = {
        register: /* @__PURE__ */ notImplemented("process.finalization.register"),
        unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
        registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
      };
      memoryUsage = Object.assign(() => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }), { rss: /* @__PURE__ */ __name(() => 0, "rss") });
      // --- undefined props ---
      mainModule = void 0;
      domain = void 0;
      // optional
      send = void 0;
      exitCode = void 0;
      channel = void 0;
      getegid = void 0;
      geteuid = void 0;
      getgid = void 0;
      getgroups = void 0;
      getuid = void 0;
      setegid = void 0;
      seteuid = void 0;
      setgid = void 0;
      setgroups = void 0;
      setuid = void 0;
      // internals
      _events = void 0;
      _eventsCount = void 0;
      _exiting = void 0;
      _maxListeners = void 0;
      _debugEnd = void 0;
      _debugProcess = void 0;
      _fatalException = void 0;
      _getActiveHandles = void 0;
      _getActiveRequests = void 0;
      _kill = void 0;
      _preload_modules = void 0;
      _rawDebug = void 0;
      _startProfilerIdleNotifier = void 0;
      _stopProfilerIdleNotifier = void 0;
      _tickCallback = void 0;
      _disconnect = void 0;
      _handleQueue = void 0;
      _pendingMessage = void 0;
      _channel = void 0;
      _send = void 0;
      _linkedBinding = void 0;
    };
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess, getBuiltinModule, workerdProcess, isWorkerdProcessV2, unenvProcess, exit, features, platform, env, hrtime3, nextTick, _channel, _disconnect, _events, _eventsCount, _handleQueue, _maxListeners, _pendingMessage, _send, assert2, disconnect, mainModule, _debugEnd, _debugProcess, _exiting, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _linkedBinding, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, abort, addListener, allowedNodeEnvironmentFlags, arch, argv, argv0, availableMemory, binding, channel, chdir, config, connected, constrainedMemory, cpuUsage, cwd, debugPort, dlopen, domain, emit, emitWarning, eventNames, execArgv, execPath, exitCode, finalization, getActiveResourcesInfo, getegid, geteuid, getgid, getgroups, getMaxListeners, getuid, hasUncaughtExceptionCaptureCallback, initgroups, kill, listenerCount, listeners, loadEnvFile, memoryUsage, moduleLoadList, off, on, once, openStdin, permission, pid, ppid, prependListener, prependOnceListener, rawListeners, reallyExit, ref, release, removeAllListeners, removeListener, report, resourceUsage, send, setegid, seteuid, setgid, setgroups, setMaxListeners, setSourceMapsEnabled, setuid, setUncaughtExceptionCaptureCallback, sourceMapsEnabled, stderr, stdin, stdout, throwDeprecation, title, traceDeprecation, umask, unref, uptime, version, versions, _process, process_default;
var init_process2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hrtime();
    init_process();
    globalProcess = globalThis["process"];
    getBuiltinModule = globalProcess.getBuiltinModule;
    workerdProcess = getBuiltinModule("node:process");
    isWorkerdProcessV2 = globalThis.Cloudflare.compatibilityFlags.enable_nodejs_process_v2;
    unenvProcess = new Process({
      env: globalProcess.env,
      // `hrtime` is only available from workerd process v2
      hrtime: isWorkerdProcessV2 ? workerdProcess.hrtime : hrtime,
      // `nextTick` is available from workerd process v1
      nextTick: workerdProcess.nextTick
    });
    ({ exit, features, platform } = workerdProcess);
    ({
      env: (
        // Always implemented by workerd
        env
      ),
      hrtime: (
        // Only implemented in workerd v2
        hrtime3
      ),
      nextTick: (
        // Always implemented by workerd
        nextTick
      )
    } = unenvProcess);
    ({
      _channel,
      _disconnect,
      _events,
      _eventsCount,
      _handleQueue,
      _maxListeners,
      _pendingMessage,
      _send,
      assert: assert2,
      disconnect,
      mainModule
    } = unenvProcess);
    ({
      _debugEnd: (
        // @ts-expect-error `_debugEnd` is missing typings
        _debugEnd
      ),
      _debugProcess: (
        // @ts-expect-error `_debugProcess` is missing typings
        _debugProcess
      ),
      _exiting: (
        // @ts-expect-error `_exiting` is missing typings
        _exiting
      ),
      _fatalException: (
        // @ts-expect-error `_fatalException` is missing typings
        _fatalException
      ),
      _getActiveHandles: (
        // @ts-expect-error `_getActiveHandles` is missing typings
        _getActiveHandles
      ),
      _getActiveRequests: (
        // @ts-expect-error `_getActiveRequests` is missing typings
        _getActiveRequests
      ),
      _kill: (
        // @ts-expect-error `_kill` is missing typings
        _kill
      ),
      _linkedBinding: (
        // @ts-expect-error `_linkedBinding` is missing typings
        _linkedBinding
      ),
      _preload_modules: (
        // @ts-expect-error `_preload_modules` is missing typings
        _preload_modules
      ),
      _rawDebug: (
        // @ts-expect-error `_rawDebug` is missing typings
        _rawDebug
      ),
      _startProfilerIdleNotifier: (
        // @ts-expect-error `_startProfilerIdleNotifier` is missing typings
        _startProfilerIdleNotifier
      ),
      _stopProfilerIdleNotifier: (
        // @ts-expect-error `_stopProfilerIdleNotifier` is missing typings
        _stopProfilerIdleNotifier
      ),
      _tickCallback: (
        // @ts-expect-error `_tickCallback` is missing typings
        _tickCallback
      ),
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      arch,
      argv,
      argv0,
      availableMemory,
      binding: (
        // @ts-expect-error `binding` is missing typings
        binding
      ),
      channel,
      chdir,
      config,
      connected,
      constrainedMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      domain: (
        // @ts-expect-error `domain` is missing typings
        domain
      ),
      emit,
      emitWarning,
      eventNames,
      execArgv,
      execPath,
      exitCode,
      finalization,
      getActiveResourcesInfo,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getMaxListeners,
      getuid,
      hasUncaughtExceptionCaptureCallback,
      initgroups: (
        // @ts-expect-error `initgroups` is missing typings
        initgroups
      ),
      kill,
      listenerCount,
      listeners,
      loadEnvFile,
      memoryUsage,
      moduleLoadList: (
        // @ts-expect-error `moduleLoadList` is missing typings
        moduleLoadList
      ),
      off,
      on,
      once,
      openStdin: (
        // @ts-expect-error `openStdin` is missing typings
        openStdin
      ),
      permission,
      pid,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      reallyExit: (
        // @ts-expect-error `reallyExit` is missing typings
        reallyExit
      ),
      ref,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      send,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setMaxListeners,
      setSourceMapsEnabled,
      setuid,
      setUncaughtExceptionCaptureCallback,
      sourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      throwDeprecation,
      title,
      traceDeprecation,
      umask,
      unref,
      uptime,
      version,
      versions
    } = isWorkerdProcessV2 ? workerdProcess : unenvProcess);
    _process = {
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      exit,
      finalization,
      features,
      getBuiltinModule,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      // @ts-expect-error old API
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    };
    process_default = _process;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process"() {
    init_process2();
    globalThis.process = process_default;
  }
});

// node_modules/hono/dist/request/constants.js
var GET_MATCH_RESULT;
var init_constants = __esm({
  "node_modules/hono/dist/request/constants.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    GET_MATCH_RESULT = Symbol();
  }
});

// node_modules/hono/dist/utils/body.js
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value);
        delete form[key];
      }
    });
  }
  return form;
}
var parseBody, handleParsingAllValues, handleParsingNestedValues;
var init_body = __esm({
  "node_modules/hono/dist/utils/body.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_request();
    parseBody = /* @__PURE__ */ __name(async (request, options = /* @__PURE__ */ Object.create(null)) => {
      const { all = false, dot = false } = options;
      const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
      const contentType = headers.get("Content-Type");
      if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
        return parseFormData(request, { all, dot });
      }
      return {};
    }, "parseBody");
    __name(parseFormData, "parseFormData");
    __name(convertFormDataToBodyData, "convertFormDataToBodyData");
    handleParsingAllValues = /* @__PURE__ */ __name((form, key, value) => {
      if (form[key] !== void 0) {
        if (Array.isArray(form[key])) {
          ;
          form[key].push(value);
        } else {
          form[key] = [form[key], value];
        }
      } else {
        if (!key.endsWith("[]")) {
          form[key] = value;
        } else {
          form[key] = [value];
        }
      }
    }, "handleParsingAllValues");
    handleParsingNestedValues = /* @__PURE__ */ __name((form, key, value) => {
      let nestedForm = form;
      const keys = key.split(".");
      keys.forEach((key2, index) => {
        if (index === keys.length - 1) {
          nestedForm[key2] = value;
        } else {
          if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
            nestedForm[key2] = /* @__PURE__ */ Object.create(null);
          }
          nestedForm = nestedForm[key2];
        }
      });
    }, "handleParsingNestedValues");
  }
});

// node_modules/hono/dist/utils/url.js
var splitPath, splitRoutingPath, extractGroupsFromPath, replaceGroupMarks, patternCache, getPattern, tryDecode, tryDecodeURI, getPath, getPathNoStrict, mergePath, checkOptionalParameter, _decodeURI, _getQueryParam, getQueryParam, getQueryParams, decodeURIComponent_;
var init_url = __esm({
  "node_modules/hono/dist/utils/url.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    splitPath = /* @__PURE__ */ __name((path) => {
      const paths = path.split("/");
      if (paths[0] === "") {
        paths.shift();
      }
      return paths;
    }, "splitPath");
    splitRoutingPath = /* @__PURE__ */ __name((routePath) => {
      const { groups, path } = extractGroupsFromPath(routePath);
      const paths = splitPath(path);
      return replaceGroupMarks(paths, groups);
    }, "splitRoutingPath");
    extractGroupsFromPath = /* @__PURE__ */ __name((path) => {
      const groups = [];
      path = path.replace(/\{[^}]+\}/g, (match, index) => {
        const mark = `@${index}`;
        groups.push([mark, match]);
        return mark;
      });
      return { groups, path };
    }, "extractGroupsFromPath");
    replaceGroupMarks = /* @__PURE__ */ __name((paths, groups) => {
      for (let i = groups.length - 1; i >= 0; i--) {
        const [mark] = groups[i];
        for (let j = paths.length - 1; j >= 0; j--) {
          if (paths[j].includes(mark)) {
            paths[j] = paths[j].replace(mark, groups[i][1]);
            break;
          }
        }
      }
      return paths;
    }, "replaceGroupMarks");
    patternCache = {};
    getPattern = /* @__PURE__ */ __name((label, next) => {
      if (label === "*") {
        return "*";
      }
      const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
      if (match) {
        const cacheKey = `${label}#${next}`;
        if (!patternCache[cacheKey]) {
          if (match[2]) {
            patternCache[cacheKey] = next && next[0] !== ":" && next[0] !== "*" ? [cacheKey, match[1], new RegExp(`^${match[2]}(?=/${next})`)] : [label, match[1], new RegExp(`^${match[2]}$`)];
          } else {
            patternCache[cacheKey] = [label, match[1], true];
          }
        }
        return patternCache[cacheKey];
      }
      return null;
    }, "getPattern");
    tryDecode = /* @__PURE__ */ __name((str, decoder) => {
      try {
        return decoder(str);
      } catch {
        return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {
          try {
            return decoder(match);
          } catch {
            return match;
          }
        });
      }
    }, "tryDecode");
    tryDecodeURI = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURI), "tryDecodeURI");
    getPath = /* @__PURE__ */ __name((request) => {
      const url2 = request.url;
      const start = url2.indexOf(
        "/",
        url2.charCodeAt(9) === 58 ? 13 : 8
      );
      let i = start;
      for (; i < url2.length; i++) {
        const charCode = url2.charCodeAt(i);
        if (charCode === 37) {
          const queryIndex = url2.indexOf("?", i);
          const path = url2.slice(start, queryIndex === -1 ? void 0 : queryIndex);
          return tryDecodeURI(path.includes("%25") ? path.replace(/%25/g, "%2525") : path);
        } else if (charCode === 63) {
          break;
        }
      }
      return url2.slice(start, i);
    }, "getPath");
    getPathNoStrict = /* @__PURE__ */ __name((request) => {
      const result = getPath(request);
      return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
    }, "getPathNoStrict");
    mergePath = /* @__PURE__ */ __name((base, sub, ...rest) => {
      if (rest.length) {
        sub = mergePath(sub, ...rest);
      }
      return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
    }, "mergePath");
    checkOptionalParameter = /* @__PURE__ */ __name((path) => {
      if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(":")) {
        return null;
      }
      const segments = path.split("/");
      const results = [];
      let basePath = "";
      segments.forEach((segment) => {
        if (segment !== "" && !/\:/.test(segment)) {
          basePath += "/" + segment;
        } else if (/\:/.test(segment)) {
          if (/\?/.test(segment)) {
            if (results.length === 0 && basePath === "") {
              results.push("/");
            } else {
              results.push(basePath);
            }
            const optionalSegment = segment.replace("?", "");
            basePath += "/" + optionalSegment;
            results.push(basePath);
          } else {
            basePath += "/" + segment;
          }
        }
      });
      return results.filter((v, i, a) => a.indexOf(v) === i);
    }, "checkOptionalParameter");
    _decodeURI = /* @__PURE__ */ __name((value) => {
      if (!/[%+]/.test(value)) {
        return value;
      }
      if (value.indexOf("+") !== -1) {
        value = value.replace(/\+/g, " ");
      }
      return value.indexOf("%") !== -1 ? tryDecode(value, decodeURIComponent_) : value;
    }, "_decodeURI");
    _getQueryParam = /* @__PURE__ */ __name((url2, key, multiple) => {
      let encoded;
      if (!multiple && key && !/[%+]/.test(key)) {
        let keyIndex2 = url2.indexOf(`?${key}`, 8);
        if (keyIndex2 === -1) {
          keyIndex2 = url2.indexOf(`&${key}`, 8);
        }
        while (keyIndex2 !== -1) {
          const trailingKeyCode = url2.charCodeAt(keyIndex2 + key.length + 1);
          if (trailingKeyCode === 61) {
            const valueIndex = keyIndex2 + key.length + 2;
            const endIndex = url2.indexOf("&", valueIndex);
            return _decodeURI(url2.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));
          } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
            return "";
          }
          keyIndex2 = url2.indexOf(`&${key}`, keyIndex2 + 1);
        }
        encoded = /[%+]/.test(url2);
        if (!encoded) {
          return void 0;
        }
      }
      const results = {};
      encoded ??= /[%+]/.test(url2);
      let keyIndex = url2.indexOf("?", 8);
      while (keyIndex !== -1) {
        const nextKeyIndex = url2.indexOf("&", keyIndex + 1);
        let valueIndex = url2.indexOf("=", keyIndex);
        if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
          valueIndex = -1;
        }
        let name = url2.slice(
          keyIndex + 1,
          valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex
        );
        if (encoded) {
          name = _decodeURI(name);
        }
        keyIndex = nextKeyIndex;
        if (name === "") {
          continue;
        }
        let value;
        if (valueIndex === -1) {
          value = "";
        } else {
          value = url2.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);
          if (encoded) {
            value = _decodeURI(value);
          }
        }
        if (multiple) {
          if (!(results[name] && Array.isArray(results[name]))) {
            results[name] = [];
          }
          ;
          results[name].push(value);
        } else {
          results[name] ??= value;
        }
      }
      return key ? results[key] : results;
    }, "_getQueryParam");
    getQueryParam = _getQueryParam;
    getQueryParams = /* @__PURE__ */ __name((url2, key) => {
      return _getQueryParam(url2, key, true);
    }, "getQueryParams");
    decodeURIComponent_ = decodeURIComponent;
  }
});

// node_modules/hono/dist/request.js
var tryDecodeURIComponent, HonoRequest;
var init_request = __esm({
  "node_modules/hono/dist/request.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_constants();
    init_body();
    init_url();
    tryDecodeURIComponent = /* @__PURE__ */ __name((str) => tryDecode(str, decodeURIComponent_), "tryDecodeURIComponent");
    HonoRequest = class {
      static {
        __name(this, "HonoRequest");
      }
      raw;
      #validatedData;
      #matchResult;
      routeIndex = 0;
      path;
      bodyCache = {};
      constructor(request, path = "/", matchResult = [[]]) {
        this.raw = request;
        this.path = path;
        this.#matchResult = matchResult;
        this.#validatedData = {};
      }
      param(key) {
        return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
      }
      #getDecodedParam(key) {
        const paramKey = this.#matchResult[0][this.routeIndex][1][key];
        const param = this.#getParamValue(paramKey);
        return param ? /\%/.test(param) ? tryDecodeURIComponent(param) : param : void 0;
      }
      #getAllDecodedParams() {
        const decoded = {};
        const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
        for (const key of keys) {
          const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
          if (value && typeof value === "string") {
            decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
          }
        }
        return decoded;
      }
      #getParamValue(paramKey) {
        return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
      }
      query(key) {
        return getQueryParam(this.url, key);
      }
      queries(key) {
        return getQueryParams(this.url, key);
      }
      header(name) {
        if (name) {
          return this.raw.headers.get(name) ?? void 0;
        }
        const headerData = {};
        this.raw.headers.forEach((value, key) => {
          headerData[key] = value;
        });
        return headerData;
      }
      async parseBody(options) {
        return this.bodyCache.parsedBody ??= await parseBody(this, options);
      }
      #cachedBody = /* @__PURE__ */ __name((key) => {
        const { bodyCache, raw: raw2 } = this;
        const cachedBody = bodyCache[key];
        if (cachedBody) {
          return cachedBody;
        }
        const anyCachedKey = Object.keys(bodyCache)[0];
        if (anyCachedKey) {
          return bodyCache[anyCachedKey].then((body) => {
            if (anyCachedKey === "json") {
              body = JSON.stringify(body);
            }
            return new Response(body)[key]();
          });
        }
        return bodyCache[key] = raw2[key]();
      }, "#cachedBody");
      json() {
        return this.#cachedBody("text").then((text) => JSON.parse(text));
      }
      text() {
        return this.#cachedBody("text");
      }
      arrayBuffer() {
        return this.#cachedBody("arrayBuffer");
      }
      blob() {
        return this.#cachedBody("blob");
      }
      formData() {
        return this.#cachedBody("formData");
      }
      addValidatedData(target, data) {
        this.#validatedData[target] = data;
      }
      valid(target) {
        return this.#validatedData[target];
      }
      get url() {
        return this.raw.url;
      }
      get method() {
        return this.raw.method;
      }
      get [GET_MATCH_RESULT]() {
        return this.#matchResult;
      }
      get matchedRoutes() {
        return this.#matchResult[0].map(([[, route]]) => route);
      }
      get routePath() {
        return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
      }
    };
  }
});

// node_modules/hono/dist/utils/html.js
var HtmlEscapedCallbackPhase, raw, resolveCallback;
var init_html = __esm({
  "node_modules/hono/dist/utils/html.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    HtmlEscapedCallbackPhase = {
      Stringify: 1,
      BeforeStream: 2,
      Stream: 3
    };
    raw = /* @__PURE__ */ __name((value, callbacks) => {
      const escapedString = new String(value);
      escapedString.isEscaped = true;
      escapedString.callbacks = callbacks;
      return escapedString;
    }, "raw");
    resolveCallback = /* @__PURE__ */ __name(async (str, phase, preserveCallbacks, context2, buffer) => {
      if (typeof str === "object" && !(str instanceof String)) {
        if (!(str instanceof Promise)) {
          str = str.toString();
        }
        if (str instanceof Promise) {
          str = await str;
        }
      }
      const callbacks = str.callbacks;
      if (!callbacks?.length) {
        return Promise.resolve(str);
      }
      if (buffer) {
        buffer[0] += str;
      } else {
        buffer = [str];
      }
      const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context: context2 }))).then(
        (res) => Promise.all(
          res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context2, buffer))
        ).then(() => buffer[0])
      );
      if (preserveCallbacks) {
        return raw(await resStr, callbacks);
      } else {
        return resStr;
      }
    }, "resolveCallback");
  }
});

// node_modules/hono/dist/context.js
var TEXT_PLAIN, setDefaultContentType, Context;
var init_context = __esm({
  "node_modules/hono/dist/context.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_request();
    init_html();
    TEXT_PLAIN = "text/plain; charset=UTF-8";
    setDefaultContentType = /* @__PURE__ */ __name((contentType, headers) => {
      return {
        "Content-Type": contentType,
        ...headers
      };
    }, "setDefaultContentType");
    Context = class {
      static {
        __name(this, "Context");
      }
      #rawRequest;
      #req;
      env = {};
      #var;
      finalized = false;
      error;
      #status;
      #executionCtx;
      #res;
      #layout;
      #renderer;
      #notFoundHandler;
      #preparedHeaders;
      #matchResult;
      #path;
      constructor(req, options) {
        this.#rawRequest = req;
        if (options) {
          this.#executionCtx = options.executionCtx;
          this.env = options.env;
          this.#notFoundHandler = options.notFoundHandler;
          this.#path = options.path;
          this.#matchResult = options.matchResult;
        }
      }
      get req() {
        this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
        return this.#req;
      }
      get event() {
        if (this.#executionCtx && "respondWith" in this.#executionCtx) {
          return this.#executionCtx;
        } else {
          throw Error("This context has no FetchEvent");
        }
      }
      get executionCtx() {
        if (this.#executionCtx) {
          return this.#executionCtx;
        } else {
          throw Error("This context has no ExecutionContext");
        }
      }
      get res() {
        return this.#res ||= new Response(null, {
          headers: this.#preparedHeaders ??= new Headers()
        });
      }
      set res(_res) {
        if (this.#res && _res) {
          _res = new Response(_res.body, _res);
          for (const [k, v] of this.#res.headers.entries()) {
            if (k === "content-type") {
              continue;
            }
            if (k === "set-cookie") {
              const cookies = this.#res.headers.getSetCookie();
              _res.headers.delete("set-cookie");
              for (const cookie of cookies) {
                _res.headers.append("set-cookie", cookie);
              }
            } else {
              _res.headers.set(k, v);
            }
          }
        }
        this.#res = _res;
        this.finalized = true;
      }
      render = /* @__PURE__ */ __name((...args) => {
        this.#renderer ??= (content) => this.html(content);
        return this.#renderer(...args);
      }, "render");
      setLayout = /* @__PURE__ */ __name((layout) => this.#layout = layout, "setLayout");
      getLayout = /* @__PURE__ */ __name(() => this.#layout, "getLayout");
      setRenderer = /* @__PURE__ */ __name((renderer) => {
        this.#renderer = renderer;
      }, "setRenderer");
      header = /* @__PURE__ */ __name((name, value, options) => {
        if (this.finalized) {
          this.#res = new Response(this.#res.body, this.#res);
        }
        const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers();
        if (value === void 0) {
          headers.delete(name);
        } else if (options?.append) {
          headers.append(name, value);
        } else {
          headers.set(name, value);
        }
      }, "header");
      status = /* @__PURE__ */ __name((status) => {
        this.#status = status;
      }, "status");
      set = /* @__PURE__ */ __name((key, value) => {
        this.#var ??= /* @__PURE__ */ new Map();
        this.#var.set(key, value);
      }, "set");
      get = /* @__PURE__ */ __name((key) => {
        return this.#var ? this.#var.get(key) : void 0;
      }, "get");
      get var() {
        if (!this.#var) {
          return {};
        }
        return Object.fromEntries(this.#var);
      }
      #newResponse(data, arg, headers) {
        const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers();
        if (typeof arg === "object" && "headers" in arg) {
          const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);
          for (const [key, value] of argHeaders) {
            if (key.toLowerCase() === "set-cookie") {
              responseHeaders.append(key, value);
            } else {
              responseHeaders.set(key, value);
            }
          }
        }
        if (headers) {
          for (const [k, v] of Object.entries(headers)) {
            if (typeof v === "string") {
              responseHeaders.set(k, v);
            } else {
              responseHeaders.delete(k);
              for (const v2 of v) {
                responseHeaders.append(k, v2);
              }
            }
          }
        }
        const status = typeof arg === "number" ? arg : arg?.status ?? this.#status;
        return new Response(data, { status, headers: responseHeaders });
      }
      newResponse = /* @__PURE__ */ __name((...args) => this.#newResponse(...args), "newResponse");
      body = /* @__PURE__ */ __name((data, arg, headers) => this.#newResponse(data, arg, headers), "body");
      text = /* @__PURE__ */ __name((text, arg, headers) => {
        return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text) : this.#newResponse(
          text,
          arg,
          setDefaultContentType(TEXT_PLAIN, headers)
        );
      }, "text");
      json = /* @__PURE__ */ __name((object2, arg, headers) => {
        return this.#newResponse(
          JSON.stringify(object2),
          arg,
          setDefaultContentType("application/json", headers)
        );
      }, "json");
      html = /* @__PURE__ */ __name((html, arg, headers) => {
        const res = /* @__PURE__ */ __name((html2) => this.#newResponse(html2, arg, setDefaultContentType("text/html; charset=UTF-8", headers)), "res");
        return typeof html === "object" ? resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then(res) : res(html);
      }, "html");
      redirect = /* @__PURE__ */ __name((location, status) => {
        const locationString = String(location);
        this.header(
          "Location",
          !/[^\x00-\xFF]/.test(locationString) ? locationString : encodeURI(locationString)
        );
        return this.newResponse(null, status ?? 302);
      }, "redirect");
      notFound = /* @__PURE__ */ __name(() => {
        this.#notFoundHandler ??= () => new Response();
        return this.#notFoundHandler(this);
      }, "notFound");
    };
  }
});

// node_modules/hono/dist/utils/cookie.js
var init_cookie = __esm({
  "node_modules/hono/dist/utils/cookie.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_url();
  }
});

// node_modules/hono/dist/helper/cookie/index.js
var init_cookie2 = __esm({
  "node_modules/hono/dist/helper/cookie/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_cookie();
  }
});

// node_modules/hono/dist/http-exception.js
var HTTPException;
var init_http_exception = __esm({
  "node_modules/hono/dist/http-exception.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    HTTPException = class extends Error {
      static {
        __name(this, "HTTPException");
      }
      res;
      status;
      constructor(status = 500, options) {
        super(options?.message, { cause: options?.cause });
        this.res = options?.res;
        this.status = status;
      }
      getResponse() {
        if (this.res) {
          const newResponse = new Response(this.res.body, {
            status: this.status,
            headers: this.res.headers
          });
          return newResponse;
        }
        return new Response(this.message, {
          status: this.status
        });
      }
    };
  }
});

// node_modules/hono/dist/utils/encode.js
var decodeBase64Url, encodeBase64Url, encodeBase64, decodeBase64;
var init_encode = __esm({
  "node_modules/hono/dist/utils/encode.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    decodeBase64Url = /* @__PURE__ */ __name((str) => {
      return decodeBase64(str.replace(/_|-/g, (m) => ({ _: "/", "-": "+" })[m] ?? m));
    }, "decodeBase64Url");
    encodeBase64Url = /* @__PURE__ */ __name((buf) => encodeBase64(buf).replace(/\/|\+/g, (m) => ({ "/": "_", "+": "-" })[m] ?? m), "encodeBase64Url");
    encodeBase64 = /* @__PURE__ */ __name((buf) => {
      let binary = "";
      const bytes = new Uint8Array(buf);
      for (let i = 0, len = bytes.length; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    }, "encodeBase64");
    decodeBase64 = /* @__PURE__ */ __name((str) => {
      const binary = atob(str);
      const bytes = new Uint8Array(new ArrayBuffer(binary.length));
      const half = binary.length / 2;
      for (let i = 0, j = binary.length - 1; i <= half; i++, j--) {
        bytes[i] = binary.charCodeAt(i);
        bytes[j] = binary.charCodeAt(j);
      }
      return bytes;
    }, "decodeBase64");
  }
});

// node_modules/hono/dist/utils/jwt/jwa.js
var AlgorithmTypes;
var init_jwa = __esm({
  "node_modules/hono/dist/utils/jwt/jwa.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    AlgorithmTypes = /* @__PURE__ */ ((AlgorithmTypes2) => {
      AlgorithmTypes2["HS256"] = "HS256";
      AlgorithmTypes2["HS384"] = "HS384";
      AlgorithmTypes2["HS512"] = "HS512";
      AlgorithmTypes2["RS256"] = "RS256";
      AlgorithmTypes2["RS384"] = "RS384";
      AlgorithmTypes2["RS512"] = "RS512";
      AlgorithmTypes2["PS256"] = "PS256";
      AlgorithmTypes2["PS384"] = "PS384";
      AlgorithmTypes2["PS512"] = "PS512";
      AlgorithmTypes2["ES256"] = "ES256";
      AlgorithmTypes2["ES384"] = "ES384";
      AlgorithmTypes2["ES512"] = "ES512";
      AlgorithmTypes2["EdDSA"] = "EdDSA";
      return AlgorithmTypes2;
    })(AlgorithmTypes || {});
  }
});

// node_modules/hono/dist/helper/adapter/index.js
var knownUserAgents, getRuntimeKey, checkUserAgentEquals;
var init_adapter = __esm({
  "node_modules/hono/dist/helper/adapter/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    knownUserAgents = {
      deno: "Deno",
      bun: "Bun",
      workerd: "Cloudflare-Workers",
      node: "Node.js"
    };
    getRuntimeKey = /* @__PURE__ */ __name(() => {
      const global = globalThis;
      const userAgentSupported = typeof navigator !== "undefined" && true;
      if (userAgentSupported) {
        for (const [runtimeKey, userAgent] of Object.entries(knownUserAgents)) {
          if (checkUserAgentEquals(userAgent)) {
            return runtimeKey;
          }
        }
      }
      if (typeof global?.EdgeRuntime === "string") {
        return "edge-light";
      }
      if (global?.fastly !== void 0) {
        return "fastly";
      }
      if (global?.process?.release?.name === "node") {
        return "node";
      }
      return "other";
    }, "getRuntimeKey");
    checkUserAgentEquals = /* @__PURE__ */ __name((platform2) => {
      const userAgent = "Cloudflare-Workers";
      return userAgent.startsWith(platform2);
    }, "checkUserAgentEquals");
  }
});

// node_modules/hono/dist/utils/jwt/types.js
var JwtAlgorithmNotImplemented, JwtTokenInvalid, JwtTokenNotBefore, JwtTokenExpired, JwtTokenIssuedAt, JwtTokenIssuer, JwtHeaderInvalid, JwtHeaderRequiresKid, JwtTokenSignatureMismatched, CryptoKeyUsage;
var init_types = __esm({
  "node_modules/hono/dist/utils/jwt/types.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    JwtAlgorithmNotImplemented = class extends Error {
      static {
        __name(this, "JwtAlgorithmNotImplemented");
      }
      constructor(alg) {
        super(`${alg} is not an implemented algorithm`);
        this.name = "JwtAlgorithmNotImplemented";
      }
    };
    JwtTokenInvalid = class extends Error {
      static {
        __name(this, "JwtTokenInvalid");
      }
      constructor(token) {
        super(`invalid JWT token: ${token}`);
        this.name = "JwtTokenInvalid";
      }
    };
    JwtTokenNotBefore = class extends Error {
      static {
        __name(this, "JwtTokenNotBefore");
      }
      constructor(token) {
        super(`token (${token}) is being used before it's valid`);
        this.name = "JwtTokenNotBefore";
      }
    };
    JwtTokenExpired = class extends Error {
      static {
        __name(this, "JwtTokenExpired");
      }
      constructor(token) {
        super(`token (${token}) expired`);
        this.name = "JwtTokenExpired";
      }
    };
    JwtTokenIssuedAt = class extends Error {
      static {
        __name(this, "JwtTokenIssuedAt");
      }
      constructor(currentTimestamp, iat) {
        super(
          `Invalid "iat" claim, must be a valid number lower than "${currentTimestamp}" (iat: "${iat}")`
        );
        this.name = "JwtTokenIssuedAt";
      }
    };
    JwtTokenIssuer = class extends Error {
      static {
        __name(this, "JwtTokenIssuer");
      }
      constructor(expected, iss) {
        super(`expected issuer "${expected}", got ${iss ? `"${iss}"` : "none"} `);
        this.name = "JwtTokenIssuer";
      }
    };
    JwtHeaderInvalid = class extends Error {
      static {
        __name(this, "JwtHeaderInvalid");
      }
      constructor(header) {
        super(`jwt header is invalid: ${JSON.stringify(header)}`);
        this.name = "JwtHeaderInvalid";
      }
    };
    JwtHeaderRequiresKid = class extends Error {
      static {
        __name(this, "JwtHeaderRequiresKid");
      }
      constructor(header) {
        super(`required "kid" in jwt header: ${JSON.stringify(header)}`);
        this.name = "JwtHeaderRequiresKid";
      }
    };
    JwtTokenSignatureMismatched = class extends Error {
      static {
        __name(this, "JwtTokenSignatureMismatched");
      }
      constructor(token) {
        super(`token(${token}) signature mismatched`);
        this.name = "JwtTokenSignatureMismatched";
      }
    };
    CryptoKeyUsage = /* @__PURE__ */ ((CryptoKeyUsage2) => {
      CryptoKeyUsage2["Encrypt"] = "encrypt";
      CryptoKeyUsage2["Decrypt"] = "decrypt";
      CryptoKeyUsage2["Sign"] = "sign";
      CryptoKeyUsage2["Verify"] = "verify";
      CryptoKeyUsage2["DeriveKey"] = "deriveKey";
      CryptoKeyUsage2["DeriveBits"] = "deriveBits";
      CryptoKeyUsage2["WrapKey"] = "wrapKey";
      CryptoKeyUsage2["UnwrapKey"] = "unwrapKey";
      return CryptoKeyUsage2;
    })(CryptoKeyUsage || {});
  }
});

// node_modules/hono/dist/utils/jwt/utf8.js
var utf8Encoder, utf8Decoder;
var init_utf8 = __esm({
  "node_modules/hono/dist/utils/jwt/utf8.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    utf8Encoder = new TextEncoder();
    utf8Decoder = new TextDecoder();
  }
});

// node_modules/hono/dist/utils/jwt/jws.js
async function signing(privateKey, alg, data) {
  const algorithm = getKeyAlgorithm(alg);
  const cryptoKey = await importPrivateKey(privateKey, algorithm);
  return await crypto.subtle.sign(algorithm, cryptoKey, data);
}
async function verifying(publicKey, alg, signature, data) {
  const algorithm = getKeyAlgorithm(alg);
  const cryptoKey = await importPublicKey(publicKey, algorithm);
  return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);
}
function pemToBinary(pem) {
  return decodeBase64(pem.replace(/-+(BEGIN|END).*/g, "").replace(/\s/g, ""));
}
async function importPrivateKey(key, alg) {
  if (!crypto.subtle || !crypto.subtle.importKey) {
    throw new Error("`crypto.subtle.importKey` is undefined. JWT auth middleware requires it.");
  }
  if (isCryptoKey(key)) {
    if (key.type !== "private" && key.type !== "secret") {
      throw new Error(
        `unexpected key type: CryptoKey.type is ${key.type}, expected private or secret`
      );
    }
    return key;
  }
  const usages = [CryptoKeyUsage.Sign];
  if (typeof key === "object") {
    return await crypto.subtle.importKey("jwk", key, alg, false, usages);
  }
  if (key.includes("PRIVATE")) {
    return await crypto.subtle.importKey("pkcs8", pemToBinary(key), alg, false, usages);
  }
  return await crypto.subtle.importKey("raw", utf8Encoder.encode(key), alg, false, usages);
}
async function importPublicKey(key, alg) {
  if (!crypto.subtle || !crypto.subtle.importKey) {
    throw new Error("`crypto.subtle.importKey` is undefined. JWT auth middleware requires it.");
  }
  if (isCryptoKey(key)) {
    if (key.type === "public" || key.type === "secret") {
      return key;
    }
    key = await exportPublicJwkFrom(key);
  }
  if (typeof key === "string" && key.includes("PRIVATE")) {
    const privateKey = await crypto.subtle.importKey("pkcs8", pemToBinary(key), alg, true, [
      CryptoKeyUsage.Sign
    ]);
    key = await exportPublicJwkFrom(privateKey);
  }
  const usages = [CryptoKeyUsage.Verify];
  if (typeof key === "object") {
    return await crypto.subtle.importKey("jwk", key, alg, false, usages);
  }
  if (key.includes("PUBLIC")) {
    return await crypto.subtle.importKey("spki", pemToBinary(key), alg, false, usages);
  }
  return await crypto.subtle.importKey("raw", utf8Encoder.encode(key), alg, false, usages);
}
async function exportPublicJwkFrom(privateKey) {
  if (privateKey.type !== "private") {
    throw new Error(`unexpected key type: ${privateKey.type}`);
  }
  if (!privateKey.extractable) {
    throw new Error("unexpected private key is unextractable");
  }
  const jwk = await crypto.subtle.exportKey("jwk", privateKey);
  const { kty } = jwk;
  const { alg, e, n } = jwk;
  const { crv, x, y } = jwk;
  return { kty, alg, e, n, crv, x, y, key_ops: [CryptoKeyUsage.Verify] };
}
function getKeyAlgorithm(name) {
  switch (name) {
    case "HS256":
      return {
        name: "HMAC",
        hash: {
          name: "SHA-256"
        }
      };
    case "HS384":
      return {
        name: "HMAC",
        hash: {
          name: "SHA-384"
        }
      };
    case "HS512":
      return {
        name: "HMAC",
        hash: {
          name: "SHA-512"
        }
      };
    case "RS256":
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
          name: "SHA-256"
        }
      };
    case "RS384":
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
          name: "SHA-384"
        }
      };
    case "RS512":
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
          name: "SHA-512"
        }
      };
    case "PS256":
      return {
        name: "RSA-PSS",
        hash: {
          name: "SHA-256"
        },
        saltLength: 32
      };
    case "PS384":
      return {
        name: "RSA-PSS",
        hash: {
          name: "SHA-384"
        },
        saltLength: 48
      };
    case "PS512":
      return {
        name: "RSA-PSS",
        hash: {
          name: "SHA-512"
        },
        saltLength: 64
      };
    case "ES256":
      return {
        name: "ECDSA",
        hash: {
          name: "SHA-256"
        },
        namedCurve: "P-256"
      };
    case "ES384":
      return {
        name: "ECDSA",
        hash: {
          name: "SHA-384"
        },
        namedCurve: "P-384"
      };
    case "ES512":
      return {
        name: "ECDSA",
        hash: {
          name: "SHA-512"
        },
        namedCurve: "P-521"
      };
    case "EdDSA":
      return {
        name: "Ed25519",
        namedCurve: "Ed25519"
      };
    default:
      throw new JwtAlgorithmNotImplemented(name);
  }
}
function isCryptoKey(key) {
  const runtime = getRuntimeKey();
  if (runtime === "node" && !!crypto.webcrypto) {
    return key instanceof crypto.webcrypto.CryptoKey;
  }
  return key instanceof CryptoKey;
}
var init_jws = __esm({
  "node_modules/hono/dist/utils/jwt/jws.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_adapter();
    init_encode();
    init_types();
    init_utf8();
    __name(signing, "signing");
    __name(verifying, "verifying");
    __name(pemToBinary, "pemToBinary");
    __name(importPrivateKey, "importPrivateKey");
    __name(importPublicKey, "importPublicKey");
    __name(exportPublicJwkFrom, "exportPublicJwkFrom");
    __name(getKeyAlgorithm, "getKeyAlgorithm");
    __name(isCryptoKey, "isCryptoKey");
  }
});

// node_modules/hono/dist/utils/jwt/jwt.js
function isTokenHeader(obj) {
  if (typeof obj === "object" && obj !== null) {
    const objWithAlg = obj;
    return "alg" in objWithAlg && Object.values(AlgorithmTypes).includes(objWithAlg.alg) && (!("typ" in objWithAlg) || objWithAlg.typ === "JWT");
  }
  return false;
}
var encodeJwtPart, encodeSignaturePart, decodeJwtPart, sign, verify, verifyWithJwks, decode, decodeHeader;
var init_jwt = __esm({
  "node_modules/hono/dist/utils/jwt/jwt.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_encode();
    init_jwa();
    init_jws();
    init_types();
    init_utf8();
    encodeJwtPart = /* @__PURE__ */ __name((part) => encodeBase64Url(utf8Encoder.encode(JSON.stringify(part)).buffer).replace(/=/g, ""), "encodeJwtPart");
    encodeSignaturePart = /* @__PURE__ */ __name((buf) => encodeBase64Url(buf).replace(/=/g, ""), "encodeSignaturePart");
    decodeJwtPart = /* @__PURE__ */ __name((part) => JSON.parse(utf8Decoder.decode(decodeBase64Url(part))), "decodeJwtPart");
    __name(isTokenHeader, "isTokenHeader");
    sign = /* @__PURE__ */ __name(async (payload, privateKey, alg = "HS256") => {
      const encodedPayload = encodeJwtPart(payload);
      let encodedHeader;
      if (typeof privateKey === "object" && "alg" in privateKey) {
        alg = privateKey.alg;
        encodedHeader = encodeJwtPart({ alg, typ: "JWT", kid: privateKey.kid });
      } else {
        encodedHeader = encodeJwtPart({ alg, typ: "JWT" });
      }
      const partialToken = `${encodedHeader}.${encodedPayload}`;
      const signaturePart = await signing(privateKey, alg, utf8Encoder.encode(partialToken));
      const signature = encodeSignaturePart(signaturePart);
      return `${partialToken}.${signature}`;
    }, "sign");
    verify = /* @__PURE__ */ __name(async (token, publicKey, algOrOptions) => {
      const optsIn = typeof algOrOptions === "string" ? { alg: algOrOptions } : algOrOptions || {};
      const opts = {
        alg: optsIn.alg ?? "HS256",
        iss: optsIn.iss,
        nbf: optsIn.nbf ?? true,
        exp: optsIn.exp ?? true,
        iat: optsIn.iat ?? true
      };
      const tokenParts = token.split(".");
      if (tokenParts.length !== 3) {
        throw new JwtTokenInvalid(token);
      }
      const { header, payload } = decode(token);
      if (!isTokenHeader(header)) {
        throw new JwtHeaderInvalid(header);
      }
      const now = Date.now() / 1e3 | 0;
      if (opts.nbf && payload.nbf && payload.nbf > now) {
        throw new JwtTokenNotBefore(token);
      }
      if (opts.exp && payload.exp && payload.exp <= now) {
        throw new JwtTokenExpired(token);
      }
      if (opts.iat && payload.iat && now < payload.iat) {
        throw new JwtTokenIssuedAt(now, payload.iat);
      }
      if (opts.iss) {
        if (!payload.iss) {
          throw new JwtTokenIssuer(opts.iss, null);
        }
        if (typeof opts.iss === "string" && payload.iss !== opts.iss) {
          throw new JwtTokenIssuer(opts.iss, payload.iss);
        }
        if (opts.iss instanceof RegExp && !opts.iss.test(payload.iss)) {
          throw new JwtTokenIssuer(opts.iss, payload.iss);
        }
      }
      const headerPayload = token.substring(0, token.lastIndexOf("."));
      const verified = await verifying(
        publicKey,
        opts.alg,
        decodeBase64Url(tokenParts[2]),
        utf8Encoder.encode(headerPayload)
      );
      if (!verified) {
        throw new JwtTokenSignatureMismatched(token);
      }
      return payload;
    }, "verify");
    verifyWithJwks = /* @__PURE__ */ __name(async (token, options, init) => {
      const verifyOpts = options.verification || {};
      const header = decodeHeader(token);
      if (!isTokenHeader(header)) {
        throw new JwtHeaderInvalid(header);
      }
      if (!header.kid) {
        throw new JwtHeaderRequiresKid(header);
      }
      if (options.jwks_uri) {
        const response = await fetch(options.jwks_uri, init);
        if (!response.ok) {
          throw new Error(`failed to fetch JWKS from ${options.jwks_uri}`);
        }
        const data = await response.json();
        if (!data.keys) {
          throw new Error('invalid JWKS response. "keys" field is missing');
        }
        if (!Array.isArray(data.keys)) {
          throw new Error('invalid JWKS response. "keys" field is not an array');
        }
        if (options.keys) {
          options.keys.push(...data.keys);
        } else {
          options.keys = data.keys;
        }
      } else if (!options.keys) {
        throw new Error('verifyWithJwks requires options for either "keys" or "jwks_uri" or both');
      }
      const matchingKey = options.keys.find((key) => key.kid === header.kid);
      if (!matchingKey) {
        throw new JwtTokenInvalid(token);
      }
      return await verify(token, matchingKey, {
        alg: matchingKey.alg || header.alg,
        ...verifyOpts
      });
    }, "verifyWithJwks");
    decode = /* @__PURE__ */ __name((token) => {
      try {
        const [h, p] = token.split(".");
        const header = decodeJwtPart(h);
        const payload = decodeJwtPart(p);
        return {
          header,
          payload
        };
      } catch {
        throw new JwtTokenInvalid(token);
      }
    }, "decode");
    decodeHeader = /* @__PURE__ */ __name((token) => {
      try {
        const [h] = token.split(".");
        return decodeJwtPart(h);
      } catch {
        throw new JwtTokenInvalid(token);
      }
    }, "decodeHeader");
  }
});

// node_modules/hono/dist/utils/jwt/index.js
var Jwt;
var init_jwt2 = __esm({
  "node_modules/hono/dist/utils/jwt/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_jwt();
    Jwt = { sign, verify, decode, verifyWithJwks };
  }
});

// node_modules/hono/dist/middleware/jwt/jwt.js
var verifyWithJwks2, verify2, decode2, sign2;
var init_jwt3 = __esm({
  "node_modules/hono/dist/middleware/jwt/jwt.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_cookie2();
    init_http_exception();
    init_jwt2();
    init_context();
    verifyWithJwks2 = Jwt.verifyWithJwks;
    verify2 = Jwt.verify;
    decode2 = Jwt.decode;
    sign2 = Jwt.sign;
  }
});

// node_modules/hono/dist/middleware/jwt/index.js
var init_jwt4 = __esm({
  "node_modules/hono/dist/middleware/jwt/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_jwt3();
  }
});

// src/utils/errors.ts
var errors_exports = {};
__export(errors_exports, {
  AppError: () => AppError,
  AuthenticationError: () => AuthenticationError,
  AuthorizationError: () => AuthorizationError,
  ConflictError: () => ConflictError,
  ExternalServiceError: () => ExternalServiceError,
  NotFoundError: () => NotFoundError,
  RateLimitError: () => RateLimitError,
  ValidationError: () => ValidationError,
  asyncHandler: () => asyncHandler,
  errorHandler: () => errorHandler2,
  formatErrorResponse: () => formatErrorResponse,
  handleError: () => handleError,
  validateRequired: () => validateRequired,
  validateType: () => validateType
});
function formatErrorResponse(error48) {
  if (error48 instanceof AppError) {
    return {
      error: {
        code: error48.errorCode,
        message: error48.message,
        details: error48.details
      },
      status: error48.statusCode
    };
  }
  if (error48 instanceof HTTPException) {
    return {
      error: {
        code: "HTTP_ERROR",
        message: error48.message,
        status: error48.status
      },
      status: error48.status
    };
  }
  const isDevelopment = globalThis.NODE_ENV === "development";
  return {
    error: {
      code: "INTERNAL_ERROR",
      message: isDevelopment ? error48.message : "An unexpected error occurred",
      stack: isDevelopment ? error48.stack : void 0
    },
    status: 500
  };
}
async function errorHandler2(err, c) {
  console.error("Error:", err);
  const { error: error48, status } = formatErrorResponse(err);
  const requestId2 = c.req.header("X-Request-ID") || crypto.randomUUID();
  c.header("X-Request-ID", requestId2);
  if (globalThis.NODE_ENV === "production") {
    console.error("Production error:", {
      requestId: requestId2,
      error: error48,
      url: c.req.url,
      method: c.req.method,
      headers: Object.fromEntries(c.req.raw.headers.entries())
    });
  }
  if (err instanceof RateLimitError && err.details?.retryAfter) {
    c.header("Retry-After", String(err.details.retryAfter));
  }
  return c.json(error48, status);
}
function asyncHandler(fn) {
  return async (...args) => {
    try {
      return await fn(...args);
    } catch (error48) {
      throw error48;
    }
  };
}
function validateRequired(data, fields) {
  const missing = fields.filter((field) => !data[field]);
  if (missing.length > 0) {
    throw new ValidationError(
      `Missing required fields: ${missing.join(", ")}`,
      { missingFields: missing }
    );
  }
}
function validateType(value, type, fieldName) {
  let isValid = false;
  switch (type) {
    case "string":
      isValid = typeof value === "string";
      break;
    case "number":
      isValid = typeof value === "number" && !isNaN(value);
      break;
    case "boolean":
      isValid = typeof value === "boolean";
      break;
    case "array":
      isValid = Array.isArray(value);
      break;
    case "object":
      isValid = value !== null && typeof value === "object" && !Array.isArray(value);
      break;
  }
  if (!isValid) {
    throw new ValidationError(
      `Invalid type for ${fieldName}: expected ${type}`,
      { field: fieldName, expectedType: type, actualType: typeof value }
    );
  }
}
var AppError, ValidationError, AuthenticationError, AuthorizationError, NotFoundError, ConflictError, RateLimitError, ExternalServiceError, handleError;
var init_errors = __esm({
  "src/utils/errors.ts"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_http_exception();
    AppError = class _AppError extends Error {
      static {
        __name(this, "AppError");
      }
      constructor(message, statusCode = 500, errorCode = "INTERNAL_ERROR", details) {
        super(message);
        this.name = "AppError";
        this.statusCode = statusCode;
        this.errorCode = errorCode;
        this.details = details;
        Object.setPrototypeOf(this, _AppError.prototype);
      }
    };
    ValidationError = class extends AppError {
      static {
        __name(this, "ValidationError");
      }
      constructor(message, details) {
        super(message, 400, "VALIDATION_ERROR", details);
        this.name = "ValidationError";
      }
    };
    AuthenticationError = class extends AppError {
      static {
        __name(this, "AuthenticationError");
      }
      constructor(message = "Authentication required") {
        super(message, 401, "AUTHENTICATION_ERROR");
        this.name = "AuthenticationError";
      }
    };
    AuthorizationError = class extends AppError {
      static {
        __name(this, "AuthorizationError");
      }
      constructor(message = "Insufficient permissions") {
        super(message, 403, "AUTHORIZATION_ERROR");
        this.name = "AuthorizationError";
      }
    };
    NotFoundError = class extends AppError {
      static {
        __name(this, "NotFoundError");
      }
      constructor(resource = "Resource") {
        super(`${resource} not found`, 404, "NOT_FOUND");
        this.name = "NotFoundError";
      }
    };
    ConflictError = class extends AppError {
      static {
        __name(this, "ConflictError");
      }
      constructor(message) {
        super(message, 409, "CONFLICT_ERROR");
        this.name = "ConflictError";
      }
    };
    RateLimitError = class extends AppError {
      static {
        __name(this, "RateLimitError");
      }
      constructor(retryAfter) {
        super("Too many requests", 429, "RATE_LIMIT_ERROR", { retryAfter });
        this.name = "RateLimitError";
      }
    };
    ExternalServiceError = class extends AppError {
      static {
        __name(this, "ExternalServiceError");
      }
      constructor(service, originalError) {
        super(
          `External service error: ${service}`,
          502,
          "EXTERNAL_SERVICE_ERROR",
          { service, originalError }
        );
        this.name = "ExternalServiceError";
      }
    };
    __name(formatErrorResponse, "formatErrorResponse");
    __name(errorHandler2, "errorHandler");
    __name(asyncHandler, "asyncHandler");
    __name(validateRequired, "validateRequired");
    __name(validateType, "validateType");
    handleError = errorHandler2;
  }
});

// src/utils/security.ts
async function hashSha256(input) {
  const encoder = new TextEncoder();
  const data = encoder.encode(input);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}
function generateState(prefix = "state") {
  return `${prefix}_${crypto.randomUUID()}`;
}
function sanitizeFileName(name) {
  return name.normalize("NFKD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-zA-Z0-9._-]/g, "_").replace(/_{2,}/g, "_").replace(/^_+|_+$/g, "").toLowerCase();
}
function assertEnvVar(value, variableName) {
  if (!value) {
    throw new Error(`Environment variable ${variableName} is required`);
  }
  return value;
}
var init_security = __esm({
  "src/utils/security.ts"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(hashSha256, "hashSha256");
    __name(generateState, "generateState");
    __name(sanitizeFileName, "sanitizeFileName");
    __name(assertEnvVar, "assertEnvVar");
  }
});

// src/middleware/analytics.ts
var analytics_exports = {};
__export(analytics_exports, {
  analyticsMiddleware: () => analyticsMiddleware,
  errorTrackingMiddleware: () => errorTrackingMiddleware,
  getAggregatedMetrics: () => getAggregatedMetrics,
  streamMetrics: () => streamMetrics
});
async function sendToAnalyticsEngine(env2, event) {
  if (!env2.ANALYTICS) return;
  try {
    const statusIndex = event.metrics.status != null ? event.metrics.status.toString() : "unknown";
    await env2.ANALYTICS.writeDataPoint({
      blobs: [
        event.type,
        event.metrics.method,
        event.metrics.path,
        event.metrics.error || "",
        event.metrics.aiModel || "",
        event.metrics.country || "",
        event.metrics.cacheStatus || "",
        event.metadata?.environment || "",
        event.metadata?.version || ""
      ],
      doubles: [
        event.metrics.duration,
        event.metrics.cpuTime,
        event.metrics.aiTokensUsed || 0,
        event.metrics.aiDuration || 0,
        event.metrics.cacheHit ? 1 : 0
      ],
      indexes: [statusIndex]
    });
  } catch (error48) {
    console.error("Failed to write to Analytics Engine:", error48);
  }
}
function checkPerformanceThresholds(metrics, env2) {
  const { duration: duration3, cpuTime } = metrics;
  let durationLevel = "good";
  if (duration3 > PERFORMANCE_THRESHOLDS.duration.critical) {
    durationLevel = "critical";
  } else if (duration3 > PERFORMANCE_THRESHOLDS.duration.warning) {
    durationLevel = "warning";
  }
  let cpuLevel = "good";
  if (cpuTime > PERFORMANCE_THRESHOLDS.cpuTime.critical) {
    cpuLevel = "critical";
  } else if (cpuTime > PERFORMANCE_THRESHOLDS.cpuTime.warning) {
    cpuLevel = "warning";
  }
  if (durationLevel !== "good" || cpuLevel !== "good") {
    console.warn("Performance threshold exceeded:", {
      path: metrics.path,
      duration: `${duration3}ms (${durationLevel})`,
      cpuTime: `${cpuTime}ms (${cpuLevel})`,
      status: metrics.status
    });
  }
}
async function getAggregatedMetrics(env2, timeRange, groupBy) {
  if (!env2.ANALYTICS) return null;
  try {
    const result = await env2.ANALYTICS?.query?.({
      timeRange: [timeRange.start, timeRange.end],
      filter: { blob1: "api_request" },
      aggregations: {
        count: { count: {} },
        avgDuration: { avg: { field: "double1" } },
        avgCpuTime: { avg: { field: "double2" } },
        p95Duration: { quantile: { field: "double1", quantile: 0.95 } },
        p95CpuTime: { quantile: { field: "double2", quantile: 0.95 } }
      },
      groupBy: groupBy ? [`blob${getFieldIndex(groupBy)}`] : void 0
    });
    return result ?? null;
  } catch (error48) {
    console.error("Failed to query Analytics Engine:", error48);
    return null;
  }
}
function getFieldIndex(field) {
  const fieldMap = {
    "path": 3,
    "status": 1,
    "country": 2
  };
  return fieldMap[field] || 1;
}
async function streamMetrics(ws, env2) {
  const interval = setInterval(async () => {
    try {
      const metrics = await getAggregatedMetrics(env2, {
        start: new Date(Date.now() - 6e4),
        end: /* @__PURE__ */ new Date()
      });
      if (metrics && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: "metrics_update",
          timestamp: Date.now(),
          data: metrics
        }));
      }
    } catch (error48) {
      console.error("Failed to stream metrics:", error48);
    }
  }, 5e3);
  ws.addEventListener("close", () => {
    clearInterval(interval);
  });
}
var PERFORMANCE_THRESHOLDS, analyticsMiddleware, errorTrackingMiddleware;
var init_analytics = __esm({
  "src/middleware/analytics.ts"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    PERFORMANCE_THRESHOLDS = {
      duration: {
        good: 100,
        // 100ms 
        warning: 500,
        // 500ms 
        critical: 1e3
        // 1 
      },
      cpuTime: {
        good: 50,
        // 50ms 
        warning: 200,
        // 200ms 
        critical: 500
        // 500ms 
      }
    };
    analyticsMiddleware = /* @__PURE__ */ __name(async (c, next) => {
      const startTime = Date.now();
      const startCpu = c.executionCtx.cpuTime || 0;
      const request = c.req.raw;
      const url2 = new URL(request.url);
      const cf = request.cf;
      try {
        await next();
        const duration3 = Date.now() - startTime;
        const cpuTime = (c.executionCtx.cpuTime || 0) - startCpu;
        const status = c.res.status;
        const metrics = {
          method: request.method,
          path: url2.pathname,
          status,
          duration: duration3,
          cpuTime,
          userAgent: request.headers.get("user-agent") || void 0,
          country: cf?.country,
          city: cf?.city,
          colo: cf?.colo,
          tlsVersion: cf?.tlsVersion,
          httpProtocol: cf?.httpProtocol,
          cacheStatus: c.res.headers.get("cf-cache-status") || void 0,
          cacheHit: c.res.headers.get("cf-cache-status") === "HIT"
        };
        const aiMetrics = c.get("aiMetrics");
        if (aiMetrics) {
          metrics.aiModel = aiMetrics.model;
          metrics.aiTokensUsed = aiMetrics.tokensUsed;
          metrics.aiDuration = aiMetrics.duration;
        }
        if (status >= 400) {
          const error48 = c.get("error");
          if (error48) {
            metrics.error = error48.message;
            metrics.errorType = error48.type || "unknown";
          }
        }
        await sendToAnalyticsEngine(c.env, {
          timestamp: Date.now(),
          type: "api_request",
          metrics,
          metadata: {
            environment: c.env.ENVIRONMENT,
            version: c.env.API_VERSION
          }
        });
        checkPerformanceThresholds(metrics, c.env);
        c.res.headers.set("Server-Timing", [
          `cpu;dur=${cpuTime.toFixed(2)}`,
          `total;dur=${duration3.toFixed(2)}`,
          cf?.colo ? `colo;desc="${cf.colo}"` : null
        ].filter(Boolean).join(", "));
      } catch (error48) {
        console.error("Analytics middleware error:", error48);
      }
    }, "analyticsMiddleware");
    __name(sendToAnalyticsEngine, "sendToAnalyticsEngine");
    __name(checkPerformanceThresholds, "checkPerformanceThresholds");
    errorTrackingMiddleware = /* @__PURE__ */ __name(async (c, next) => {
      try {
        await next();
      } catch (error48) {
        c.set("error", {
          message: error48.message,
          type: error48.constructor.name,
          stack: error48.stack
        });
        await sendToAnalyticsEngine(c.env, {
          timestamp: Date.now(),
          type: "error",
          metrics: {
            method: c.req.method,
            path: new URL(c.req.url).pathname,
            status: 500,
            duration: 0,
            cpuTime: 0,
            error: error48.message,
            errorType: error48.constructor.name
          },
          metadata: {
            stack: error48.stack,
            environment: c.env.ENVIRONMENT
          }
        });
        throw error48;
      }
    }, "errorTrackingMiddleware");
    __name(getAggregatedMetrics, "getAggregatedMetrics");
    __name(getFieldIndex, "getFieldIndex");
    __name(streamMetrics, "streamMetrics");
  }
});

// src/utils/db.ts
async function query(db, sql, params = []) {
  const result = await db.prepare(sql).bind(...params).all();
  return result.results ?? [];
}
async function queryFirst(db, sql, params = []) {
  const rows = await query(db, sql, params);
  return rows.length > 0 ? rows[0] : null;
}
async function execute(db, sql, params = []) {
  return db.prepare(sql).bind(...params).run();
}
async function transaction(db, statements, reducer) {
  let accumulator = void 0;
  await db.batch(
    statements.map(({ sql, params }) => db.prepare(sql).bind(...params ?? []))
  ).then((results) => {
    if (reducer) {
      results.forEach((res, index) => {
        accumulator = reducer(res, index, accumulator);
      });
    }
  });
  return accumulator;
}
var init_db = __esm({
  "src/utils/db.ts"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(query, "query");
    __name(queryFirst, "queryFirst");
    __name(execute, "execute");
    __name(transaction, "transaction");
  }
});

// src/utils/userAgent.ts
function parseUserAgent(userAgent) {
  if (!userAgent) {
    return {
      device: "Unknown Device",
      browser: "Unknown Browser",
      os: "Unknown OS"
    };
  }
  const ua = userAgent.toLowerCase();
  let os = "Unknown OS";
  if (ua.includes("windows")) {
    os = "Windows";
    if (ua.includes("windows nt 10.0")) os = "Windows 10";
    else if (ua.includes("windows nt 6.3")) os = "Windows 8.1";
    else if (ua.includes("windows nt 6.2")) os = "Windows 8";
    else if (ua.includes("windows nt 6.1")) os = "Windows 7";
  } else if (ua.includes("mac os x")) {
    os = "MacOS";
    const match = ua.match(/mac os x (\d+[._]\d+)/);
    if (match) {
      os = `MacOS ${match[1].replace("_", ".")}`;
    }
  } else if (ua.includes("android")) {
    os = "Android";
    const match = ua.match(/android (\d+\.?\d*)/);
    if (match) {
      os = `Android ${match[1]}`;
    }
  } else if (ua.includes("iphone") || ua.includes("ipad")) {
    os = ua.includes("ipad") ? "iPadOS" : "iOS";
    const match = ua.match(/os (\d+[._]\d+)/);
    if (match) {
      os = `${os} ${match[1].replace("_", ".")}`;
    }
  } else if (ua.includes("linux")) {
    os = "Linux";
  }
  let browser = "Unknown Browser";
  let version3 = "";
  if (ua.includes("edg/")) {
    browser = "Edge";
    const match = ua.match(/edg\/(\d+\.?\d*)/);
    if (match) version3 = match[1];
  } else if (ua.includes("chrome/") && !ua.includes("edg")) {
    browser = "Chrome";
    const match = ua.match(/chrome\/(\d+\.?\d*)/);
    if (match) version3 = match[1];
  } else if (ua.includes("safari/") && !ua.includes("chrome")) {
    browser = "Safari";
    const match = ua.match(/version\/(\d+\.?\d*)/);
    if (match) version3 = match[1];
  } else if (ua.includes("firefox/")) {
    browser = "Firefox";
    const match = ua.match(/firefox\/(\d+\.?\d*)/);
    if (match) version3 = match[1];
  } else if (ua.includes("opera/") || ua.includes("opr/")) {
    browser = "Opera";
    const match = ua.match(/(?:opera|opr)\/(\d+\.?\d*)/);
    if (match) version3 = match[1];
  }
  if (version3) {
    browser = `${browser} ${version3.split(".")[0]}`;
  }
  let device = "Desktop";
  if (ua.includes("mobile")) {
    device = "Mobile";
  } else if (ua.includes("tablet") || ua.includes("ipad")) {
    device = "Tablet";
  }
  const deviceInfo = `${browser} on ${os}`;
  return {
    device: deviceInfo,
    browser,
    os
  };
}
function getLocationFromIP(ipAddress) {
  return {
    location: "Unknown Location",
    countryCode: "XX"
  };
}
function detectSuspiciousActivity(params) {
  return {
    suspicious: false,
    reason: void 0
  };
}
var init_userAgent = __esm({
  "src/utils/userAgent.ts"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(parseUserAgent, "parseUserAgent");
    __name(getLocationFromIP, "getLocationFromIP");
    __name(detectSuspiciousActivity, "detectSuspiciousActivity");
  }
});

// src/services/auth.ts
var auth_exports = {};
__export(auth_exports, {
  generateLoginUrl: () => generateLoginUrl,
  handleOAuthCallback: () => handleOAuthCallback,
  logoutUser: () => logoutUser,
  refreshTokens: () => refreshTokens
});
function resolveNumericEnv(value, fallback) {
  if (!value) return fallback;
  const parsed = Number(value);
  if (Number.isFinite(parsed) && parsed > 0) {
    return Math.floor(parsed);
  }
  return fallback;
}
function getAccessTokenTtl(env2) {
  return resolveNumericEnv(env2.ACCESS_TOKEN_TTL_SECONDS, DEFAULT_ACCESS_TOKEN_TTL_SECONDS);
}
function getRefreshTokenTtl(env2) {
  return resolveNumericEnv(env2.REFRESH_TOKEN_TTL_SECONDS, DEFAULT_REFRESH_TOKEN_TTL_SECONDS);
}
function getJwtIssuer(env2) {
  return env2.JWT_ISSUER ?? env2.API_BASE_URL ?? "https://api.languagemate.kr";
}
function getProviderConfig(env2, provider) {
  switch (provider) {
    case "naver":
      return {
        clientId: assertEnvVar(env2.NAVER_CLIENT_ID, "NAVER_CLIENT_ID"),
        clientSecret: assertEnvVar(env2.NAVER_CLIENT_SECRET, "NAVER_CLIENT_SECRET"),
        redirectUri: assertEnvVar(env2.NAVER_REDIRECT_URI, "NAVER_REDIRECT_URI")
      };
    case "google":
      return {
        clientId: assertEnvVar(env2.GOOGLE_CLIENT_ID, "GOOGLE_CLIENT_ID"),
        clientSecret: assertEnvVar(env2.GOOGLE_CLIENT_SECRET, "GOOGLE_CLIENT_SECRET"),
        redirectUri: assertEnvVar(env2.GOOGLE_REDIRECT_URI, "GOOGLE_REDIRECT_URI")
      };
    default:
      throw new Error(`Unsupported provider: ${provider}`);
  }
}
function normalizeProvider(provider) {
  const value = provider.toLowerCase();
  if (value !== "naver" && value !== "google") {
    throw new Error(`Invalid OAuth provider: ${provider}`);
  }
  return value;
}
async function upsertOAuthUser(env2, identity, provider, payload) {
  const existing = await queryFirst(
    env2.DB,
    "SELECT user_id, user_identity, email, name, english_name, profile_image, self_bio, gender FROM users WHERE user_identity = ? LIMIT 1",
    [identity]
  );
  const nowIso7 = (/* @__PURE__ */ new Date()).toISOString();
  if (existing) {
    const updates = [];
    const params = [];
    if (payload.name) {
      updates.push("name = ?");
      params.push(payload.name);
    }
    if (payload.email) {
      updates.push("email = ?");
      params.push(payload.email);
    }
    if (payload.profileImage) {
      updates.push("profile_image = ?");
      params.push(payload.profileImage);
    }
    if (updates.length > 0) {
      updates.push("updated_at = ?");
      params.push(nowIso7);
      params.push(existing.user_id);
      await execute(env2.DB, `UPDATE users SET ${updates.join(", ")} WHERE user_id = ?`, params);
    }
    return {
      ...existing,
      email: payload.email ?? existing.email,
      name: payload.name ?? existing.name,
      profile_image: payload.profileImage ?? existing.profile_image
    };
  }
  const userId = crypto.randomUUID();
  await execute(
    env2.DB,
    `INSERT INTO users (
        user_id,
        user_identity,
        email,
        name,
        profile_image,
        user_disable,
        is_onboarding_completed,
        user_identity_type,
        user_created_at,
        created_at,
        updated_at
      ) VALUES (?, ?, ?, ?, ?, 0, 0, ?, ?, ?, ?)
    `,
    [
      userId,
      identity,
      payload.email ?? null,
      payload.name ?? null,
      payload.profileImage ?? null,
      provider.toUpperCase(),
      nowIso7,
      nowIso7,
      nowIso7
    ]
  );
  return {
    user_id: userId,
    user_identity: identity,
    email: payload.email ?? null,
    name: payload.name ?? null,
    english_name: null,
    profile_image: payload.profileImage ?? null,
    self_bio: null,
    gender: null
  };
}
async function issueTokens(options) {
  const {
    env: env2,
    userId,
    email: email3,
    role = "USER",
    permissions = [],
    userAgent,
    ipAddress,
    replaceTokenId
  } = options;
  const secret = assertEnvVar(env2.JWT_SECRET, "JWT_SECRET");
  const accessTokenTtl = getAccessTokenTtl(env2);
  const refreshTokenTtl = getRefreshTokenTtl(env2);
  const issuer = getJwtIssuer(env2);
  const nowSeconds = Math.floor(Date.now() / 1e3);
  const expiresAtSeconds = nowSeconds + accessTokenTtl;
  const payload = {
    sub: userId,
    email: email3,
    role,
    permissions,
    iat: nowSeconds,
    exp: expiresAtSeconds,
    iss: issuer
  };
  const accessToken = await sign2(payload, secret, "HS512");
  const refreshId = crypto.randomUUID();
  const refreshPayload = {
    jti: refreshId,
    sub: userId,
    type: "refresh",
    iat: nowSeconds,
    exp: nowSeconds + refreshTokenTtl,
    iss: issuer
  };
  const refreshToken = await sign2(refreshPayload, secret, "HS512");
  const refreshHash = await hashSha256(refreshToken);
  const issuedAtIso = new Date(nowSeconds * 1e3).toISOString();
  const refreshExpiresAtIso = new Date((nowSeconds + refreshTokenTtl) * 1e3).toISOString();
  const parsedUA = parseUserAgent(userAgent);
  const locationInfo = getLocationFromIP(ipAddress);
  const suspiciousCheck = detectSuspiciousActivity({
    ipAddress,
    userAgent
  });
  await transaction(env2.DB, [
    ...replaceTokenId ? [
      {
        sql: "UPDATE refresh_tokens SET revoked_at = ? WHERE token_id = ?",
        params: [issuedAtIso, replaceTokenId]
      }
    ] : [],
    {
      sql: `INSERT INTO refresh_tokens (
              token_id,
              user_id,
              token_hash,
              issued_at,
              expires_at,
              user_agent,
              ip_address
            ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
      params: [refreshId, userId, refreshHash, issuedAtIso, refreshExpiresAtIso, userAgent ?? null, ipAddress ?? null]
    },
    //   
    {
      sql: `INSERT INTO login_history (
              user_id,
              login_time,
              ip_address,
              user_agent,
              device,
              browser,
              location,
              country_code,
              suspicious,
              suspicious_reason,
              session_id,
              success
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      params: [
        userId,
        issuedAtIso,
        ipAddress ?? null,
        userAgent ?? null,
        parsedUA.device,
        parsedUA.browser,
        locationInfo.location,
        locationInfo.countryCode,
        suspiciousCheck.suspicious ? 1 : 0,
        suspiciousCheck.reason ?? null,
        refreshId,
        1
        // success = 1
      ]
    }
  ]);
  return {
    accessToken,
    refreshToken,
    expiresIn: accessTokenTtl
  };
}
async function getUserById(env2, userId) {
  return queryFirst(
    env2.DB,
    "SELECT user_id, user_identity, email, name, english_name, profile_image, self_bio, gender FROM users WHERE user_id = ? LIMIT 1",
    [userId]
  );
}
function mapDbUserToAuthUser(row) {
  return {
    id: row.user_id,
    email: row.email ?? void 0,
    role: "USER",
    permissions: []
  };
}
async function consumeState(env2, state) {
  if (!state) {
    return null;
  }
  const key = `oauth:state:${state}`;
  const value = await env2.CACHE.get(key, { type: "json" });
  if (value) {
    await env2.CACHE.delete(key);
  }
  return value;
}
async function generateLoginUrl(env2, providerName, redirectUri) {
  const provider = normalizeProvider(providerName);
  const config3 = getProviderConfig(env2, provider);
  const state = generateState(provider);
  const baseRedirect = redirectUri || "https://languagemate.kr";
  const callbackUrl = (() => {
    try {
      return new URL(`/login/oauth2/code/${provider}`, baseRedirect).toString();
    } catch {
      return `https://languagemate.kr/login/oauth2/code/${provider}`;
    }
  })();
  const statePayload = {
    provider,
    redirectUri: baseRedirect,
    //   
    callbackUrl,
    createdAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  await env2.CACHE.put(`oauth:state:${state}`, JSON.stringify(statePayload), {
    expirationTtl: 300
  });
  const authorizeUrl = new URL(provider === "naver" ? NAVER_AUTHORIZE_URL : GOOGLE_AUTHORIZE_URL);
  authorizeUrl.searchParams.set("response_type", "code");
  authorizeUrl.searchParams.set("client_id", config3.clientId);
  authorizeUrl.searchParams.set("redirect_uri", config3.redirectUri);
  authorizeUrl.searchParams.set("state", state);
  if (provider === "google") {
    authorizeUrl.searchParams.set("scope", "openid email profile");
    authorizeUrl.searchParams.set("access_type", "offline");
    authorizeUrl.searchParams.set("prompt", "consent");
  }
  return {
    url: authorizeUrl.toString(),
    state
  };
}
async function handleOAuthCallback(env2, providerName, params, metadata = {}) {
  const provider = normalizeProvider(providerName);
  const config3 = getProviderConfig(env2, provider);
  const statePayload = await consumeState(env2, params.state);
  const finalRedirectUri = statePayload?.redirectUri ?? "https://languagemate.kr";
  const callbackUrl = statePayload?.callbackUrl ?? (() => {
    try {
      return new URL(`/login/oauth2/code/${provider}`, finalRedirectUri).toString();
    } catch {
      return `https://languagemate.kr/login/oauth2/code/${provider}`;
    }
  })();
  if (statePayload && statePayload.provider !== provider) {
    throw new Error("OAuth provider mismatch for provided state");
  }
  const result = provider === "naver" ? await handleNaverCallback(env2, config3, params.code, params.state, config3.redirectUri, metadata) : await handleGoogleCallback(env2, config3, params.code, config3.redirectUri, metadata);
  return {
    ...result,
    redirectUri: finalRedirectUri,
    callbackUrl
  };
}
async function handleNaverCallback(env2, config3, code, state, redirectUri, metadata) {
  const body = new URLSearchParams({
    grant_type: "authorization_code",
    client_id: config3.clientId,
    client_secret: config3.clientSecret,
    code,
    state: state ?? "",
    redirect_uri: redirectUri
  });
  const tokenRes = await fetch(NAVER_TOKEN_URL, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body
  });
  if (!tokenRes.ok) {
    throw new Error(`Naver token exchange failed: ${tokenRes.status}`);
  }
  const tokenJson = await tokenRes.json();
  const accessToken = tokenJson.access_token;
  if (!accessToken) {
    throw new Error("Naver token exchange response missing access_token");
  }
  const profileRes = await fetch(NAVER_USERINFO_URL, {
    headers: {
      Authorization: `Bearer ${accessToken}`
    }
  });
  if (!profileRes.ok) {
    throw new Error(`Naver userinfo request failed: ${profileRes.status}`);
  }
  const profileJson = await profileRes.json();
  const response = profileJson.response ?? {};
  const identity = response.id;
  if (!identity) {
    throw new Error("Naver userinfo did not include id");
  }
  const userRow = await upsertOAuthUser(env2, identity, "naver", {
    name: response.name ?? response.nickname ?? null,
    email: response.email ?? null,
    profileImage: response.profile_image ?? null
  });
  const tokens = await issueTokens({
    env: env2,
    userId: userRow.user_id,
    email: userRow.email,
    role: "USER",
    permissions: [],
    userAgent: metadata.userAgent,
    ipAddress: metadata.ipAddress
  });
  return {
    user: mapDbUserToAuthUser(userRow),
    accessToken: tokens.accessToken,
    refreshToken: tokens.refreshToken,
    expiresIn: tokens.expiresIn,
    redirectUri
  };
}
async function handleGoogleCallback(env2, config3, code, redirectUri, metadata) {
  const body = new URLSearchParams({
    grant_type: "authorization_code",
    client_id: config3.clientId,
    client_secret: config3.clientSecret,
    code,
    redirect_uri: redirectUri
  });
  const tokenRes = await fetch(GOOGLE_TOKEN_URL, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body
  });
  if (!tokenRes.ok) {
    throw new Error(`Google token exchange failed: ${tokenRes.status}`);
  }
  const tokenJson = await tokenRes.json();
  const accessToken = tokenJson.access_token;
  if (!accessToken) {
    throw new Error("Google token exchange response missing access_token");
  }
  const profileRes = await fetch(GOOGLE_USERINFO_URL, {
    headers: {
      Authorization: `Bearer ${accessToken}`
    }
  });
  if (!profileRes.ok) {
    throw new Error(`Google userinfo request failed: ${profileRes.status}`);
  }
  const profileJson = await profileRes.json();
  if (!profileJson.id) {
    throw new Error("Google userinfo did not include id");
  }
  const userRow = await upsertOAuthUser(env2, profileJson.id, "google", {
    name: profileJson.name ?? null,
    email: profileJson.email ?? null,
    profileImage: profileJson.picture ?? null
  });
  const tokens = await issueTokens({
    env: env2,
    userId: userRow.user_id,
    email: userRow.email,
    role: "USER",
    permissions: [],
    userAgent: metadata.userAgent,
    ipAddress: metadata.ipAddress
  });
  return {
    user: mapDbUserToAuthUser(userRow),
    accessToken: tokens.accessToken,
    refreshToken: tokens.refreshToken,
    expiresIn: tokens.expiresIn,
    redirectUri
  };
}
async function refreshTokens(env2, refreshToken, metadata = {}) {
  const refreshHash = await hashSha256(refreshToken);
  const row = await queryFirst(
    env2.DB,
    "SELECT token_id, user_id, expires_at, revoked_at FROM refresh_tokens WHERE token_hash = ? LIMIT 1",
    [refreshHash]
  );
  if (!row) {
    throw new Error("Invalid refresh token");
  }
  if (row.revoked_at) {
    throw new Error("Refresh token revoked");
  }
  if (Date.parse(row.expires_at) < Date.now()) {
    throw new Error("Refresh token expired");
  }
  const user = await getUserById(env2, row.user_id);
  if (!user) {
    throw new Error("User not found for refresh token");
  }
  return issueTokens({
    env: env2,
    userId: user.user_id,
    email: user.email,
    role: "USER",
    permissions: [],
    userAgent: metadata.userAgent,
    ipAddress: metadata.ipAddress,
    replaceTokenId: row.token_id
  });
}
async function logoutUser(env2, _accessToken, refreshToken) {
  if (!refreshToken) {
    return;
  }
  const refreshHash = await hashSha256(refreshToken);
  await execute(
    env2.DB,
    "UPDATE refresh_tokens SET revoked_at = ? WHERE token_hash = ?",
    [(/* @__PURE__ */ new Date()).toISOString(), refreshHash]
  );
}
var DEFAULT_ACCESS_TOKEN_TTL_SECONDS, DEFAULT_REFRESH_TOKEN_TTL_SECONDS, NAVER_AUTHORIZE_URL, NAVER_TOKEN_URL, NAVER_USERINFO_URL, GOOGLE_AUTHORIZE_URL, GOOGLE_TOKEN_URL, GOOGLE_USERINFO_URL;
var init_auth = __esm({
  "src/services/auth.ts"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_jwt4();
    init_security();
    init_db();
    init_userAgent();
    DEFAULT_ACCESS_TOKEN_TTL_SECONDS = 24 * 60 * 60;
    DEFAULT_REFRESH_TOKEN_TTL_SECONDS = 7 * 24 * 60 * 60;
    __name(resolveNumericEnv, "resolveNumericEnv");
    __name(getAccessTokenTtl, "getAccessTokenTtl");
    __name(getRefreshTokenTtl, "getRefreshTokenTtl");
    __name(getJwtIssuer, "getJwtIssuer");
    NAVER_AUTHORIZE_URL = "https://nid.naver.com/oauth2.0/authorize";
    NAVER_TOKEN_URL = "https://nid.naver.com/oauth2.0/token";
    NAVER_USERINFO_URL = "https://openapi.naver.com/v1/nid/me";
    GOOGLE_AUTHORIZE_URL = "https://accounts.google.com/o/oauth2/v2/auth";
    GOOGLE_TOKEN_URL = "https://oauth2.googleapis.com/token";
    GOOGLE_USERINFO_URL = "https://www.googleapis.com/oauth2/v2/userinfo";
    __name(getProviderConfig, "getProviderConfig");
    __name(normalizeProvider, "normalizeProvider");
    __name(upsertOAuthUser, "upsertOAuthUser");
    __name(issueTokens, "issueTokens");
    __name(getUserById, "getUserById");
    __name(mapDbUserToAuthUser, "mapDbUserToAuthUser");
    __name(consumeState, "consumeState");
    __name(generateLoginUrl, "generateLoginUrl");
    __name(handleOAuthCallback, "handleOAuthCallback");
    __name(handleNaverCallback, "handleNaverCallback");
    __name(handleGoogleCallback, "handleGoogleCallback");
    __name(refreshTokens, "refreshTokens");
    __name(logoutUser, "logoutUser");
  }
});

// src/index.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/hono.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/hono-base.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/compose.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var compose = /* @__PURE__ */ __name((middleware, onError, onNotFound) => {
  return (context2, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError = false;
      let handler;
      if (middleware[i]) {
        handler = middleware[i][0][0];
        context2.req.routeIndex = i;
      } else {
        handler = i === middleware.length && next || void 0;
      }
      if (handler) {
        try {
          res = await handler(context2, () => dispatch(i + 1));
        } catch (err) {
          if (err instanceof Error && onError) {
            context2.error = err;
            res = await onError(err, context2);
            isError = true;
          } else {
            throw err;
          }
        }
      } else {
        if (context2.finalized === false && onNotFound) {
          res = await onNotFound(context2);
        }
      }
      if (res && (context2.finalized === false || isError)) {
        context2.res = res;
      }
      return context2;
    }
    __name(dispatch, "dispatch");
  };
}, "compose");

// node_modules/hono/dist/hono-base.js
init_context();

// node_modules/hono/dist/router.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
  static {
    __name(this, "UnsupportedPathError");
  }
};

// node_modules/hono/dist/utils/constants.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";

// node_modules/hono/dist/hono-base.js
init_url();
var notFoundHandler = /* @__PURE__ */ __name((c) => {
  return c.text("404 Not Found", 404);
}, "notFoundHandler");
var errorHandler = /* @__PURE__ */ __name((err, c) => {
  if ("getResponse" in err) {
    const res = err.getResponse();
    return c.newResponse(res.body, res);
  }
  console.error(err);
  return c.text("Internal Server Error", 500);
}, "errorHandler");
var Hono = class {
  static {
    __name(this, "Hono");
  }
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  router;
  getPath;
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.#addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          this.#addRoute(method, this.#path, handler);
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      for (const p of [path].flat()) {
        this.#path = p;
        for (const m of [method].flat()) {
          handlers.map((handler) => {
            this.#addRoute(m.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const { strict, ...optionsWithoutStrict } = options;
    Object.assign(this, optionsWithoutStrict);
    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;
  }
  #clone() {
    const clone2 = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone2.errorHandler = this.errorHandler;
    clone2.#notFoundHandler = this.#notFoundHandler;
    clone2.routes = this.routes;
    return clone2;
  }
  #notFoundHandler = notFoundHandler;
  errorHandler = errorHandler;
  route(path, app9) {
    const subApp = this.basePath(path);
    app9.routes.map((r) => {
      let handler;
      if (app9.errorHandler === errorHandler) {
        handler = r.handler;
      } else {
        handler = /* @__PURE__ */ __name(async (c, next) => (await compose([], app9.errorHandler)(c, () => r.handler(c, next))).res, "handler");
        handler[COMPOSED_HANDLER] = r.handler;
      }
      subApp.#addRoute(r.method, r.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.#clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  onError = /* @__PURE__ */ __name((handler) => {
    this.errorHandler = handler;
    return this;
  }, "onError");
  notFound = /* @__PURE__ */ __name((handler) => {
    this.#notFoundHandler = handler;
    return this;
  }, "notFound");
  mount(path, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        if (options.replaceRequest === false) {
          replaceRequest = /* @__PURE__ */ __name((request) => request, "replaceRequest");
        } else {
          replaceRequest = options.replaceRequest;
        }
      }
    }
    const getOptions = optionHandler ? (c) => {
      const options2 = optionHandler(c);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c) => {
      let executionContext = void 0;
      try {
        executionContext = c.executionCtx;
      } catch {
      }
      return [c.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request) => {
        const url2 = new URL(request.url);
        url2.pathname = url2.pathname.slice(pathPrefixLength) || "/";
        return new Request(url2, request);
      };
    })();
    const handler = /* @__PURE__ */ __name(async (c, next) => {
      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));
      if (res) {
        return res;
      }
      await next();
    }, "handler");
    this.#addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  #addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r = { basePath: this._basePath, path, method, handler };
    this.router.add(method, path, [handler, r]);
    this.routes.push(r);
  }
  #handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  #dispatch(request, executionCtx, env2, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env2, "GET")))();
    }
    const path = this.getPath(request, { env: env2 });
    const matchResult = this.router.match(method, path);
    const c = new Context(request, {
      path,
      matchResult,
      env: env2,
      executionCtx,
      notFoundHandler: this.#notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c, async () => {
          c.res = await this.#notFoundHandler(c);
        });
      } catch (err) {
        return this.#handleError(err, c);
      }
      return res instanceof Promise ? res.then(
        (resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))
      ).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);
    }
    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);
    return (async () => {
      try {
        const context2 = await composed(c);
        if (!context2.finalized) {
          throw new Error(
            "Context is not finalized. Did you forget to return a Response object or `await next()`?"
          );
        }
        return context2.res;
      } catch (err) {
        return this.#handleError(err, c);
      }
    })();
  }
  fetch = /* @__PURE__ */ __name((request, ...rest) => {
    return this.#dispatch(request, rest[1], rest[0], request.method);
  }, "fetch");
  request = /* @__PURE__ */ __name((input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
    }
    input = input.toString();
    return this.fetch(
      new Request(
        /^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`,
        requestInit
      ),
      Env,
      executionCtx
    );
  }, "request");
  fire = /* @__PURE__ */ __name(() => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.#dispatch(event.request, event, void 0, event.request.method));
    });
  }, "fire");
};

// node_modules/hono/dist/router/reg-exp-router/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/router/reg-exp-router/router.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_url();

// node_modules/hono/dist/router/reg-exp-router/node.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
__name(compareKey, "compareKey");
var Node = class {
  static {
    __name(this, "Node");
  }
  #index;
  #varIndex;
  #children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context2, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.#index !== void 0) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.#index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        if (regexpStr === ".*") {
          throw PATH_ERROR;
        }
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.#children[regexpStr];
      if (!node) {
        if (Object.keys(this.#children).some(
          (k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[regexpStr] = new Node();
        if (name !== "") {
          node.#varIndex = context2.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.#varIndex]);
      }
    } else {
      node = this.#children[token];
      if (!node) {
        if (Object.keys(this.#children).some(
          (k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[token] = new Node();
      }
    }
    node.insert(restTokens, index, paramMap, context2, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.#children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c = this.#children[k];
      return (typeof c.#varIndex === "number" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\${k}` : k) + c.buildRegExpStr();
    });
    if (typeof this.#index === "number") {
      strList.unshift(`#${this.#index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// node_modules/hono/dist/router/reg-exp-router/trie.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Trie = class {
  static {
    __name(this, "Trie");
  }
  #context = { varIndex: 0 };
  #root = new Node();
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0; ; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1; i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1; j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.#root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (handlerIndex !== void 0) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (paramIndex !== void 0) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// node_modules/hono/dist/router/reg-exp-router/router.js
var emptyParam = [];
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ??= new RegExp(
    path === "*" ? "" : `^${path.replace(
      /\/\*$|([.\\+*[^\]$()])/g,
      (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)"
    )}$`
  );
}
__name(buildWildcardRegExp, "buildWildcardRegExp");
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
__name(clearWildcardRegExpCache, "clearWildcardRegExpCache");
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie();
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map(
    (route) => [!/\*|\/:/.test(route[0]), ...route]
  ).sort(
    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length
  );
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (; paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length; i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length; j < len2; j++) {
      const map2 = handlerData[i][j]?.[1];
      if (!map2) {
        continue;
      }
      const keys = Object.keys(map2);
      for (let k = 0, len3 = keys.length; k < len3; k++) {
        map2[keys[k]] = paramReplacementMap[map2[keys[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
__name(buildMatcherFromPreprocessedRoutes, "buildMatcherFromPreprocessedRoutes");
function findMiddleware(middleware, path) {
  if (!middleware) {
    return void 0;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware[k]];
    }
  }
  return void 0;
}
__name(findMiddleware, "findMiddleware");
var RegExpRouter = class {
  static {
    __name(this, "RegExpRouter");
  }
  name = "RegExpRouter";
  #middleware;
  #routes;
  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path, handler) {
    const middleware = this.#middleware;
    const routes = this.#routes;
    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      ;
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m) => {
          middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
        });
      } else {
        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
      }
      Object.keys(middleware).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(middleware[m]).forEach((p) => {
            re.test(p) && middleware[m][p].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(routes[m]).forEach(
            (p) => re.test(p) && routes[m][p].push([handler, paramCount])
          );
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i = 0, len = paths.length; i < len; i++) {
      const path2 = paths[i];
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          routes[m][path2] ||= [
            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ];
          routes[m][path2].push([handler, paramCount - len + i + 1]);
        }
      });
    }
  }
  match(method, path) {
    clearWildcardRegExpCache();
    const matchers = this.#buildAllMatchers();
    this.match = (method2, path2) => {
      const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
      const staticMatch = matcher[2][path2];
      if (staticMatch) {
        return staticMatch;
      }
      const match = path2.match(matcher[0]);
      if (!match) {
        return [[], emptyParam];
      }
      const index = match.indexOf("", 1);
      return [matcher[1][index], match];
    };
    return this.match(method, path);
  }
  #buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
      matchers[method] ||= this.#buildMatcher(method);
    });
    this.#middleware = this.#routes = void 0;
    return matchers;
  }
  #buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.#middleware, this.#routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(
          ...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]])
        );
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// node_modules/hono/dist/router/smart-router/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/router/smart-router/router.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SmartRouter = class {
  static {
    __name(this, "SmartRouter");
  }
  name = "SmartRouter";
  #routers = [];
  #routes = [];
  constructor(init) {
    this.#routers = init.routers;
  }
  add(method, path, handler) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.#routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.#routes) {
      throw new Error("Fatal error");
    }
    const routers = this.#routers;
    const routes = this.#routes;
    const len = routers.length;
    let i = 0;
    let res;
    for (; i < len; i++) {
      const router = routers[i];
      try {
        for (let i2 = 0, len2 = routes.length; i2 < len2; i2++) {
          router.add(...routes[i2]);
        }
        res = router.match(method, path);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router.match.bind(router);
      this.#routers = [router];
      this.#routes = void 0;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.#routers[0];
  }
};

// node_modules/hono/dist/router/trie-router/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/router/trie-router/router.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_url();

// node_modules/hono/dist/router/trie-router/node.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_url();
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node2 = class {
  static {
    __name(this, "Node");
  }
  #methods;
  #children;
  #patterns;
  #order = 0;
  #params = emptyParams;
  constructor(method, handler, children) {
    this.#children = children || /* @__PURE__ */ Object.create(null);
    this.#methods = [];
    if (method && handler) {
      const m = /* @__PURE__ */ Object.create(null);
      m[method] = { handler, possibleKeys: [], score: 0 };
      this.#methods = [m];
    }
    this.#patterns = [];
  }
  insert(method, path, handler) {
    this.#order = ++this.#order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    for (let i = 0, len = parts.length; i < len; i++) {
      const p = parts[i];
      const nextP = parts[i + 1];
      const pattern = getPattern(p, nextP);
      const key = Array.isArray(pattern) ? pattern[0] : p;
      if (key in curNode.#children) {
        curNode = curNode.#children[key];
        if (pattern) {
          possibleKeys.push(pattern[1]);
        }
        continue;
      }
      curNode.#children[key] = new Node2();
      if (pattern) {
        curNode.#patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.#children[key];
    }
    curNode.#methods.push({
      [method]: {
        handler,
        possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
        score: this.#order
      }
    });
    return curNode;
  }
  #getHandlerSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i = 0, len = node.#methods.length; i < len; i++) {
      const m = node.#methods[i];
      const handlerSet = m[method] || m[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== void 0) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSets.push(handlerSet);
        if (nodeParams !== emptyParams || params && params !== emptyParams) {
          for (let i2 = 0, len2 = handlerSet.possibleKeys.length; i2 < len2; i2++) {
            const key = handlerSet.possibleKeys[i2];
            const processed = processedSet[handlerSet.score];
            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
            processedSet[handlerSet.score] = true;
          }
        }
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.#params = emptyParams;
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    const curNodesQueue = [];
    for (let i = 0, len = parts.length; i < len; i++) {
      const part = parts[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length; j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.#children[part];
        if (nextNode) {
          nextNode.#params = node.#params;
          if (isLast) {
            if (nextNode.#children["*"]) {
              handlerSets.push(
                ...this.#getHandlerSets(nextNode.#children["*"], method, node.#params)
              );
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node.#patterns.length; k < len3; k++) {
          const pattern = node.#patterns[k];
          const params = node.#params === emptyParams ? {} : { ...node.#params };
          if (pattern === "*") {
            const astNode = node.#children["*"];
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
              astNode.#params = params;
              tempNodes.push(astNode);
            }
            continue;
          }
          const [key, name, matcher] = pattern;
          if (!part && !(matcher instanceof RegExp)) {
            continue;
          }
          const child = node.#children[key];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp) {
            const m = matcher.exec(restPathString);
            if (m) {
              params[name] = m[0];
              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
              if (Object.keys(child.#children).length) {
                child.#params = params;
                const componentCount = m[0].match(/\//)?.length ?? 0;
                const targetCurNodes = curNodesQueue[componentCount] ||= [];
                targetCurNodes.push(child);
              }
              continue;
            }
          }
          if (matcher === true || matcher.test(part)) {
            params[name] = part;
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
              if (child.#children["*"]) {
                handlerSets.push(
                  ...this.#getHandlerSets(child.#children["*"], method, params, node.#params)
                );
              }
            } else {
              child.#params = params;
              tempNodes.push(child);
            }
          }
        }
      }
      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
    }
    if (handlerSets.length > 1) {
      handlerSets.sort((a, b) => {
        return a.score - b.score;
      });
    }
    return [handlerSets.map(({ handler, params }) => [handler, params])];
  }
};

// node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  static {
    __name(this, "TrieRouter");
  }
  name = "TrieRouter";
  #node;
  constructor() {
    this.#node = new Node2();
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (let i = 0, len = results.length; i < len; i++) {
        this.#node.insert(method, results[i], handler);
      }
      return;
    }
    this.#node.insert(method, path, handler);
  }
  match(method, path) {
    return this.#node.search(method, path);
  }
};

// node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  static {
    __name(this, "Hono");
  }
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter(), new TrieRouter()]
    });
  }
};

// node_modules/hono/dist/middleware/cors/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var cors = /* @__PURE__ */ __name((options) => {
  const defaults = {
    origin: "*",
    allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH"],
    allowHeaders: [],
    exposeHeaders: []
  };
  const opts = {
    ...defaults,
    ...options
  };
  const findAllowOrigin = ((optsOrigin) => {
    if (typeof optsOrigin === "string") {
      if (optsOrigin === "*") {
        return () => optsOrigin;
      } else {
        return (origin) => optsOrigin === origin ? origin : null;
      }
    } else if (typeof optsOrigin === "function") {
      return optsOrigin;
    } else {
      return (origin) => optsOrigin.includes(origin) ? origin : null;
    }
  })(opts.origin);
  const findAllowMethods = ((optsAllowMethods) => {
    if (typeof optsAllowMethods === "function") {
      return optsAllowMethods;
    } else if (Array.isArray(optsAllowMethods)) {
      return () => optsAllowMethods;
    } else {
      return () => [];
    }
  })(opts.allowMethods);
  return /* @__PURE__ */ __name(async function cors2(c, next) {
    function set2(key, value) {
      c.res.headers.set(key, value);
    }
    __name(set2, "set");
    const allowOrigin = findAllowOrigin(c.req.header("origin") || "", c);
    if (allowOrigin) {
      set2("Access-Control-Allow-Origin", allowOrigin);
    }
    if (opts.origin !== "*") {
      const existingVary = c.req.header("Vary");
      if (existingVary) {
        set2("Vary", existingVary);
      } else {
        set2("Vary", "Origin");
      }
    }
    if (opts.credentials) {
      set2("Access-Control-Allow-Credentials", "true");
    }
    if (opts.exposeHeaders?.length) {
      set2("Access-Control-Expose-Headers", opts.exposeHeaders.join(","));
    }
    if (c.req.method === "OPTIONS") {
      if (opts.maxAge != null) {
        set2("Access-Control-Max-Age", opts.maxAge.toString());
      }
      const allowMethods = findAllowMethods(c.req.header("origin") || "", c);
      if (allowMethods.length) {
        set2("Access-Control-Allow-Methods", allowMethods.join(","));
      }
      let headers = opts.allowHeaders;
      if (!headers?.length) {
        const requestHeaders = c.req.header("Access-Control-Request-Headers");
        if (requestHeaders) {
          headers = requestHeaders.split(/\s*,\s*/);
        }
      }
      if (headers?.length) {
        set2("Access-Control-Allow-Headers", headers.join(","));
        c.res.headers.append("Vary", "Access-Control-Request-Headers");
      }
      c.res.headers.delete("Content-Length");
      c.res.headers.delete("Content-Type");
      return new Response(null, {
        headers: c.res.headers,
        status: 204,
        statusText: "No Content"
      });
    }
    await next();
  }, "cors2");
}, "cors");

// src/routes/levelTest.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/middleware/auth.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_jwt4();

// src/middleware/error-handler.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_http_exception();

// src/types/index.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ApiError = class extends Error {
  constructor(statusCode, code, message, details) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.details = details;
    this.name = "ApiError";
  }
  static {
    __name(this, "ApiError");
  }
};

// src/utils/logger.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var LOG_LEVELS = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3
};
var WorkersLogger = class _WorkersLogger {
  constructor() {
    this.currentLevel = LOG_LEVELS.INFO;
    this.environment = "production";
  }
  static {
    __name(this, "WorkersLogger");
  }
  static getInstance() {
    if (!_WorkersLogger.instance) {
      _WorkersLogger.instance = new _WorkersLogger();
    }
    return _WorkersLogger.instance;
  }
  setLevel(level) {
    this.currentLevel = LOG_LEVELS[level];
  }
  setEnvironment(env2) {
    this.environment = env2;
    if (env2 === "development" || env2 === "staging") {
      this.setLevel("DEBUG");
    }
  }
  shouldLog(level) {
    return level >= this.currentLevel;
  }
  createLogEntry(level, message, context2, error48, metadata) {
    const entry = {
      level,
      message,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      context: context2,
      metadata
    };
    if (error48) {
      entry.error = {
        name: error48.name,
        message: error48.message,
        stack: this.environment === "development" ? error48.stack : void 0
      };
    }
    return entry;
  }
  output(entry) {
    const logString = JSON.stringify(entry);
    switch (entry.level) {
      case "ERROR":
        console.error(logString);
        break;
      case "WARN":
        console.warn(logString);
        break;
      case "INFO":
      case "DEBUG":
      default:
        console.log(logString);
        break;
    }
  }
  debug(message, context2, metadata) {
    if (!this.shouldLog(LOG_LEVELS.DEBUG)) return;
    const entry = this.createLogEntry("DEBUG", message, context2, void 0, metadata);
    this.output(entry);
  }
  info(message, context2, metadata) {
    if (!this.shouldLog(LOG_LEVELS.INFO)) return;
    const entry = this.createLogEntry("INFO", message, context2, void 0, metadata);
    this.output(entry);
  }
  warn(message, context2, metadata) {
    if (!this.shouldLog(LOG_LEVELS.WARN)) return;
    const entry = this.createLogEntry("WARN", message, context2, void 0, metadata);
    this.output(entry);
  }
  error(message, error48, context2, metadata) {
    if (!this.shouldLog(LOG_LEVELS.ERROR)) return;
    const entry = this.createLogEntry("ERROR", message, context2, error48, metadata);
    this.output(entry);
  }
  // API   
  apiCall(method, path, status, duration3, context2) {
    const message = `${method.toUpperCase()} ${path} - ${status} (${duration3}ms)`;
    const apiContext = {
      ...context2,
      method: method.toUpperCase(),
      path,
      status,
      duration: duration3,
      component: "API"
    };
    if (status >= 500) {
      this.error(message, void 0, apiContext);
    } else if (status >= 400) {
      this.warn(message, apiContext);
    } else {
      this.info(message, apiContext);
    }
  }
  //  
  performance(operation, duration3, context2) {
    const perfContext = {
      ...context2,
      operation,
      duration: duration3,
      component: "PERFORMANCE"
    };
    if (duration3 > 5e3) {
      this.warn(`Slow operation: ${operation} (${duration3}ms)`, perfContext);
    } else if (duration3 > 1e3) {
      this.info(`Operation: ${operation} (${duration3}ms)`, perfContext);
    } else {
      this.debug(`Operation: ${operation} (${duration3}ms)`, perfContext);
    }
  }
  // AI  
  aiOperation(service, operation, duration3, tokens, context2) {
    const aiContext = {
      ...context2,
      component: "AI",
      operation: `${service}.${operation}`,
      duration: duration3
    };
    const metadata = tokens ? { tokens } : void 0;
    this.info(`AI ${service}: ${operation} (${duration3}ms)`, aiContext, metadata);
  }
  // WebRTC 
  webrtc(event, roomId, userId, context2) {
    const webrtcContext = {
      ...context2,
      component: "WEBRTC",
      operation: event,
      userId
    };
    const metadata = roomId ? { roomId } : void 0;
    this.info(`WebRTC: ${event}`, webrtcContext, metadata);
  }
  //   
  storage(operation, key, size, context2) {
    const storageContext = {
      ...context2,
      component: "STORAGE",
      operation
    };
    const metadata = { key, size };
    this.debug(`Storage ${operation}: ${key}`, storageContext, metadata);
  }
  //   
  cache(operation, key, context2) {
    const cacheContext = {
      ...context2,
      component: "CACHE",
      operation
    };
    const metadata = { key };
    this.debug(`Cache ${operation}: ${key}`, cacheContext, metadata);
  }
  //   
  security(event, ip, context2) {
    const securityContext = {
      ...context2,
      component: "SECURITY",
      operation: event,
      ip
    };
    this.warn(`Security event: ${event}`, securityContext);
  }
};
var logger = WorkersLogger.getInstance();
var log3 = {
  debug: /* @__PURE__ */ __name((msg, ctx, meta) => logger.debug(msg, ctx, meta), "debug"),
  info: /* @__PURE__ */ __name((msg, ctx, meta) => logger.info(msg, ctx, meta), "info"),
  warn: /* @__PURE__ */ __name((msg, ctx, meta) => logger.warn(msg, ctx, meta), "warn"),
  error: /* @__PURE__ */ __name((msg, err, ctx, meta) => logger.error(msg, err, ctx, meta), "error"),
  api: /* @__PURE__ */ __name((method, path, status, duration3, ctx) => logger.apiCall(method, path, status, duration3, ctx), "api"),
  perf: /* @__PURE__ */ __name((operation, duration3, ctx) => logger.performance(operation, duration3, ctx), "perf"),
  ai: /* @__PURE__ */ __name((service, operation, duration3, tokens, ctx) => logger.aiOperation(service, operation, duration3, tokens, ctx), "ai"),
  webrtc: /* @__PURE__ */ __name((event, roomId, userId, ctx) => logger.webrtc(event, roomId, userId, ctx), "webrtc"),
  storage: /* @__PURE__ */ __name((operation, key, size, ctx) => logger.storage(operation, key, size, ctx), "storage"),
  cache: /* @__PURE__ */ __name((operation, key, ctx) => logger.cache(operation, key, ctx), "cache"),
  security: /* @__PURE__ */ __name((event, ip, ctx) => logger.security(event, ip, ctx), "security")
};

// src/middleware/error-handler.ts
init_errors();
async function errorHandler3(c, next) {
  try {
    await next();
  } catch (error48) {
    log3.error(
      "Unhandled error in request",
      error48 instanceof Error ? error48 : new Error(String(error48)),
      {
        requestId: c.get("requestId"),
        path: c.req.path,
        method: c.req.method,
        component: "ERROR_HANDLER"
      }
    );
    if (error48 instanceof AppError) {
      return c.json({
        success: false,
        error: {
          message: error48.message,
          code: error48.errorCode,
          details: error48.details
        },
        meta: {
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          requestId: c.get("requestId")
        }
      }, error48.statusCode);
    }
    if (error48 instanceof ApiError) {
      return c.json({
        success: false,
        error: {
          message: error48.message,
          code: error48.code,
          details: error48.details
        },
        meta: {
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          requestId: c.get("requestId")
        }
      }, error48.statusCode);
    }
    if (error48 instanceof HTTPException) {
      return c.json({
        success: false,
        error: {
          message: error48.message,
          code: "HTTP_EXCEPTION"
        },
        meta: {
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          requestId: c.get("requestId")
        }
      }, { status: error48.status });
    }
    const isDevelopment = c.env.ENVIRONMENT === "development";
    return c.json({
      success: false,
      error: {
        message: isDevelopment ? error48.message : "Internal Server Error",
        code: "INTERNAL_ERROR",
        details: isDevelopment ? error48.stack : void 0
      },
      meta: {
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        requestId: c.get("requestId")
      }
    }, { status: 500 });
  }
}
__name(errorHandler3, "errorHandler");
function notFoundHandler2(c) {
  return c.json({
    success: false,
    error: {
      message: `Route not found: ${c.req.method} ${c.req.path}`,
      code: "NOT_FOUND"
    },
    meta: {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      requestId: c.get("requestId")
    }
  }, { status: 404 });
}
__name(notFoundHandler2, "notFoundHandler");
function validationError(message, details) {
  return new ApiError(400, "VALIDATION_ERROR", message, details);
}
__name(validationError, "validationError");
function authError(message = "Unauthorized") {
  return new ApiError(401, "AUTH_ERROR", message);
}
__name(authError, "authError");
function forbiddenError(message = "Forbidden") {
  return new ApiError(403, "FORBIDDEN", message);
}
__name(forbiddenError, "forbiddenError");
function notFoundError(resource) {
  return new ApiError(404, "NOT_FOUND", `${resource} not found`);
}
__name(notFoundError, "notFoundError");
function conflictError(message) {
  return new ApiError(409, "CONFLICT", message);
}
__name(conflictError, "conflictError");

// src/middleware/auth.ts
init_security();
async function extractUser(token, env2) {
  try {
    const secret = assertEnvVar(env2.JWT_SECRET, "JWT_SECRET");
    const verifyOptions = { alg: "HS512" };
    const issuer = env2.JWT_ISSUER ?? env2.API_BASE_URL;
    if (issuer) {
      verifyOptions.iss = issuer;
    }
    const payload = await verify2(token, secret, verifyOptions);
    return {
      id: payload.sub,
      email: payload.email,
      role: payload.role,
      permissions: payload.permissions
    };
  } catch (error48) {
    return null;
  }
}
__name(extractUser, "extractUser");
function auth(options = {}) {
  return async (c, next) => {
    const authHeader = c.req.header("Authorization");
    if (!authHeader) {
      if (options.optional) {
        return next();
      }
      return c.json({
        success: false,
        error: {
          message: "Authorization header required",
          code: "AUTH_ERROR"
        },
        meta: {
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          requestId: c.get("requestId")
        }
      }, 401);
    }
    const match = authHeader.match(/^Bearer (.+)$/);
    if (!match) {
      return c.json({
        success: false,
        error: {
          message: "Invalid authorization format. Use: Bearer <token>",
          code: "AUTH_ERROR"
        },
        meta: {
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          requestId: c.get("requestId")
        }
      }, 401);
    }
    const token = match[1];
    const user = await extractUser(token, c.env);
    if (!user) {
      return c.json({
        success: false,
        error: {
          message: "Invalid or expired token",
          code: "AUTH_ERROR"
        },
        meta: {
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          requestId: c.get("requestId")
        }
      }, 401);
    }
    if (options.roles && options.roles.length > 0) {
      if (!user.role || !options.roles.includes(user.role)) {
        throw forbiddenError("Insufficient role");
      }
    }
    if (options.permissions && options.permissions.length > 0) {
      const hasPermission = options.permissions.some(
        (permission2) => user.permissions?.includes(permission2)
      );
      if (!hasPermission) {
        throw forbiddenError("Insufficient permissions");
      }
    }
    c.set("userId", user.id);
    c.set("user", user);
    await next();
  };
}
__name(auth, "auth");
function internalAuth(secret) {
  return async (c, next) => {
    const authSecret = c.req.header("X-Internal-Secret");
    const expectedSecret = secret || c.env.INTERNAL_SECRET;
    if (!authSecret || authSecret !== expectedSecret) {
      throw authError("Invalid internal authentication");
    }
    await next();
  };
}
__name(internalAuth, "internalAuth");
function getCurrentUser(c) {
  return c.get("user") || null;
}
__name(getCurrentUser, "getCurrentUser");

// src/routes/levelTest.ts
init_errors();

// src/utils/response.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function successResponse(c, data, meta) {
  const response = {
    success: true,
    data,
    meta: {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      requestId: c.get("requestId"),
      ...meta
    }
  };
  return c.json(response, 200);
}
__name(successResponse, "successResponse");
function createdResponse(c, data, location) {
  const response = {
    success: true,
    data,
    meta: {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      requestId: c.get("requestId")
    }
  };
  if (location) {
    c.header("Location", location);
  }
  return c.json(response, 201);
}
__name(createdResponse, "createdResponse");
function noContentResponse(c) {
  return c.body(null, 204);
}
__name(noContentResponse, "noContentResponse");
function paginatedResponse(c, data, pagination) {
  const response = {
    success: true,
    data,
    meta: {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      requestId: c.get("requestId"),
      page: pagination.page,
      limit: pagination.limit,
      total: pagination.total,
      totalPages: Math.ceil(pagination.total / pagination.limit)
    }
  };
  return c.json(response, 200);
}
__name(paginatedResponse, "paginatedResponse");
function setCacheHeaders(c, options = {}) {
  const directives = [];
  if (options.noStore) {
    directives.push("no-store");
  } else if (options.noCache) {
    directives.push("no-cache");
  } else {
    if (options.private) {
      directives.push("private");
    } else {
      directives.push("public");
    }
    if (options.maxAge !== void 0) {
      directives.push(`max-age=${options.maxAge}`);
    }
    if (options.sMaxAge !== void 0) {
      directives.push(`s-maxage=${options.sMaxAge}`);
    }
    if (options.mustRevalidate) {
      directives.push("must-revalidate");
    }
  }
  c.header("Cache-Control", directives.join(", "));
}
__name(setCacheHeaders, "setCacheHeaders");
function errorResponse(c, message, code, details, status = 500) {
  const response = {
    success: false,
    error: {
      message,
      code: code || "INTERNAL_ERROR",
      details
    },
    meta: {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      requestId: c.get("requestId")
    }
  };
  return c.json(response, status);
}
__name(errorResponse, "errorResponse");

// src/services/ai.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function splitAudioIntoChunks(audioBuffer, chunkSize = 1024 * 1024) {
  const chunks = [];
  for (let i = 0; i < audioBuffer.byteLength; i += chunkSize) {
    const chunk = audioBuffer.slice(i, Math.min(i + chunkSize, audioBuffer.byteLength));
    chunks.push(chunk);
  }
  return chunks;
}
__name(splitAudioIntoChunks, "splitAudioIntoChunks");
async function processAudioChunk(ai, audioChunk, options = {}) {
  try {
    const response = await ai.run("@cf/openai/whisper-large-v3-turbo", {
      audio: [...new Uint8Array(audioChunk)],
      task: options.task || "transcribe",
      language: options.language || "auto",
      vad_filter: options.vad_filter || true,
      initial_prompt: options.initial_prompt,
      prefix: options.prefix
    });
    return response;
  } catch (error48) {
    log3.error("Whisper chunk processing error", error48, { component: "AI_SERVICE" });
    return { text: "[Error transcribing chunk]", word_count: 0 };
  }
}
__name(processAudioChunk, "processAudioChunk");
async function processAudio(ai, audioBuffer, options = {}) {
  try {
    if (audioBuffer.byteLength <= 1024 * 1024) {
      const response = await processAudioChunk(ai, audioBuffer, options);
      return {
        text: response.text || "",
        word_count: response.word_count || 0,
        words: response.words || [],
        chunks: 1
      };
    }
    const chunks = await splitAudioIntoChunks(audioBuffer);
    const results = [];
    let fullTranscript = "";
    let totalWordCount = 0;
    const allWords = [];
    let timeOffset = 0;
    for (const chunk of chunks) {
      const result = await processAudioChunk(ai, chunk, options);
      results.push(result);
      fullTranscript += result.text + " ";
      totalWordCount += result.word_count || 0;
      if (result.words) {
        const adjustedWords = result.words.map((word) => ({
          ...word,
          start: word.start + timeOffset,
          end: word.end + timeOffset
        }));
        allWords.push(...adjustedWords);
        const lastWord = result.words[result.words.length - 1];
        if (lastWord) {
          timeOffset = lastWord.end;
        }
      }
    }
    return {
      text: fullTranscript.trim(),
      word_count: totalWordCount,
      words: allWords,
      chunks: chunks.length
    };
  } catch (error48) {
    log3.error("Whisper processing error", error48, { component: "AI_SERVICE" });
    throw new Error("Failed to process audio with Whisper");
  }
}
__name(processAudio, "processAudio");
async function generateEmbedding(ai, text) {
  try {
    const response = await ai.run("@cf/baai/bge-base-en-v1.5", {
      text
    });
    return response.data?.[0] || [];
  } catch (error48) {
    log3.error("Embedding generation error", error48, { component: "AI_SERVICE" });
    throw new Error("Failed to generate embedding");
  }
}
__name(generateEmbedding, "generateEmbedding");
async function generateText(ai, prompt, options = {}) {
  try {
    const model = options.model || "@cf/meta/llama-3.2-3b-instruct";
    const response = await ai.run(model, {
      prompt,
      stream: options.stream || false,
      max_tokens: options.max_tokens || 1024,
      temperature: options.temperature || 0.7,
      top_p: options.top_p || 0.9,
      top_k: options.top_k || 40,
      repetition_penalty: options.repetition_penalty || 1.1,
      frequency_penalty: options.frequency_penalty || 0,
      presence_penalty: options.presence_penalty || 0,
      seed: options.seed
    });
    return {
      text: response.response || response,
      model,
      usage: response.usage || {
        prompt_tokens: 0,
        completion_tokens: 0,
        total_tokens: 0
      }
    };
  } catch (error48) {
    log3.error("Text generation error", error48, { component: "AI_SERVICE" });
    throw new Error("Failed to generate text");
  }
}
__name(generateText, "generateText");
function normalizeAiResponseBody(raw2) {
  if (typeof raw2 === "string") {
    return raw2;
  }
  if (Array.isArray(raw2)) {
    return raw2.map((part) => {
      if (typeof part === "string") return part;
      if (part && typeof part === "object" && "text" in part) {
        const textValue = part.text;
        return typeof textValue === "string" ? textValue : JSON.stringify(textValue ?? {});
      }
      return JSON.stringify(part ?? {});
    }).join("");
  }
  if (raw2 && typeof raw2 === "object") {
    if ("text" in raw2) {
      const textValue = raw2.text;
      return typeof textValue === "string" ? textValue : JSON.stringify(textValue ?? {});
    }
    return JSON.stringify(raw2);
  }
  return "";
}
__name(normalizeAiResponseBody, "normalizeAiResponseBody");
function sanitizeJsonResponse(raw2) {
  if (!raw2) return "";
  let text = raw2.trim();
  if (text.startsWith("```")) {
    text = text.replace(/^```(?:json)?\s*/i, "");
    const closingIndex = text.lastIndexOf("```");
    if (closingIndex !== -1) {
      text = text.slice(0, closingIndex);
    }
    text = text.trim();
  }
  return text;
}
__name(sanitizeJsonResponse, "sanitizeJsonResponse");
async function generateChatCompletion(ai, messages, options = {}) {
  try {
    const model = options.model || "@cf/meta/llama-3.3-70b-instruct-fp8-fast";
    const supportsFunctions = ["llama-3.3-70b-instruct-fp8-fast", "llama-4-scout-17b-16e-instruct"].some(
      (m) => model.includes(m)
    );
    const requestParams = {
      messages,
      stream: options.stream || false,
      max_tokens: options.max_tokens || 1024,
      temperature: options.temperature || 0.7,
      top_p: options.top_p || 0.9,
      top_k: options.top_k || 40,
      repetition_penalty: options.repetition_penalty || 1.1,
      frequency_penalty: options.frequency_penalty || 0,
      presence_penalty: options.presence_penalty || 0,
      seed: options.seed
    };
    if (options.response_format) {
      requestParams.response_format = options.response_format;
    }
    if (options.tools && supportsFunctions) {
      requestParams.tools = options.tools;
    }
    const response = await ai.run(model, requestParams);
    const rawText = response.response ?? response;
    return {
      text: normalizeAiResponseBody(rawText),
      model,
      usage: response.usage || {
        prompt_tokens: 0,
        completion_tokens: 0,
        total_tokens: 0
      },
      tool_calls: response.tool_calls
    };
  } catch (error48) {
    log3.error("Chat completion error", error48, { component: "AI_SERVICE" });
    throw new Error("Failed to generate chat completion");
  }
}
__name(generateChatCompletion, "generateChatCompletion");
async function evaluateLanguageLevel(ai, transcription, question) {
  try {
    const prompt = `Evaluate the following English response for language proficiency.

Question asked: "${question}"
Student's response: "${transcription}"

Evaluate the response across these 6 dimensions and provide a score (0-100) for each:
1. Pronunciation clarity (based on transcription quality)
2. Fluency and flow
3. Grammar accuracy
4. Vocabulary range and appropriateness
5. Coherence and organization
6. Interaction and responsiveness to the question

Also provide:
- Brief feedback on overall performance
- 2-3 specific suggestions for improvement
- Estimated CEFR level (A1-C2)

Respond in JSON format:
{
  "scores": {
    "pronunciation": number,
    "fluency": number,
    "grammar": number,
    "vocabulary": number,
    "coherence": number,
    "interaction": number
  },
  "feedback": "string",
  "suggestions": ["string", "string", "string"],
  "estimatedLevel": "string"
}`;
    const response = await generateChatCompletion(ai, [
      { role: "system", content: "You are an expert English language assessor. Provide fair and constructive evaluations." },
      { role: "user", content: prompt }
    ], {
      temperature: 0.3,
      max_tokens: 600,
      response_format: { type: "json_object" }
    });
    const sanitized = sanitizeJsonResponse(response.text);
    try {
      return JSON.parse(sanitized);
    } catch (parseError) {
      log3.warn("Language evaluation parse error", void 0, {
        component: "AI_SERVICE",
        model: response.model,
        rawPreview: response.text?.slice(0, 500),
        sanitizedPreview: sanitized.slice(0, 500),
        errorMessage: parseError instanceof Error ? parseError.message : String(parseError)
      });
      return {
        scores: {
          pronunciation: 70,
          fluency: 70,
          grammar: 70,
          vocabulary: 70,
          coherence: 70,
          interaction: 70
        },
        feedback: "Good effort in responding to the question.",
        suggestions: ["Practice speaking more fluently", "Expand vocabulary range", "Work on grammar accuracy"],
        estimatedLevel: "B1"
      };
    }
  } catch (error48) {
    log3.error("Language evaluation error", error48, { component: "AI_SERVICE" });
    throw new Error("Failed to evaluate language level");
  }
}
__name(evaluateLanguageLevel, "evaluateLanguageLevel");
async function generateLevelFeedback(ai, analysis, level) {
  try {
    const prompt = `Based on the following language assessment results, provide personalized feedback and learning recommendations.

Level: ${level}
Scores:
- Grammar: ${analysis.grammar}/100
- Vocabulary: ${analysis.vocabulary}/100
- Fluency: ${analysis.fluency}/100
- Pronunciation: ${analysis.pronunciation}/100
- Task Achievement: ${analysis.taskAchievement}/100
- Interaction: ${analysis.interaction}/100

Provide:
1. Overall assessment (2-3 sentences)
2. Strengths (2-3 points)
3. Areas for improvement (2-3 points)
4. Specific study recommendations (3-4 actionable tips)
5. Next steps to reach the next CEFR level

Keep the tone encouraging and constructive. Format in clear sections.`;
    const response = await generateText(ai, prompt, {
      temperature: 0.6,
      max_tokens: 800
    });
    return response.text;
  } catch (error48) {
    log3.error("Feedback generation error", error48, { component: "AI_SERVICE" });
    return "Unable to generate detailed feedback at this time.";
  }
}
__name(generateLevelFeedback, "generateLevelFeedback");
async function translateToMultipleLanguages(ai, text, targetLanguages, sourceLanguage = "auto") {
  try {
    const languageMap = {
      "en": "English",
      "ko": "Korean",
      "ja": "Japanese",
      "zh": "Chinese",
      "es": "Spanish",
      "fr": "French",
      "de": "German",
      "pt": "Portuguese",
      "ru": "Russian",
      "ar": "Arabic"
    };
    const languageList = targetLanguages.map((code) => `${languageMap[code] || code}: [translation]`).join("\n");
    const prompt = `Translate the following text to multiple languages. Provide ONLY the translations in the exact format shown, with no additional text:

${languageList}

Text to translate: "${text}"`;
    const response = await generateChatCompletion(ai, [
      {
        role: "system",
        content: "You are a professional translator. Provide accurate translations in the requested format."
      },
      { role: "user", content: prompt }
    ], {
      temperature: 0.3,
      max_tokens: 1e3
    });
    const translations = {};
    const lines = response.text.trim().split("\n");
    for (const line of lines) {
      const match = line.match(/^(English|Korean|Japanese|Chinese|Spanish|French|German|Portuguese|Russian|Arabic):\s*(.+)$/);
      if (match) {
        const langName = match[1];
        const translation = match[2].trim();
        const langCode = Object.entries(languageMap).find(([code, name]) => name === langName)?.[0];
        if (langCode) {
          translations[langCode] = translation;
        }
      }
    }
    return translations;
  } catch (error48) {
    log3.error("Multi-translation error", error48, { component: "AI_SERVICE" });
    throw new Error("Failed to translate to multiple languages");
  }
}
__name(translateToMultipleLanguages, "translateToMultipleLanguages");

// src/services/advancedLevelEvaluation.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var CEFR_THRESHOLDS = {
  A1: { min: 0, max: 40 },
  A2: { min: 40, max: 55 },
  B1: { min: 55, max: 70 },
  B2: { min: 70, max: 80 },
  C1: { min: 80, max: 90 },
  C2: { min: 90, max: 100 }
};
async function analyzePronunciation(ai, transcription, audioQuality) {
  try {
    const prompt = `Analyze the pronunciation quality based on the audio transcription and quality assessment.

Transcription: "${transcription}"
Audio Quality Note: "${audioQuality}"

Evaluate pronunciation across these dimensions (0-100 each):
1. Clarity - How clear and understandable is the speech?
2. Intonation - Natural rise and fall of voice?
3. Rhythm - Proper pacing and timing?
4. Stress - Correct word and sentence stress?
5. Nativelikeness - How close to native speaker pronunciation?

Also identify:
- 3-5 problematic sounds with suggestions (e.g., /th/, /r/, /l/)
- Overall pronunciation score

Respond in JSON format:
{
  "clarity": number,
  "intonation": number,
  "rhythm": number,
  "stress": number,
  "nativelikeness": number,
  "problematicSounds": [
    {
      "sound": "string",
      "frequency": "high|medium|low",
      "suggestion": "string"
    }
  ],
  "overallScore": number
}`;
    const response = await generateChatCompletion(ai, [
      {
        role: "system",
        content: "You are an expert phonetics and pronunciation assessor with extensive training in CEFR-aligned evaluation."
      },
      { role: "user", content: prompt }
    ], {
      temperature: 0.2,
      max_tokens: 800,
      response_format: { type: "json_object" }
    });
    const sanitized = sanitizeJsonResponse(response.text);
    const parsed = JSON.parse(sanitized);
    const problematicSounds = (parsed.problematicSounds || []).map((item) => ({
      sound: item.sound || "",
      frequency: item.frequency === "high" ? 3 : item.frequency === "medium" ? 2 : 1,
      suggestion: item.suggestion || ""
    }));
    return {
      overallScore: parsed.overallScore || 70,
      clarity: parsed.clarity || 70,
      intonation: parsed.intonation || 70,
      rhythm: parsed.rhythm || 70,
      stress: parsed.stress || 70,
      nativelikeness: parsed.nativelikeness || 65,
      problematicSounds
    };
  } catch (error48) {
    log3.error("Pronunciation analysis error", error48, { component: "ADVANCED_EVAL" });
    return {
      overallScore: 70,
      clarity: 70,
      intonation: 70,
      rhythm: 70,
      stress: 70,
      nativelikeness: 65,
      problematicSounds: []
    };
  }
}
__name(analyzePronunciation, "analyzePronunciation");
async function analyzeGrammar(ai, transcription, questionContext) {
  try {
    const prompt = `Perform a detailed grammar analysis of this English response.

Question: "${questionContext}"
Response: "${transcription}"

Evaluate:
1. Accuracy - Correctness of grammar structures (0-100)
2. Complexity - Use of complex structures (0-100)
3. Range - Variety of grammar patterns (0-100)

Identify:
- 3-5 common grammar errors with corrections
- 2-3 grammar strengths

Respond in JSON format:
{
  "accuracy": number,
  "complexity": number,
  "range": number,
  "commonErrors": [
    {
      "type": "string (e.g., 'Subject-verb agreement')",
      "example": "string (original text)",
      "correction": "string (corrected version)",
      "frequency": number (1-5)
    }
  ],
  "strengths": ["string", "string"],
  "overallScore": number
}`;
    const response = await generateChatCompletion(ai, [
      {
        role: "system",
        content: "You are an expert English grammar assessor. Provide detailed, constructive feedback aligned with CEFR standards."
      },
      { role: "user", content: prompt }
    ], {
      temperature: 0.2,
      max_tokens: 1e3,
      response_format: { type: "json_object" }
    });
    const sanitized = sanitizeJsonResponse(response.text);
    const parsed = JSON.parse(sanitized);
    return {
      overallScore: parsed.overallScore || 70,
      accuracy: parsed.accuracy || 70,
      complexity: parsed.complexity || 65,
      range: parsed.range || 68,
      commonErrors: parsed.commonErrors || [],
      strengths: parsed.strengths || []
    };
  } catch (error48) {
    log3.error("Grammar analysis error", error48, { component: "ADVANCED_EVAL" });
    return {
      overallScore: 70,
      accuracy: 70,
      complexity: 65,
      range: 68,
      commonErrors: [],
      strengths: ["Attempted response", "Basic structure maintained"]
    };
  }
}
__name(analyzeGrammar, "analyzeGrammar");
async function analyzeVocabulary(ai, transcription) {
  try {
    const prompt = `Analyze the vocabulary usage in this English text.

Text: "${transcription}"

Evaluate:
1. Range - Breadth of vocabulary (0-100)
2. Appropriateness - Context-appropriate word choice (0-100)
3. Sophistication - Use of advanced vocabulary (0-100)
4. Academic Level - basic/intermediate/advanced

Identify:
- 5-10 key vocabulary items used
- 2-4 collocations (word combinations)
- Any idioms or phrasal verbs

Respond in JSON format:
{
  "range": number,
  "appropriateness": number,
  "sophistication": number,
  "academicLevel": "basic|intermediate|advanced",
  "keyVocabulary": ["word1", "word2", ...],
  "collocations": ["make decision", "take time", ...],
  "idiomsUsed": ["string", ...],
  "overallScore": number
}`;
    const response = await generateChatCompletion(ai, [
      {
        role: "system",
        content: "You are an expert lexicographer and vocabulary assessor with deep knowledge of academic and everyday English."
      },
      { role: "user", content: prompt }
    ], {
      temperature: 0.25,
      max_tokens: 800,
      response_format: { type: "json_object" }
    });
    const sanitized = sanitizeJsonResponse(response.text);
    const parsed = JSON.parse(sanitized);
    return {
      overallScore: parsed.overallScore || 70,
      range: parsed.range || 68,
      appropriateness: parsed.appropriateness || 72,
      sophistication: parsed.sophistication || 60,
      academicLevel: parsed.academicLevel || "intermediate",
      keyVocabulary: parsed.keyVocabulary || [],
      collocations: parsed.collocations || [],
      idiomsUsed: parsed.idiomsUsed || []
    };
  } catch (error48) {
    log3.error("Vocabulary analysis error", error48, { component: "ADVANCED_EVAL" });
    return {
      overallScore: 70,
      range: 68,
      appropriateness: 72,
      sophistication: 60,
      academicLevel: "intermediate",
      keyVocabulary: [],
      collocations: [],
      idiomsUsed: []
    };
  }
}
__name(analyzeVocabulary, "analyzeVocabulary");
async function analyzeFluency(ai, transcription, responseTime, wordCount) {
  try {
    const wordsPerMinute = wordCount / (responseTime / 60);
    const prompt = `Analyze the fluency of this English response.

Text: "${transcription}"
Response time: ${responseTime} seconds
Word count: ${wordCount}
Speed: ${Math.round(wordsPerMinute)} words/minute

Evaluate (0-100 each):
1. Speed - Appropriate speaking pace
2. Pauses - Effective use of pauses
3. Repetition - Minimal unnecessary repetition
4. SelfCorrection - Ability to self-correct naturally
5. Hesitation - Minimal hesitation markers (um, uh, like)

Respond in JSON format:
{
  "speed": number,
  "pauses": number,
  "repetition": number,
  "selfCorrection": number,
  "hesitation": number,
  "overallScore": number
}`;
    const response = await generateChatCompletion(ai, [
      {
        role: "system",
        content: "You are an expert in analyzing spoken language fluency and prosody."
      },
      { role: "user", content: prompt }
    ], {
      temperature: 0.2,
      max_tokens: 500,
      response_format: { type: "json_object" }
    });
    const sanitized = sanitizeJsonResponse(response.text);
    const parsed = JSON.parse(sanitized);
    return {
      overallScore: parsed.overallScore || 70,
      speed: parsed.speed || 70,
      pauses: parsed.pauses || 68,
      repetition: parsed.repetition || 72,
      selfCorrection: parsed.selfCorrection || 65,
      hesitation: parsed.hesitation || 68
    };
  } catch (error48) {
    log3.error("Fluency analysis error", error48, { component: "ADVANCED_EVAL" });
    return {
      overallScore: 70,
      speed: 70,
      pauses: 68,
      repetition: 72,
      selfCorrection: 65,
      hesitation: 68
    };
  }
}
__name(analyzeFluency, "analyzeFluency");
async function analyzeCoherence(ai, transcription, questionContext) {
  try {
    const prompt = `Analyze the coherence and cohesion of this English response.

Question: "${questionContext}"
Response: "${transcription}"

Evaluate (0-100 each):
1. Organization - Logical structure
2. Cohesion - Use of linking words and devices
3. LogicalFlow - Clear progression of ideas
4. TopicDevelopment - Staying on topic and developing ideas

Identify linking devices used (e.g., "however", "therefore", "in addition")

Respond in JSON format:
{
  "organization": number,
  "cohesion": number,
  "logicalFlow": number,
  "topicDevelopment": number,
  "linkingDevices": ["word1", "word2", ...],
  "overallScore": number
}`;
    const response = await generateChatCompletion(ai, [
      {
        role: "system",
        content: "You are an expert in discourse analysis and text coherence assessment."
      },
      { role: "user", content: prompt }
    ], {
      temperature: 0.2,
      max_tokens: 600,
      response_format: { type: "json_object" }
    });
    const sanitized = sanitizeJsonResponse(response.text);
    const parsed = JSON.parse(sanitized);
    return {
      overallScore: parsed.overallScore || 70,
      organization: parsed.organization || 68,
      cohesion: parsed.cohesion || 70,
      logicalFlow: parsed.logicalFlow || 69,
      topicDevelopment: parsed.topicDevelopment || 71,
      linkingDevices: parsed.linkingDevices || []
    };
  } catch (error48) {
    log3.error("Coherence analysis error", error48, { component: "ADVANCED_EVAL" });
    return {
      overallScore: 70,
      organization: 68,
      cohesion: 70,
      logicalFlow: 69,
      topicDevelopment: 71,
      linkingDevices: []
    };
  }
}
__name(analyzeCoherence, "analyzeCoherence");
function calculateCEFRLevel(averageScore) {
  let level = "A1";
  for (const [cefrLevel, range2] of Object.entries(CEFR_THRESHOLDS)) {
    if (averageScore >= range2.min && averageScore < range2.max) {
      level = cefrLevel;
      break;
    }
  }
  if (averageScore >= CEFR_THRESHOLDS.C2.min) {
    level = "C2";
  }
  const range = CEFR_THRESHOLDS[level];
  const rangeSize = range.max - range.min;
  const position = averageScore - range.min;
  const percentage = position / rangeSize * 100;
  let subLevel = "low";
  if (percentage >= 66) subLevel = "high";
  else if (percentage >= 33) subLevel = "mid";
  return { level, subLevel };
}
__name(calculateCEFRLevel, "calculateCEFRLevel");
async function performComprehensiveEvaluation(ai, transcription, questionText, audioQuality, responseTime) {
  try {
    const wordCount = transcription.split(/\s+/).length;
    const [
      pronunciationAnalysis,
      grammarAnalysis,
      vocabularyAnalysis,
      fluencyAnalysis,
      coherenceAnalysis
    ] = await Promise.all([
      analyzePronunciation(ai, transcription, audioQuality),
      analyzeGrammar(ai, transcription, questionText),
      analyzeVocabulary(ai, transcription),
      analyzeFluency(ai, transcription, responseTime, wordCount),
      analyzeCoherence(ai, transcription, questionText)
    ]);
    const interactionScore = (coherenceAnalysis.topicDevelopment + grammarAnalysis.accuracy) / 2;
    const detailedScores = {
      pronunciation: pronunciationAnalysis.overallScore,
      fluency: fluencyAnalysis.overallScore,
      grammar: grammarAnalysis.overallScore,
      vocabulary: vocabularyAnalysis.overallScore,
      coherence: coherenceAnalysis.overallScore,
      interaction: interactionScore
    };
    const averageScore = Object.values(detailedScores).reduce((sum, score) => sum + score, 0) / 6;
    const { level: overallLevel, subLevel } = calculateCEFRLevel(averageScore);
    const scores = Object.values(detailedScores);
    const standardDeviation = Math.sqrt(
      scores.reduce((sum, score) => sum + Math.pow(score - averageScore, 2), 0) / scores.length
    );
    const confidenceScore = Math.max(0, 100 - standardDeviation * 2);
    const strengths = [];
    const weaknesses = [];
    const priorityImprovements = [];
    Object.entries(detailedScores).forEach(([area, score]) => {
      if (score >= 75) {
        strengths.push(`Strong ${area} skills (${Math.round(score)}/100)`);
      } else if (score < 60) {
        weaknesses.push(`${area.charAt(0).toUpperCase() + area.slice(1)} needs improvement (${Math.round(score)}/100)`);
        priorityImprovements.push({
          area,
          currentLevel: Math.round(score),
          targetLevel: Math.round(score) + 20,
          actionItems: getImprovementActions(area, score)
        });
      }
    });
    const studyPlan = await generateStudyPlan(ai, overallLevel, detailedScores, priorityImprovements);
    const nextLevelStrategy = await generateNextLevelStrategy(ai, overallLevel, detailedScores);
    return {
      overallLevel,
      subLevel,
      confidenceScore: Math.round(confidenceScore),
      detailedScores,
      pronunciationAnalysis,
      grammarAnalysis,
      vocabularyAnalysis,
      fluencyAnalysis,
      coherenceAnalysis,
      strengths,
      weaknesses,
      priorityImprovements,
      studyPlan,
      nextLevelStrategy
    };
  } catch (error48) {
    log3.error("Comprehensive evaluation error", error48, { component: "ADVANCED_EVAL" });
    throw new Error("Failed to perform comprehensive evaluation");
  }
}
__name(performComprehensiveEvaluation, "performComprehensiveEvaluation");
function getImprovementActions(area, currentScore) {
  const actions = {
    pronunciation: [
      "Practice shadowing native speakers daily (15-20 minutes)",
      "Record yourself and compare with native pronunciation",
      "Focus on problematic sounds identified in the analysis",
      "Use pronunciation apps like ELSA or Speechling"
    ],
    fluency: [
      "Practice speaking on topics for 2-3 minutes without stopping",
      "Reduce filler words (um, uh, like) through conscious practice",
      "Join conversation clubs or language exchange",
      "Read aloud daily to improve flow and rhythm"
    ],
    grammar: [
      "Review and practice specific grammar structures identified as weak",
      "Complete grammar exercises targeting your error patterns",
      "Write daily journal entries and self-correct",
      "Use grammar checking tools with explanations"
    ],
    vocabulary: [
      "Learn 10 new words daily with context examples",
      "Practice using academic word lists (AWL)",
      "Read extensively in your areas of interest",
      "Use spaced repetition apps like Anki or Memrise"
    ],
    coherence: [
      "Practice organizing ideas before speaking",
      "Learn and use discourse markers (however, therefore, moreover)",
      "Outline your thoughts using mind maps",
      "Practice presenting structured 2-3 minute talks"
    ],
    interaction: [
      "Practice responding to various question types",
      "Work on directly addressing the question asked",
      "Develop ideas fully with examples and details",
      "Practice active listening and appropriate responses"
    ]
  };
  return actions[area] || ["Practice regularly", "Seek feedback from teachers", "Use targeted learning resources"];
}
__name(getImprovementActions, "getImprovementActions");
async function generateStudyPlan(ai, currentLevel, scores, priorities) {
  try {
    const prompt = `Create a personalized study plan for an English learner.

Current Level: ${currentLevel}
Detailed Scores: ${JSON.stringify(scores)}
Priority Areas: ${priorities.map((p) => p.area).join(", ")}

Provide:
- Short-term goals (1-2 weeks): 3-4 actionable items
- Medium-term goals (1-3 months): 3-4 objectives
- Long-term goals (3-6 months): 2-3 major milestones

Respond in JSON format:
{
  "shortTerm": ["goal1", "goal2", ...],
  "mediumTerm": ["goal1", "goal2", ...],
  "longTerm": ["goal1", "goal2", ...]
}`;
    const response = await generateChatCompletion(ai, [
      {
        role: "system",
        content: "You are an expert language learning coach. Create SMART goals (Specific, Measurable, Achievable, Relevant, Time-bound)."
      },
      { role: "user", content: prompt }
    ], {
      temperature: 0.4,
      max_tokens: 800,
      response_format: { type: "json_object" }
    });
    const sanitized = sanitizeJsonResponse(response.text);
    const parsed = JSON.parse(sanitized);
    return {
      shortTerm: parsed.shortTerm || ["Practice daily pronunciation drills", "Complete grammar exercises"],
      mediumTerm: parsed.mediumTerm || ["Expand vocabulary by 300 words", "Improve fluency through conversation practice"],
      longTerm: parsed.longTerm || ["Achieve next CEFR level", "Maintain consistent practice routine"]
    };
  } catch (error48) {
    log3.error("Study plan generation error", error48, { component: "ADVANCED_EVAL" });
    return {
      shortTerm: ["Practice speaking 15 minutes daily", "Learn 10 new vocabulary words per day"],
      mediumTerm: ["Complete structured grammar course", "Join language exchange program"],
      longTerm: ["Reach next CEFR level", "Achieve fluent conversation ability"]
    };
  }
}
__name(generateStudyPlan, "generateStudyPlan");
async function generateNextLevelStrategy(ai, currentLevel, scores) {
  const levelOrder = ["A1", "A2", "B1", "B2", "C1", "C2"];
  const currentIndex = levelOrder.indexOf(currentLevel);
  const targetLevel = currentIndex < levelOrder.length - 1 ? levelOrder[currentIndex + 1] : "C2";
  try {
    const prompt = `Create a strategy to progress from ${currentLevel} to ${targetLevel} in English.

Current Scores: ${JSON.stringify(scores)}

Provide:
- Estimated time in months (realistic estimate)
- 4-5 key milestones to achieve
- 4-5 recommended resources (books, apps, courses, websites)

Respond in JSON format:
{
  "estimatedTimeMonths": number,
  "keyMilestones": ["milestone1", "milestone2", ...],
  "recommendedResources": ["resource1", "resource2", ...]
}`;
    const response = await generateChatCompletion(ai, [
      {
        role: "system",
        content: "You are an expert in language learning pathways and CEFR progression strategies."
      },
      { role: "user", content: prompt }
    ], {
      temperature: 0.3,
      max_tokens: 800,
      response_format: { type: "json_object" }
    });
    const sanitized = sanitizeJsonResponse(response.text);
    const parsed = JSON.parse(sanitized);
    return {
      targetLevel,
      estimatedTimeMonths: parsed.estimatedTimeMonths || 6,
      keyMilestones: parsed.keyMilestones || [
        `Master ${targetLevel} grammar structures`,
        `Build ${targetLevel}-appropriate vocabulary (1000+ words)`,
        `Achieve fluent conversation at ${targetLevel} topics`
      ],
      recommendedResources: parsed.recommendedResources || [
        "English Grammar in Use (Cambridge)",
        "IELTS/TOEFL preparation materials",
        "Language exchange platforms (HelloTalk, Tandem)",
        "Listening practice (TED Talks, podcasts)"
      ]
    };
  } catch (error48) {
    log3.error("Next level strategy error", error48, { component: "ADVANCED_EVAL" });
    return {
      targetLevel,
      estimatedTimeMonths: 6,
      keyMilestones: ["Improve all skill areas", "Practice consistently", "Seek feedback regularly"],
      recommendedResources: ["Standard English textbooks", "Online learning platforms", "Language exchange apps"]
    };
  }
}
__name(generateNextLevelStrategy, "generateNextLevelStrategy");

// src/services/storage.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function saveToR2(bucket, key, data, contentType, customMetadata) {
  try {
    const httpMetadata = {};
    if (contentType) {
      httpMetadata.contentType = contentType;
    }
    if (contentType?.startsWith("image/")) {
      httpMetadata.cacheControl = "public, max-age=31536000";
    } else if (contentType?.startsWith("audio/")) {
      httpMetadata.cacheControl = "public, max-age=86400";
    } else {
      httpMetadata.cacheControl = "public, max-age=3600";
    }
    const object2 = await bucket.put(key, data, {
      httpMetadata,
      customMetadata: {
        uploadedAt: (/* @__PURE__ */ new Date()).toISOString(),
        ...customMetadata
      }
    });
    return object2;
  } catch (error48) {
    console.error("R2 save error:", error48);
    throw new Error(`Failed to save to R2: ${key}`);
  }
}
__name(saveToR2, "saveToR2");
async function getFromR2(bucket, key) {
  try {
    const object2 = await bucket.get(key);
    return object2;
  } catch (error48) {
    console.error("R2 get error:", error48);
    return null;
  }
}
__name(getFromR2, "getFromR2");
async function deleteFromR2(bucket, key) {
  try {
    await bucket.delete(key);
  } catch (error48) {
    console.error("R2 delete error:", error48);
    throw new Error(`Failed to delete from R2: ${key}`);
  }
}
__name(deleteFromR2, "deleteFromR2");
function generateUniqueFileName(originalName, userId) {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 8);
  const extension = originalName.split(".").pop();
  const nameWithoutExt = originalName.replace(/\.[^/.]+$/, "");
  const sanitized = nameWithoutExt.replace(/[^a-zA-Z0-9_-]/g, "_").substring(0, 50);
  return `${userId}/${timestamp}_${random}_${sanitized}.${extension}`;
}
__name(generateUniqueFileName, "generateUniqueFileName");

// src/routes/levelTest.ts
var levelTestRoutes = new Hono2();
var SESSION_TTL_SECONDS = 60 * 60 * 24 * 14;
var HISTORY_TTL_SECONDS = 60 * 60 * 24 * 90;
var MAX_HISTORY_ITEMS = 20;
var SCORE_KEYS = ["pronunciation", "fluency", "grammar", "vocabulary", "coherence", "interaction"];
var optionalAuth = auth({ optional: true });
levelTestRoutes.use("*", optionalAuth);
var TEST_QUESTIONS = [
  {
    id: 1,
    text: "Introduce yourself. Tell me about your name, where you're from, and what you do.",
    korean: "\uC790\uAE30\uC18C\uAC1C\uB97C \uD574\uC8FC\uC138\uC694. \uC774\uB984, \uCD9C\uC2E0\uC9C0, \uD558\uB294 \uC77C\uC5D0 \uB300\uD574 \uB9D0\uC500\uD574\uC8FC\uC138\uC694.",
    duration: 60,
    difficulty: "A1-A2"
  },
  {
    id: 2,
    text: "Describe your typical day. What do you usually do from morning to evening?",
    korean: "\uC77C\uC0C1\uC801\uC778 \uD558\uB8E8\uB97C \uC124\uBA85\uD574\uC8FC\uC138\uC694. \uC544\uCE68\uBD80\uD130 \uC800\uB141\uAE4C\uC9C0 \uBCF4\uD1B5 \uBB34\uC5C7\uC744 \uD558\uB098\uC694?",
    duration: 90,
    difficulty: "A2-B1"
  },
  {
    id: 3,
    text: "Talk about a memorable experience you had recently. What happened and how did you feel?",
    korean: "\uCD5C\uADFC\uC5D0 \uC788\uC5C8\uB358 \uAE30\uC5B5\uC5D0 \uB0A8\uB294 \uACBD\uD5D8\uC5D0 \uB300\uD574 \uC774\uC57C\uAE30\uD574\uC8FC\uC138\uC694. \uBB34\uC2A8 \uC77C\uC774 \uC788\uC5C8\uACE0 \uC5B4\uB5BB\uAC8C \uB290\uAF08\uB098\uC694?",
    duration: 120,
    difficulty: "B1-B2"
  },
  {
    id: 4,
    text: "What are your thoughts on technology's impact on education? Discuss both positive and negative aspects.",
    korean: "\uAE30\uC220\uC774 \uAD50\uC721\uC5D0 \uBBF8\uCE58\uB294 \uC601\uD5A5\uC5D0 \uB300\uD55C \uB2F9\uC2E0\uC758 \uC0DD\uAC01\uC740 \uBB34\uC5C7\uC778\uAC00\uC694? \uAE0D\uC815\uC801\uC778 \uBA74\uACFC \uBD80\uC815\uC801\uC778 \uBA74\uC744 \uBAA8\uB450 \uB17C\uC758\uD574\uC8FC\uC138\uC694.",
    duration: 180,
    difficulty: "B2-C1"
  }
];
function generateTestId() {
  const now = Date.now();
  const random = Math.floor(Math.random() * 1e3);
  return String(now * 1e3 + random);
}
__name(generateTestId, "generateTestId");
function sessionKey(testId) {
  return `level-test:session:${testId}`;
}
__name(sessionKey, "sessionKey");
function userHistoryKey(userId) {
  return `level-test:history:${userId}`;
}
__name(userHistoryKey, "userHistoryKey");
async function loadSession(env2, testId) {
  const raw2 = await env2.CACHE.get(sessionKey(testId));
  if (!raw2) return null;
  try {
    return JSON.parse(raw2);
  } catch (error48) {
    log3.error("Failed to parse level test session", error48, { component: "LEVEL_TEST", testId });
    return null;
  }
}
__name(loadSession, "loadSession");
async function requireSession(env2, testId) {
  const session = await loadSession(env2, testId);
  if (!session) {
    throw new AppError("Level test not found", 404, "LEVEL_TEST_NOT_FOUND");
  }
  return session;
}
__name(requireSession, "requireSession");
function ensureOwnership(session, userId) {
  if (session.userId !== userId) {
    throw new AppError("You do not have access to this test", 403, "LEVEL_TEST_FORBIDDEN");
  }
}
__name(ensureOwnership, "ensureOwnership");
async function saveSession(env2, session) {
  await env2.CACHE.put(sessionKey(session.testId), JSON.stringify(session), {
    expirationTtl: SESSION_TTL_SECONDS
  });
  await updateHistory(env2, session.userId, session);
}
__name(saveSession, "saveSession");
async function updateHistory(env2, userId, session) {
  const key = userHistoryKey(userId);
  const raw2 = await env2.CACHE.get(key);
  let history = [];
  if (raw2) {
    try {
      history = JSON.parse(raw2);
    } catch (error48) {
      history = [];
    }
  }
  const summary = {
    testId: session.testId,
    startedAt: session.startedAt,
    completedAt: session.completedAt,
    status: session.status,
    languageCode: session.languageCode,
    testType: session.testType,
    testLevel: session.testLevel,
    overallScore: session.result?.overallScore,
    level: session.result?.level
  };
  history = history.filter((item) => item.testId !== session.testId);
  history.unshift(summary);
  if (history.length > MAX_HISTORY_ITEMS) {
    history = history.slice(0, MAX_HISTORY_ITEMS);
  }
  await env2.CACHE.put(key, JSON.stringify(history), {
    expirationTtl: HISTORY_TTL_SECONDS
  });
}
__name(updateHistory, "updateHistory");
async function getUserHistory(env2, userId) {
  const raw2 = await env2.CACHE.get(userHistoryKey(userId));
  if (!raw2) return [];
  try {
    return JSON.parse(raw2);
  } catch (error48) {
    return [];
  }
}
__name(getUserHistory, "getUserHistory");
function buildAudioKey(session, questionId) {
  return `level-test/${session.userId}/${session.testId}/question-${questionId}.webm`;
}
__name(buildAudioKey, "buildAudioKey");
function buildAudioUrl(testId, questionId) {
  return `/api/v1/level-test/${testId}/audio/${questionId}`;
}
__name(buildAudioUrl, "buildAudioUrl");
function sanitizeSession(session) {
  return {
    testId: Number(session.testId),
    status: session.status,
    languageCode: session.languageCode,
    testType: session.testType,
    testLevel: session.testLevel,
    mode: session.mode,
    startedAt: session.startedAt,
    completedAt: session.completedAt ?? null,
    questions: session.questions,
    answers: session.answers.map((answer) => ({
      questionId: answer.questionId,
      transcription: answer.transcription ?? null,
      submittedAt: answer.submittedAt,
      responseTimeSeconds: answer.responseTimeSeconds ?? null,
      audioUrl: answer.audioKey ? buildAudioUrl(session.testId, answer.questionId) : null,
      evaluation: answer.evaluation ?? null
    })),
    result: session.result ? {
      ...session.result,
      testId: Number(session.result.testId)
    } : null
  };
}
__name(sanitizeSession, "sanitizeSession");
function getUserIdOrThrow(c) {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("Authentication required", 401, "AUTH_REQUIRED");
  }
  return userId;
}
__name(getUserIdOrThrow, "getUserIdOrThrow");
function pickScore(value) {
  if (typeof value === "number" && Number.isFinite(value)) {
    return Math.max(0, Math.min(100, value));
  }
  if (typeof value === "string") {
    const parsed = Number.parseFloat(value);
    if (Number.isFinite(parsed)) {
      return Math.max(0, Math.min(100, parsed));
    }
  }
  return void 0;
}
__name(pickScore, "pickScore");
function upsertAnswer(session, questionId) {
  const existing = session.answers.find((answer2) => answer2.questionId === questionId);
  if (existing) {
    return existing;
  }
  const answer = {
    questionId,
    submittedAt: (/* @__PURE__ */ new Date()).toISOString(),
    responseTimeSeconds: null
  };
  session.answers.push(answer);
  return answer;
}
__name(upsertAnswer, "upsertAnswer");
function resolveQuestion(session, questionId) {
  if (questionId) {
    const question = session.questions.find((item) => item.id === questionId);
    if (!question) {
      throw new AppError("Invalid question id", 400, "LEVEL_TEST_INVALID_QUESTION");
    }
    return question;
  }
  const unanswered = session.questions.find((question) => !session.answers.some((answer) => answer.questionId === question.id));
  if (!unanswered) {
    throw new AppError("All questions already answered", 400, "LEVEL_TEST_COMPLETED");
  }
  return unanswered;
}
__name(resolveQuestion, "resolveQuestion");
function aggregateScores(evaluations) {
  const totals = {
    pronunciation: { sum: 0, count: 0 },
    fluency: { sum: 0, count: 0 },
    grammar: { sum: 0, count: 0 },
    vocabulary: { sum: 0, count: 0 },
    coherence: { sum: 0, count: 0 },
    interaction: { sum: 0, count: 0 }
  };
  for (const evaluation of evaluations) {
    for (const key of SCORE_KEYS) {
      const value = pickScore(evaluation.scores[key]);
      if (value !== void 0) {
        totals[key].sum += value;
        totals[key].count += 1;
      }
    }
  }
  const averages = {
    pronunciation: 0,
    fluency: 0,
    grammar: 0,
    vocabulary: 0,
    coherence: 0,
    interaction: 0
  };
  for (const key of SCORE_KEYS) {
    averages[key] = totals[key].count > 0 ? Math.round(totals[key].sum / totals[key].count) : 0;
  }
  return averages;
}
__name(aggregateScores, "aggregateScores");
function determineLevel(overallScore) {
  if (overallScore >= 85) return "C2";
  if (overallScore >= 75) return "C1";
  if (overallScore >= 65) return "B2";
  if (overallScore >= 55) return "B1";
  if (overallScore >= 45) return "A2";
  return "A1";
}
__name(determineLevel, "determineLevel");
async function evaluateSession(env2, session) {
  const evaluations = [];
  for (const question of session.questions) {
    const answer = session.answers.find((item) => item.questionId === question.id);
    if (!answer?.transcription) {
      continue;
    }
    if (!answer.evaluation) {
      try {
        const comprehensiveEval = await performComprehensiveEvaluation(
          env2.AI,
          answer.transcription,
          question.text,
          "good",
          // audioQuality - default to 'good', can be enhanced later
          0
          // responseTime - can be calculated from answer metadata
        );
        const scores = {
          pronunciation: comprehensiveEval.detailedScores.pronunciation,
          fluency: comprehensiveEval.detailedScores.fluency,
          grammar: comprehensiveEval.detailedScores.grammar,
          vocabulary: comprehensiveEval.detailedScores.vocabulary,
          coherence: comprehensiveEval.detailedScores.coherence,
          interaction: comprehensiveEval.detailedScores.coherence
          // Use coherence for interaction
        };
        const feedback = `Overall Level: ${comprehensiveEval.overallLevel} (${comprehensiveEval.subLevel})
Confidence: ${Math.round(comprehensiveEval.confidenceScore)}%

Pronunciation: ${comprehensiveEval.pronunciationAnalysis.overallScore}/100 - ${comprehensiveEval.pronunciationAnalysis.clarity} clarity
Grammar: ${comprehensiveEval.grammarAnalysis.accuracyScore}/100 - ${comprehensiveEval.grammarAnalysis.complexity} complexity
Vocabulary: ${comprehensiveEval.vocabularyAnalysis.rangeScore}/100 - ${comprehensiveEval.vocabularyAnalysis.sophisticationLevel} level
Fluency: ${comprehensiveEval.fluencyAnalysis.overallScore}/100 - ${comprehensiveEval.fluencyAnalysis.speedLevel} speed`;
        const suggestions2 = [
          ...comprehensiveEval.pronunciationAnalysis.improvementAreas.map((area) => `Pronunciation: ${area}`),
          ...comprehensiveEval.grammarAnalysis.commonErrors.slice(0, 2).map((err) => `Grammar: ${err}`),
          ...comprehensiveEval.studyPlan.shortTerm.slice(0, 2)
        ];
        answer.evaluation = {
          scores,
          feedback,
          suggestions: suggestions2,
          estimatedLevel: comprehensiveEval.overallLevel,
          // Store comprehensive data for later use
          comprehensiveData: comprehensiveEval
        };
      } catch (error48) {
        log3.warn("Comprehensive evaluation failed, using basic evaluation:", error48);
        const evaluation = await evaluateLanguageLevel(env2.AI, answer.transcription, question.text);
        const scores = {
          pronunciation: pickScore(evaluation?.scores?.pronunciation) ?? 0,
          fluency: pickScore(evaluation?.scores?.fluency) ?? 0,
          grammar: pickScore(evaluation?.scores?.grammar) ?? 0,
          vocabulary: pickScore(evaluation?.scores?.vocabulary) ?? 0,
          coherence: pickScore(evaluation?.scores?.coherence) ?? 0,
          interaction: pickScore(evaluation?.scores?.interaction) ?? 0
        };
        answer.evaluation = {
          scores,
          feedback: evaluation?.feedback ?? "",
          suggestions: Array.isArray(evaluation?.suggestions) ? evaluation.suggestions.filter(Boolean) : [],
          estimatedLevel: evaluation?.estimatedLevel
        };
      }
    }
    evaluations.push({
      questionId: question.id,
      question: question.text,
      transcription: answer.transcription,
      scores: answer.evaluation.scores,
      feedback: answer.evaluation.feedback,
      suggestions: answer.evaluation.suggestions,
      estimatedLevel: answer.evaluation.estimatedLevel
    });
  }
  if (evaluations.length === 0) {
    throw new AppError("No submissions to evaluate", 400, "LEVEL_TEST_NO_SUBMISSIONS");
  }
  const averages = aggregateScores(evaluations);
  const overallScore = Math.round(
    SCORE_KEYS.reduce((sum, key) => sum + averages[key], 0) / SCORE_KEYS.length
  );
  const level = determineLevel(overallScore);
  const strengths = SCORE_KEYS.filter((key) => averages[key] >= 75).map((key) => key);
  const improvements = SCORE_KEYS.filter((key) => averages[key] <= 55).map((key) => key);
  const suggestions = Array.from(
    new Set(
      evaluations.flatMap((evaluation) => evaluation.suggestions).filter(Boolean)
    )
  ).slice(0, 6);
  const analysis = {
    grammar: averages.grammar,
    vocabulary: averages.vocabulary,
    fluency: averages.fluency,
    pronunciation: averages.pronunciation,
    taskAchievement: averages.coherence,
    interaction: averages.interaction
  };
  const feedbackSummary = await generateLevelFeedback(env2.AI, analysis, level);
  const result = {
    testId: session.testId,
    level,
    estimatedLevel: level,
    overallScore,
    scores: averages,
    strengths,
    improvements,
    suggestions,
    evaluations,
    completedAt: (/* @__PURE__ */ new Date()).toISOString(),
    feedbackSummary
  };
  return result;
}
__name(evaluateSession, "evaluateSession");
async function createSession(c, mode) {
  const env2 = c.env;
  const userId = getUserIdOrThrow(c);
  const body = await c.req.json().catch(() => ({}));
  const languageCode = typeof body?.languageCode === "string" ? body.languageCode : typeof body?.targetLanguage === "string" ? body.targetLanguage : "en";
  const testType = typeof body?.testType === "string" ? body.testType : "SPEAKING";
  const testLevel = typeof body?.testLevel === "string" ? body.testLevel : "INTERMEDIATE";
  const requestedQuestions = Number(body?.totalQuestions) || TEST_QUESTIONS.length;
  const questionCount = Math.min(Math.max(requestedQuestions, 1), TEST_QUESTIONS.length);
  const testId = generateTestId();
  const questions = TEST_QUESTIONS.slice(0, questionCount).map((question, index) => ({
    ...question,
    id: index + 1
  }));
  const session = {
    testId,
    userId,
    languageCode,
    testType,
    testLevel,
    questionCount,
    mode,
    questions,
    answers: [],
    status: "in-progress",
    startedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  await saveSession(env2, session);
  return session;
}
__name(createSession, "createSession");
async function handleAudioSubmission(c, session, providedQuestionId) {
  const env2 = c.env;
  const formData = await c.req.formData();
  const audio = formData.get("audio");
  if (!audio) {
    throw new AppError("Audio file missing", 400, "LEVEL_TEST_AUDIO_REQUIRED");
  }
  const questionIdFromForm = formData.get("questionId");
  const questionNumber = providedQuestionId ?? (typeof questionIdFromForm === "string" ? Number.parseInt(questionIdFromForm, 10) : void 0);
  const question = resolveQuestion(session, Number.isFinite(questionNumber) ? Number(questionNumber) : void 0);
  const answer = upsertAnswer(session, question.id);
  const audioBuffer = await audio.arrayBuffer();
  const audioKey = buildAudioKey(session, question.id);
  await saveToR2(env2.STORAGE, audioKey, audioBuffer, audio.type || "audio/webm");
  const transcription = await processAudio(env2.AI, audioBuffer, {
    task: "transcribe",
    language: session.languageCode || "en",
    vad_filter: true,
    initial_prompt: question.text
  });
  answer.audioKey = audioKey;
  answer.audioType = audio.type || "audio/webm";
  answer.transcription = transcription?.text ?? transcription;
  answer.submittedAt = (/* @__PURE__ */ new Date()).toISOString();
  answer.responseTimeSeconds = typeof formData.get("responseTimeSeconds") === "string" ? Number.parseFloat(formData.get("responseTimeSeconds")) : answer.responseTimeSeconds ?? null;
  answer.evaluation = void 0;
  await saveSession(env2, session);
  return {
    testId: Number(session.testId),
    questionId: question.id,
    transcription: answer.transcription,
    audioUrl: buildAudioUrl(session.testId, question.id),
    submittedAt: answer.submittedAt
  };
}
__name(handleAudioSubmission, "handleAudioSubmission");
levelTestRoutes.get("/questions", (c) => {
  return successResponse(c, { questions: TEST_QUESTIONS });
});
levelTestRoutes.post("/start", auth(), async (c) => {
  const session = await createSession(c, "standard");
  return successResponse(c, {
    testId: Number(session.testId),
    languageCode: session.languageCode,
    testType: session.testType,
    testLevel: session.testLevel,
    totalQuestions: session.questionCount,
    questions: session.questions,
    startedAt: session.startedAt
  });
});
levelTestRoutes.post("/restart", auth(), async (c) => {
  const env2 = c.env;
  const userId = getUserIdOrThrow(c);
  const body = await c.req.json().catch(() => ({}));
  const previousTestId = typeof body?.previousTestId === "string" ? body.previousTestId : typeof body?.testId === "string" ? body.testId : void 0;
  if (previousTestId) {
    const previous = await loadSession(env2, previousTestId);
    if (previous && previous.userId === userId && previous.status === "in-progress") {
      previous.status = "cancelled";
      previous.completedAt = (/* @__PURE__ */ new Date()).toISOString();
      await saveSession(env2, previous);
    }
  }
  const session = await createSession(c, "standard");
  return successResponse(c, {
    testId: Number(session.testId),
    languageCode: session.languageCode,
    testType: session.testType,
    testLevel: session.testLevel,
    totalQuestions: session.questionCount,
    questions: session.questions,
    startedAt: session.startedAt
  });
});
levelTestRoutes.post("/voice/start", auth(), async (c) => {
  const session = await createSession(c, "voice");
  return successResponse(c, {
    testId: Number(session.testId),
    languageCode: session.languageCode,
    testType: session.testType,
    testLevel: session.testLevel,
    totalQuestions: session.questionCount,
    questions: session.questions,
    startedAt: session.startedAt
  });
});
levelTestRoutes.post("/voice/:testId/upload", auth(), async (c) => {
  const env2 = c.env;
  const userId = getUserIdOrThrow(c);
  const testId = c.req.param("testId");
  const session = await requireSession(env2, testId);
  ensureOwnership(session, userId);
  if (session.status === "completed") {
    throw new AppError("Test already completed", 400, "LEVEL_TEST_ALREADY_COMPLETED");
  }
  const response = await handleAudioSubmission(c, session, null);
  return successResponse(c, response);
});
levelTestRoutes.post("/voice/transcribe", auth(), async (c) => {
  const userId = getUserIdOrThrow(c);
  const contentType = c.req.header("Content-Type") || "";
  let audioBuffer = null;
  let mimeType = "audio/webm";
  let whisperOptions = {};
  if (contentType.startsWith("multipart/form-data")) {
    const formData = await c.req.formData();
    const audio = formData.get("audio");
    if (!(audio instanceof File)) {
      throw new AppError("audio file is required", 400, "LEVEL_TEST_AUDIO_REQUIRED");
    }
    audioBuffer = await audio.arrayBuffer();
    mimeType = audio.type || mimeType;
    whisperOptions = {
      language: formData.get("language") || void 0,
      task: formData.get("task") || void 0,
      initial_prompt: formData.get("initialPrompt") || void 0,
      prefix: formData.get("prefix") || void 0,
      vad_filter: formData.get("vadFilter") ?? formData.get("vad_filter") ?? void 0
    };
  } else {
    const body = await c.req.json().catch(() => ({}));
    if (typeof body.audio === "string") {
      const cleaned = body.audio.replace(/^data:[^;]+;base64,/, "");
      const binaryString = atob(cleaned);
      const view = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        view[i] = binaryString.charCodeAt(i);
      }
      audioBuffer = view.buffer;
      mimeType = typeof body.mimeType === "string" ? body.mimeType : mimeType;
    }
    whisperOptions = {
      language: typeof body.language === "string" ? body.language : void 0,
      task: typeof body.task === "string" ? body.task : void 0,
      initial_prompt: typeof body.initialPrompt === "string" ? body.initialPrompt : void 0,
      prefix: typeof body.prefix === "string" ? body.prefix : void 0,
      vad_filter: typeof body.vadFilter === "boolean" ? body.vadFilter : void 0
    };
  }
  if (!audioBuffer) {
    throw new AppError("audio payload is required", 400, "LEVEL_TEST_AUDIO_REQUIRED");
  }
  const transcription = await processAudio(c.env.AI, audioBuffer, {
    task: whisperOptions.task || "transcribe",
    language: whisperOptions.language || "auto",
    vad_filter: whisperOptions.vad_filter !== void 0 ? Boolean(whisperOptions.vad_filter) : true,
    initial_prompt: whisperOptions.initial_prompt,
    prefix: whisperOptions.prefix
  });
  return successResponse(c, {
    userId,
    mimeType,
    transcription: transcription.text,
    wordCount: transcription.word_count,
    words: transcription.words ?? [],
    chunks: transcription.chunks
  });
});
levelTestRoutes.post("/voice/:testId/analyze", auth(), async (c) => {
  const env2 = c.env;
  const userId = getUserIdOrThrow(c);
  const testId = c.req.param("testId");
  const session = await requireSession(env2, testId);
  ensureOwnership(session, userId);
  const result = await evaluateSession(env2, session);
  session.result = result;
  session.status = "completed";
  session.completedAt = result.completedAt;
  await saveSession(env2, session);
  return successResponse(c, {
    ...result,
    testId: Number(result.testId)
  });
});
levelTestRoutes.get("/voice/:testId/result", auth(), async (c) => {
  const env2 = c.env;
  const userId = getUserIdOrThrow(c);
  const testId = c.req.param("testId");
  const session = await requireSession(env2, testId);
  ensureOwnership(session, userId);
  if (!session.result) {
    throw new AppError("Result not available yet", 404, "LEVEL_TEST_RESULT_NOT_READY");
  }
  return successResponse(c, {
    ...session.result,
    testId: Number(session.result.testId)
  });
});
levelTestRoutes.post("/submit", auth(), async (c) => {
  const env2 = c.env;
  const userId = getUserIdOrThrow(c);
  const body = await c.req.json().catch(() => ({}));
  const testId = typeof body?.testId === "number" ? String(body.testId) : typeof body?.testId === "string" ? body.testId : void 0;
  const questionNumber = typeof body?.questionNumber === "number" ? body.questionNumber : Number(body?.questionId);
  const userAnswer = typeof body?.userAnswer === "string" ? body.userAnswer.trim() : void 0;
  if (!testId || !questionNumber || !userAnswer) {
    throw new AppError("testId, questionNumber and userAnswer are required", 400, "LEVEL_TEST_INVALID_SUBMISSION");
  }
  const session = await requireSession(env2, testId);
  ensureOwnership(session, userId);
  if (session.status === "completed") {
    throw new AppError("Test already completed", 400, "LEVEL_TEST_ALREADY_COMPLETED");
  }
  const question = resolveQuestion(session, questionNumber);
  const answer = upsertAnswer(session, question.id);
  answer.transcription = userAnswer;
  answer.submittedAt = (/* @__PURE__ */ new Date()).toISOString();
  answer.responseTimeSeconds = typeof body?.responseTimeSeconds === "number" ? body.responseTimeSeconds : answer.responseTimeSeconds ?? null;
  answer.evaluation = void 0;
  await saveSession(env2, session);
  return successResponse(c, {
    testId: Number(session.testId),
    questionId: question.id,
    saved: true
  });
});
levelTestRoutes.post("/:testId/audio-answer", auth(), async (c) => {
  const env2 = c.env;
  const userId = getUserIdOrThrow(c);
  const testId = c.req.param("testId");
  const session = await requireSession(env2, testId);
  ensureOwnership(session, userId);
  if (session.status === "completed") {
    throw new AppError("Test already completed", 400, "LEVEL_TEST_ALREADY_COMPLETED");
  }
  const response = await handleAudioSubmission(c, session);
  return successResponse(c, response);
});
levelTestRoutes.post("/:testId/complete", auth(), async (c) => {
  const env2 = c.env;
  const userId = getUserIdOrThrow(c);
  const testId = c.req.param("testId");
  const session = await requireSession(env2, testId);
  ensureOwnership(session, userId);
  const result = await evaluateSession(env2, session);
  session.result = result;
  session.status = "completed";
  session.completedAt = result.completedAt;
  await saveSession(env2, session);
  return successResponse(c, {
    ...result,
    testId: Number(result.testId)
  });
});
levelTestRoutes.get("/my-tests", auth(), async (c) => {
  const env2 = c.env;
  const userId = getUserIdOrThrow(c);
  const history = await getUserHistory(env2, userId);
  return successResponse(c, history.map((entry) => ({
    ...entry,
    testId: Number(entry.testId)
  })));
});
levelTestRoutes.get("/summary", auth(), async (c) => {
  const env2 = c.env;
  const userId = getUserIdOrThrow(c);
  const history = await getUserHistory(env2, userId);
  if (history.length === 0) {
    return successResponse(c, {
      totalTests: 0,
      completedTests: 0,
      averageScore: null,
      latestLevel: null,
      latestCompletedAt: null
    });
  }
  const completed = history.filter((item) => item.status === "completed" && typeof item.overallScore === "number");
  const averageScore = completed.length > 0 ? Math.round(completed.reduce((sum, item) => sum + (item.overallScore || 0), 0) / completed.length) : null;
  const latestCompleted = completed.sort((a, b) => (b.completedAt ? Date.parse(b.completedAt) : 0) - (a.completedAt ? Date.parse(a.completedAt) : 0))[0];
  return successResponse(c, {
    totalTests: history.length,
    completedTests: completed.length,
    averageScore,
    latestLevel: latestCompleted?.level ?? null,
    latestCompletedAt: latestCompleted?.completedAt ?? null
  });
});
levelTestRoutes.get("/:testId/audio/:questionId", auth(), async (c) => {
  const env2 = c.env;
  const userId = getUserIdOrThrow(c);
  const testId = c.req.param("testId");
  const questionId = Number.parseInt(c.req.param("questionId"), 10);
  const session = await requireSession(env2, testId);
  ensureOwnership(session, userId);
  const answer = session.answers.find((item) => item.questionId === questionId);
  if (!answer?.audioKey) {
    throw new AppError("Audio not found for this question", 404, "LEVEL_TEST_AUDIO_NOT_FOUND");
  }
  const audio = await getFromR2(env2.STORAGE, answer.audioKey);
  if (!audio) {
    throw new AppError("Audio not found", 404, "LEVEL_TEST_AUDIO_NOT_FOUND");
  }
  return new Response(audio.body, {
    headers: {
      "Content-Type": answer.audioType || audio.httpMetadata?.contentType || "audio/webm",
      "Cache-Control": "private, max-age=86400"
    }
  });
});
levelTestRoutes.get("/:testId", auth(), async (c) => {
  const env2 = c.env;
  const userId = getUserIdOrThrow(c);
  const testId = c.req.param("testId");
  const session = await requireSession(env2, testId);
  ensureOwnership(session, userId);
  return successResponse(c, sanitizeSession(session));
});
levelTestRoutes.get("/:testId/answer/:questionId/detailed", auth(), async (c) => {
  const env2 = c.env;
  const userId = getUserIdOrThrow(c);
  const testId = c.req.param("testId");
  const questionId = c.req.param("questionId");
  const session = await requireSession(env2, testId);
  ensureOwnership(session, userId);
  const answer = session.answers.find((a) => a.questionId === questionId);
  if (!answer) {
    throw new AppError("Answer not found", 404, "ANSWER_NOT_FOUND");
  }
  if (answer.evaluation && "comprehensiveData" in answer.evaluation) {
    return successResponse(c, {
      questionId,
      transcription: answer.transcription,
      evaluation: answer.evaluation.comprehensiveData
    });
  }
  throw new AppError("Detailed evaluation not available", 404, "DETAILED_EVALUATION_NOT_FOUND");
});

// src/routes/webrtc.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/utils/activeRooms.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ACTIVE_ROOMS_CACHE_KEY = "active_rooms";
var DEFAULT_TTL_SECONDS = 3600;
async function readActiveRooms(cache) {
  if (!cache) return [];
  const raw2 = await cache.get(ACTIVE_ROOMS_CACHE_KEY);
  if (!raw2) return [];
  try {
    const parsed = JSON.parse(raw2);
    if (Array.isArray(parsed)) {
      return parsed;
    }
    return [];
  } catch (error48) {
    console.error("Failed to parse active rooms cache", error48);
    return [];
  }
}
__name(readActiveRooms, "readActiveRooms");
async function writeActiveRooms(cache, rooms) {
  if (!cache) return;
  await cache.put(
    ACTIVE_ROOMS_CACHE_KEY,
    JSON.stringify(rooms),
    { expirationTtl: DEFAULT_TTL_SECONDS }
  );
}
__name(writeActiveRooms, "writeActiveRooms");
async function getActiveRooms(cache) {
  return readActiveRooms(cache);
}
__name(getActiveRooms, "getActiveRooms");
async function upsertActiveRoom(cache, room) {
  if (!cache) return;
  const rooms = await readActiveRooms(cache);
  const index = rooms.findIndex((item) => item.roomId === room.roomId);
  const nextRoom = {
    ...room,
    updatedAt: room.updatedAt || (/* @__PURE__ */ new Date()).toISOString()
  };
  if (index >= 0) {
    rooms[index] = nextRoom;
  } else {
    rooms.push(nextRoom);
  }
  await writeActiveRooms(cache, rooms);
}
__name(upsertActiveRoom, "upsertActiveRoom");
async function removeActiveRoom(cache, roomId) {
  if (!cache) return;
  const rooms = await readActiveRooms(cache);
  const filtered = rooms.filter((room) => room.roomId !== roomId);
  if (filtered.length === rooms.length) {
    return;
  }
  await writeActiveRooms(cache, filtered);
}
__name(removeActiveRoom, "removeActiveRoom");

// src/routes/webrtc.ts
var webrtcRoutes = new Hono2();
webrtcRoutes.post("/create", auth({ optional: true }), async (c) => {
  const { roomType = "audio", maxParticipants = 4, metadata = {} } = await c.req.json();
  if (!["audio", "video"].includes(roomType)) {
    throw validationError('Invalid room type. Must be "audio" or "video"');
  }
  if (maxParticipants < 2 || maxParticipants > 10) {
    throw validationError("Max participants must be between 2 and 10");
  }
  const roomId = crypto.randomUUID();
  const id = c.env.ROOM.idFromName(roomId);
  const room = c.env.ROOM.get(id);
  const response = await room.fetch(new Request("http://room/init", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ roomType, maxParticipants, metadata })
  }));
  if (!response.ok) {
    const error48 = await response.json();
    throw new Error(String(error48?.message) || "Failed to initialize room");
  }
  const data = {
    roomId,
    roomType,
    maxParticipants,
    metadata,
    websocketUrl: `/api/v1/room/${roomId}/ws`,
    joinUrl: `/api/v1/room/${roomId}/join`,
    createdAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  await c.env.CACHE.put(
    `room:${roomId}`,
    JSON.stringify(data),
    { expirationTtl: 3600 }
    // 1 hour
  );
  return createdResponse(c, data, `/api/v1/room/${roomId}`);
});
webrtcRoutes.get("/active", async (c) => {
  const rooms = await getActiveRooms(c.env.CACHE);
  return successResponse(c, rooms);
});
webrtcRoutes.post("/:roomId/join", auth({ optional: true }), async (c) => {
  const roomId = c.req.param("roomId");
  const { userId, userName, userMetadata = {} } = await c.req.json();
  if (!userId || !userName) {
    throw validationError("userId and userName are required");
  }
  const cachedRoom = await c.env.CACHE.get(`room:${roomId}`);
  if (!cachedRoom) {
    const id2 = c.env.ROOM.idFromName(roomId);
    const room2 = c.env.ROOM.get(id2);
    const infoResponse = await room2.fetch(new Request("http://room/info"));
    if (!infoResponse.ok) {
      throw notFoundError("Room");
    }
  }
  const id = c.env.ROOM.idFromName(roomId);
  const room = c.env.ROOM.get(id);
  const response = await room.fetch(new Request("http://room/join", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ userId, userName, userMetadata })
  }));
  if (!response.ok) {
    const error48 = await response.json();
    if (response.status === 409) {
      throw conflictError(String(error48?.message) || "Room is full");
    }
    throw new Error(String(error48?.message) || "Failed to join room");
  }
  const result = await response.json();
  return successResponse(c, {
    ...result || {},
    websocketUrl: `/api/v1/room/${roomId}/ws?userId=${userId}&userName=${encodeURIComponent(userName)}`
  });
});
webrtcRoutes.post("/:roomId/leave", auth({ optional: true }), async (c) => {
  const roomId = c.req.param("roomId");
  const { userId } = await c.req.json();
  if (!userId) {
    throw validationError("userId is required");
  }
  const id = c.env.ROOM.idFromName(roomId);
  const room = c.env.ROOM.get(id);
  const response = await room.fetch(new Request("http://room/leave", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ userId })
  }));
  if (!response.ok) {
    const error48 = await response.json();
    throw new Error(String(error48?.message) || "Failed to leave room");
  }
  return successResponse(c, await response.json());
});
webrtcRoutes.get("/:roomId/ws", async (c) => {
  const roomId = c.req.param("roomId");
  const userId = c.req.query("userId");
  const userName = c.req.query("userName") || "Anonymous";
  const upgrade = c.req.header("Upgrade");
  if (!upgrade || upgrade !== "websocket") {
    throw validationError("Expected WebSocket upgrade header");
  }
  if (!userId) {
    throw validationError("userId parameter is required");
  }
  const id = c.env.ROOM.idFromName(roomId);
  const room = c.env.ROOM.get(id);
  const wsUrl = `http://room/websocket?userId=${userId}&userName=${encodeURIComponent(userName)}`;
  return room.fetch(new Request(wsUrl, {
    headers: c.req.raw.headers
  }));
});
webrtcRoutes.patch("/:roomId/settings", auth({ optional: true }), async (c) => {
  const roomId = c.req.param("roomId");
  const settings = await c.req.json();
  const id = c.env.ROOM.idFromName(roomId);
  const room = c.env.ROOM.get(id);
  const response = await room.fetch(new Request("http://room/settings", {
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(settings)
  }));
  if (!response.ok) {
    const error48 = await response.json();
    throw new Error(String(error48?.message) || "Failed to update settings");
  }
  const cachedRoom = await c.env.CACHE.get(`room:${roomId}`);
  if (cachedRoom) {
    const roomData = JSON.parse(cachedRoom);
    await c.env.CACHE.put(
      `room:${roomId}`,
      JSON.stringify({ ...roomData, ...settings }),
      { expirationTtl: 3600 }
    );
  }
  return successResponse(c, await response.json());
});
webrtcRoutes.get("/:roomId/info", async (c) => {
  const roomId = c.req.param("roomId");
  const cachedRoom = await c.env.CACHE.get(`room:${roomId}`);
  if (cachedRoom) {
    return successResponse(c, JSON.parse(cachedRoom));
  }
  const id = c.env.ROOM.idFromName(roomId);
  const room = c.env.ROOM.get(id);
  const response = await room.fetch(new Request("http://room/info"));
  if (!response.ok) {
    if (response.status === 404) {
      throw notFoundError("Room");
    }
    const error48 = await response.json();
    throw new Error(String(error48?.message) || "Failed to get room info");
  }
  const data = await response.json();
  await c.env.CACHE.put(
    `room:${roomId}`,
    JSON.stringify(data),
    { expirationTtl: 3600 }
  );
  return successResponse(c, data);
});
webrtcRoutes.get("/:roomId/ice-servers", async (c) => {
  const roomId = c.req.param("roomId");
  const id = c.env.ROOM.idFromName(roomId);
  const room = c.env.ROOM.get(id);
  const response = await room.fetch(new Request("http://room/ice-servers"));
  if (!response.ok) {
    const error48 = await response.json();
    throw new Error(String(error48?.message) || "Failed to get ICE servers");
  }
  return successResponse(c, await response.json());
});
webrtcRoutes.get("/:roomId/metrics", auth({ optional: true }), async (c) => {
  const roomId = c.req.param("roomId");
  const id = c.env.ROOM.idFromName(roomId);
  const room = c.env.ROOM.get(id);
  const response = await room.fetch(new Request("http://room/metrics"));
  if (!response.ok) {
    if (response.status === 404) {
      throw notFoundError("Room");
    }
    const error48 = await response.json();
    throw new Error(String(error48?.message) || "Failed to get room metrics");
  }
  const data = await response.json();
  return successResponse(c, {
    ...data || {},
    analytics: {
      uptimeHours: Math.floor((data?.metrics?.sessionDuration || 0) / 3600),
      averageParticipants: (data?.metrics?.totalParticipants || 0) > 0 ? (data?.metrics?.peakParticipants || 0) / Math.max(1, data?.currentParticipants || 0) : 0,
      messagesPerMinute: (data?.metrics?.sessionDuration || 0) > 0 ? (data?.metrics?.messagesExchanged || 0) / ((data?.metrics?.sessionDuration || 0) / 60) : 0
    }
  });
});
webrtcRoutes.post("/:roomId/recording/upload", auth({ optional: true }), async (c) => {
  const roomId = c.req.param("roomId");
  const formData = await c.req.formData();
  const file2 = formData.get("recording");
  const userId = formData.get("userId");
  const filename = formData.get("filename");
  if (!file2 || !userId || !filename) {
    throw validationError("recording, userId, and filename are required");
  }
  const timestamp = Date.now();
  const extension = filename.split(".").pop() || "webm";
  const storageKey = `recordings/${roomId}/${userId}/${timestamp}-${filename}`;
  try {
    await c.env.STORAGE.put(storageKey, file2.stream(), {
      httpMetadata: {
        contentType: file2.type || "video/webm"
      }
    });
    const id = c.env.ROOM.idFromName(roomId);
    const room = c.env.ROOM.get(id);
    await room.fetch(new Request("http://room/websocket", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        type: "recording-chunk",
        userId,
        data: {
          filename: storageKey,
          originalFilename: filename,
          size: file2.size,
          duration: formData.get("duration") || 0,
          contentType: file2.type
        }
      })
    }));
    return successResponse(c, {
      uploadedTo: storageKey,
      size: file2.size,
      contentType: file2.type,
      uploadedAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error48) {
    console.error("Recording upload error:", error48);
    throw new Error("Failed to upload recording");
  }
});
webrtcRoutes.get("/list", auth({ roles: ["admin"] }), async (c) => {
  return successResponse(c, {
    rooms: [],
    total: 0,
    message: "Room listing requires additional infrastructure setup"
  });
});

// src/routes/upload.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/middleware/security.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function bodySizeLimit(maxSize = 10 * 1024 * 1024) {
  return async (c, next) => {
    const contentLength = c.req.header("Content-Length");
    if (contentLength && parseInt(contentLength) > maxSize) {
      throw new ApiError(413, "PAYLOAD_TOO_LARGE", `Request body too large. Maximum size: ${maxSize} bytes`);
    }
    await next();
  };
}
__name(bodySizeLimit, "bodySizeLimit");

// src/routes/upload.ts
var uploadRoutes = new Hono2();
var FILE_LIMITS = {
  audio: {
    types: ["audio/webm", "audio/mp3", "audio/wav", "audio/ogg", "audio/m4a"],
    maxSize: 50 * 1024 * 1024
    // 50MB
  },
  image: {
    types: ["image/jpeg", "image/png", "image/webp", "image/gif", "image/avif"],
    maxSize: 10 * 1024 * 1024
    // 10MB
  },
  video: {
    types: ["video/mp4", "video/webm", "video/quicktime"],
    maxSize: 100 * 1024 * 1024
    // 100MB
  },
  document: {
    types: ["application/pdf", "application/msword", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
    maxSize: 20 * 1024 * 1024
    // 20MB
  }
};
function validateFile(file2, type) {
  const limits = FILE_LIMITS[type];
  if (!limits.types.includes(file2.type)) {
    throw validationError(`Invalid file type. Allowed types: ${limits.types.join(", ")}`);
  }
  if (file2.size > limits.maxSize) {
    const maxSizeMB = limits.maxSize / (1024 * 1024);
    throw validationError(`File too large. Maximum size: ${maxSizeMB}MB`);
  }
}
__name(validateFile, "validateFile");
function generateFileKey(type, userId, fileName, folder) {
  const timestamp = Date.now();
  const safeFileName = fileName.replace(/[^a-zA-Z0-9.-]/g, "_");
  const parts = [type];
  if (folder) {
    parts.push(folder);
  }
  parts.push(userId, `${timestamp}-${safeFileName}`);
  return parts.join("/");
}
__name(generateFileKey, "generateFileKey");
uploadRoutes.post("/audio", auth(), bodySizeLimit(50 * 1024 * 1024), async (c) => {
  const formData = await c.req.formData();
  const file2 = formData.get("file");
  const folder = formData.get("folder");
  const metadata = formData.get("metadata");
  if (!file2) {
    throw validationError("File is required");
  }
  const user = getCurrentUser(c);
  validateFile(file2, "audio");
  const buffer = await file2.arrayBuffer();
  const key = generateFileKey("audio", user.id, file2.name, folder);
  const uploadMetadata = metadata ? JSON.parse(metadata) : {};
  await saveToR2(c.env.STORAGE, key, buffer, file2.type, {
    userId: user.id,
    originalName: file2.name,
    ...uploadMetadata
  });
  const response = {
    key,
    url: `/api/v1/upload/file/${key}`,
    size: file2.size,
    type: file2.type,
    metadata: uploadMetadata
  };
  return createdResponse(c, response, response.url);
});
uploadRoutes.post("/image", auth(), bodySizeLimit(10 * 1024 * 1024), async (c) => {
  const formData = await c.req.formData();
  const file2 = formData.get("file");
  const type = formData.get("type");
  const metadata = formData.get("metadata");
  if (!file2) {
    throw validationError("File is required");
  }
  const user = getCurrentUser(c);
  validateFile(file2, "image");
  const buffer = await file2.arrayBuffer();
  const key = generateFileKey("images", user.id, file2.name, type || "general");
  const uploadMetadata = metadata ? JSON.parse(metadata) : {};
  await saveToR2(c.env.STORAGE, key, buffer, file2.type, {
    userId: user.id,
    originalName: file2.name,
    imageType: type,
    ...uploadMetadata
  });
  let variants = {};
  if (type === "profile") {
    variants = {
      thumbnail: `/api/v1/upload/file/${key}?variant=thumbnail`,
      medium: `/api/v1/upload/file/${key}?variant=medium`,
      large: `/api/v1/upload/file/${key}?variant=large`
    };
  }
  const response = {
    key,
    url: `/api/v1/upload/file/${key}`,
    size: file2.size,
    type: file2.type,
    variants,
    metadata: uploadMetadata
  };
  if (type === "profile") {
    await c.env.CACHE.put(
      `profile-image:${user.id}`,
      JSON.stringify(response),
      { expirationTtl: 86400 }
      // 24 hours
    );
  }
  return createdResponse(c, response, response.url);
});
uploadRoutes.post("/video", auth(), bodySizeLimit(100 * 1024 * 1024), async (c) => {
  const formData = await c.req.formData();
  const file2 = formData.get("file");
  const metadata = formData.get("metadata");
  if (!file2) {
    throw validationError("File is required");
  }
  const user = getCurrentUser(c);
  validateFile(file2, "video");
  const buffer = await file2.arrayBuffer();
  const key = generateFileKey("videos", user.id, file2.name);
  const uploadMetadata = metadata ? JSON.parse(metadata) : {};
  await saveToR2(c.env.STORAGE, key, buffer, file2.type, {
    userId: user.id,
    originalName: file2.name,
    ...uploadMetadata
  });
  const response = {
    key,
    url: `/api/v1/upload/file/${key}`,
    size: file2.size,
    type: file2.type,
    metadata: uploadMetadata
  };
  return createdResponse(c, response, response.url);
});
uploadRoutes.get("/file/*", async (c) => {
  const path = c.req.path.replace("/api/v1/upload/file/", "");
  const variant = c.req.query("variant");
  const download = c.req.query("download") === "true";
  if (!path) {
    throw validationError("Invalid file path");
  }
  const cacheKey = `file:${path}${variant ? `:${variant}` : ""}`;
  const cached2 = await c.env.CACHE.get(cacheKey, { type: "stream" });
  if (cached2) {
    setCacheHeaders(c, { maxAge: 3600, sMaxAge: 86400 });
    return new Response(cached2, {
      headers: c.res.headers
    });
  }
  const file2 = await getFromR2(c.env.STORAGE, path);
  if (!file2) {
    throw notFoundError("File");
  }
  const headers = new Headers();
  headers.set("Content-Type", file2.httpMetadata?.contentType || "application/octet-stream");
  if (download || file2.httpMetadata?.contentDisposition) {
    const filename = file2.customMetadata?.originalName || path.split("/").pop();
    headers.set("Content-Disposition", `attachment; filename="${filename}"`);
  } else {
    headers.set("Content-Disposition", "inline");
  }
  setCacheHeaders(c, {
    maxAge: 3600,
    // 1 hour browser cache
    sMaxAge: 86400,
    // 24 hours CDN cache
    private: false
  });
  Object.entries(c.res.headers).forEach(([key, value]) => {
    headers.set(key, value);
  });
  if (!download && file2.size < 1024 * 1024) {
    await c.env.CACHE.put(
      cacheKey,
      file2.body,
      { expirationTtl: 3600 }
    );
  }
  return new Response(file2.body, { headers });
});
uploadRoutes.delete("/file/*", auth(), async (c) => {
  const path = c.req.path.replace("/api/v1/upload/file/", "");
  const user = getCurrentUser(c);
  if (!path) {
    throw validationError("Invalid file path");
  }
  const file2 = await getFromR2(c.env.STORAGE, path);
  if (!file2) {
    throw notFoundError("File");
  }
  const fileUserId = file2.customMetadata?.userId;
  if (fileUserId !== user.id && user.role !== "admin") {
    throw forbiddenError("You do not have permission to delete this file");
  }
  await deleteFromR2(c.env.STORAGE, path);
  await c.env.CACHE.delete(`file:${path}`);
  if (path.includes("profile")) {
    await c.env.CACHE.delete(`profile-image:${user.id}`);
  }
  return noContentResponse(c);
});
uploadRoutes.post("/presigned-url", auth(), async (c) => {
  const { fileName, fileType, type = "general" } = await c.req.json();
  if (!fileName || !fileType) {
    throw validationError("fileName and fileType are required");
  }
  const user = getCurrentUser(c);
  const key = generateFileKey(type, user.id, fileName);
  try {
    const uploadUrl = `/api/v1/upload/${type}`;
    return successResponse(c, {
      uploadUrl,
      key,
      method: "POST",
      // Worker  POST  
      headers: {
        "Content-Type": "multipart/form-data"
      },
      fields: {
        key,
        fileName,
        fileType,
        type
      },
      expiresAt: new Date(Date.now() + 3600 * 1e3).toISOString()
    });
  } catch (error48) {
    console.error("Upload URL generation failed:", error48);
    throw validationError("Failed to generate upload URL");
  }
});

// src/routes/whisper.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var app = new Hono2();
app.use("/*", cors());
app.post("/transcribe", async (c) => {
  try {
    const contentType = c.req.header("content-type");
    let audioBuffer;
    let options = {};
    if (contentType?.includes("multipart/form-data")) {
      const formData = await c.req.formData();
      const audioFile = formData.get("audio");
      if (!audioFile) {
        return c.json({ error: "No audio file provided" }, 400);
      }
      audioBuffer = await audioFile.arrayBuffer();
      const task = formData.get("task");
      const language = formData.get("language");
      const vadFilter = formData.get("vad_filter");
      const initialPrompt = formData.get("initial_prompt");
      const prefix = formData.get("prefix");
      options = {
        task: task || "transcribe",
        language: language || "auto",
        vad_filter: vadFilter === "true",
        initial_prompt: initialPrompt,
        prefix
      };
    } else if (contentType?.includes("application/json")) {
      const body = await c.req.json();
      if (!body.audio) {
        return c.json({ error: "No audio data provided" }, 400);
      }
      const binaryString = atob(body.audio);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      audioBuffer = bytes.buffer;
      options = body.options || {};
    } else {
      audioBuffer = await c.req.arrayBuffer();
    }
    if (audioBuffer.byteLength > 25 * 1024 * 1024) {
      return c.json({ error: "Audio file too large. Maximum size is 25MB" }, 400);
    }
    const result = await processAudio(c.env.AI, audioBuffer, options);
    return c.json({
      success: true,
      transcription: result.text,
      word_count: result.word_count,
      words: result.words,
      chunks_processed: result.chunks,
      language: options.language || "auto",
      task: options.task || "transcribe"
    });
  } catch (error48) {
    log3.error("Transcription error", error48, { component: "WHISPER_SERVICE" });
    return c.json({
      error: "Transcription failed",
      message: error48 instanceof Error ? error48.message : "Unknown error"
    }, 500);
  }
});
app.get("/languages", (c) => {
  return c.json({
    supported_languages: [
      { code: "auto", name: "Auto-detect" },
      { code: "en", name: "English" },
      { code: "zh", name: "Chinese" },
      { code: "de", name: "German" },
      { code: "es", name: "Spanish" },
      { code: "ru", name: "Russian" },
      { code: "ko", name: "Korean" },
      { code: "fr", name: "French" },
      { code: "ja", name: "Japanese" },
      { code: "pt", name: "Portuguese" },
      { code: "tr", name: "Turkish" },
      { code: "pl", name: "Polish" },
      { code: "ca", name: "Catalan" },
      { code: "nl", name: "Dutch" },
      { code: "ar", name: "Arabic" },
      { code: "sv", name: "Swedish" },
      { code: "it", name: "Italian" },
      { code: "id", name: "Indonesian" },
      { code: "hi", name: "Hindi" },
      { code: "fi", name: "Finnish" },
      { code: "vi", name: "Vietnamese" },
      { code: "he", name: "Hebrew" },
      { code: "uk", name: "Ukrainian" },
      { code: "el", name: "Greek" },
      { code: "ms", name: "Malay" },
      { code: "cs", name: "Czech" },
      { code: "ro", name: "Romanian" },
      { code: "da", name: "Danish" },
      { code: "hu", name: "Hungarian" },
      { code: "ta", name: "Tamil" },
      { code: "no", name: "Norwegian" },
      { code: "th", name: "Thai" },
      { code: "ur", name: "Urdu" },
      { code: "hr", name: "Croatian" },
      { code: "bg", name: "Bulgarian" },
      { code: "lt", name: "Lithuanian" },
      { code: "la", name: "Latin" },
      { code: "mi", name: "Maori" },
      { code: "ml", name: "Malayalam" },
      { code: "cy", name: "Welsh" },
      { code: "sk", name: "Slovak" },
      { code: "te", name: "Telugu" },
      { code: "fa", name: "Persian" },
      { code: "lv", name: "Latvian" },
      { code: "bn", name: "Bengali" },
      { code: "sr", name: "Serbian" },
      { code: "az", name: "Azerbaijani" },
      { code: "sl", name: "Slovenian" },
      { code: "kn", name: "Kannada" },
      { code: "et", name: "Estonian" },
      { code: "mk", name: "Macedonian" },
      { code: "br", name: "Breton" },
      { code: "eu", name: "Basque" },
      { code: "is", name: "Icelandic" },
      { code: "hy", name: "Armenian" },
      { code: "ne", name: "Nepali" },
      { code: "mn", name: "Mongolian" },
      { code: "bs", name: "Bosnian" },
      { code: "kk", name: "Kazakh" },
      { code: "sq", name: "Albanian" },
      { code: "sw", name: "Swahili" },
      { code: "gl", name: "Galician" },
      { code: "mr", name: "Marathi" },
      { code: "pa", name: "Punjabi" },
      { code: "si", name: "Sinhala" },
      { code: "km", name: "Khmer" },
      { code: "sn", name: "Shona" },
      { code: "yo", name: "Yoruba" },
      { code: "so", name: "Somali" },
      { code: "af", name: "Afrikaans" },
      { code: "oc", name: "Occitan" },
      { code: "ka", name: "Georgian" },
      { code: "be", name: "Belarusian" },
      { code: "tg", name: "Tajik" },
      { code: "sd", name: "Sindhi" },
      { code: "gu", name: "Gujarati" },
      { code: "am", name: "Amharic" },
      { code: "yi", name: "Yiddish" },
      { code: "lo", name: "Lao" },
      { code: "uz", name: "Uzbek" },
      { code: "fo", name: "Faroese" },
      { code: "ht", name: "Haitian creole" },
      { code: "ps", name: "Pashto" },
      { code: "tk", name: "Turkmen" },
      { code: "nn", name: "Nynorsk" },
      { code: "mt", name: "Maltese" },
      { code: "sa", name: "Sanskrit" },
      { code: "lb", name: "Luxembourgish" },
      { code: "my", name: "Myanmar" },
      { code: "bo", name: "Tibetan" },
      { code: "tl", name: "Tagalog" },
      { code: "mg", name: "Malagasy" },
      { code: "as", name: "Assamese" },
      { code: "tt", name: "Tatar" },
      { code: "haw", name: "Hawaiian" },
      { code: "ln", name: "Lingala" },
      { code: "ha", name: "Hausa" },
      { code: "ba", name: "Bashkir" },
      { code: "jw", name: "Javanese" },
      { code: "su", name: "Sundanese" }
    ]
  });
});
app.get("/models", (c) => {
  return c.json({
    available_models: [
      {
        id: "@cf/openai/whisper",
        name: "Whisper",
        description: "General-purpose speech recognition model",
        languages: "Multilingual",
        max_duration: "30 minutes",
        pricing: "$0.00045 per audio minute"
      },
      {
        id: "@cf/openai/whisper-large-v3-turbo",
        name: "Whisper Large v3 Turbo",
        description: "Large model optimized for speed and accuracy",
        languages: "Multilingual",
        max_duration: "30 minutes",
        pricing: "$0.00045 per audio minute",
        recommended: true
      },
      {
        id: "@cf/openai/whisper-tiny-en",
        name: "Whisper Tiny (English)",
        description: "Small model for English-only transcription",
        languages: "English only",
        max_duration: "30 minutes",
        pricing: "$0.00045 per audio minute",
        beta: true
      }
    ]
  });
});
var whisper_default = app;

// src/routes/llm.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var app2 = new Hono2();
app2.use("/*", cors());
app2.post("/generate", async (c) => {
  try {
    const body = await c.req.json();
    const model = body.model || "@cf/meta/llama-3.3-70b-instruct-fp8-fast";
    let messages;
    if (body.messages) {
      messages = body.messages;
    } else if (body.prompt) {
      messages = [
        { role: "system", content: body.system || "You are a helpful assistant." },
        { role: "user", content: body.prompt }
      ];
    } else {
      return c.json({ error: "Either prompt or messages required" }, 400);
    }
    const ai = c.env.AI;
    if (body.stream) {
      const stream = await ai.run(model, {
        messages,
        stream: true,
        temperature: body.temperature || 0.7,
        max_tokens: body.max_tokens || 1e3
      });
      return new Response(stream, {
        headers: {
          "Content-Type": "text/event-stream",
          "Cache-Control": "no-cache",
          "Connection": "keep-alive"
        }
      });
    }
    const response = await ai.run(model, {
      messages,
      temperature: body.temperature || 0.7,
      max_tokens: body.max_tokens || 1e3
    });
    return successResponse(c, {
      response: response.response,
      usage: response.usage,
      model
    });
  } catch (error48) {
    console.error("LLM generation error:", error48);
    return c.json({ error: error48.message || "Text generation failed" }, 500);
  }
});
app2.post("/evaluate-english", async (c) => {
  try {
    const { text, context: context2 } = await c.req.json();
    if (!text) {
      return c.json({ error: "Text is required" }, 400);
    }
    const prompt = `You are an expert English language assessor. Evaluate the following English text for language proficiency.

${context2 ? `Context: ${context2}
` : ""}
Text to evaluate: "${text}"

Provide a detailed assessment with scores (0-100) for each of these 6 areas:
1. Grammar accuracy
2. Vocabulary range and appropriateness
3. Fluency and coherence
4. Pronunciation clarity (based on transcription quality if applicable)
5. Task achievement / Content relevance
6. Interaction skills / Communication effectiveness

Also determine the CEFR level (A1, A2, B1, B2, C1, or C2) based on the overall proficiency.

Response in JSON format with this structure:
{
  "scores": {
    "grammar": <0-100>,
    "vocabulary": <0-100>,
    "fluency": <0-100>,
    "pronunciation": <0-100>,
    "taskAchievement": <0-100>,
    "interaction": <0-100>
  },
  "averageScore": <0-100>,
  "cefrLevel": "<A1-C2>",
  "feedback": {
    "strengths": ["point 1", "point 2"],
    "improvements": ["point 1", "point 2"],
    "suggestions": ["suggestion 1", "suggestion 2"]
  },
  "detailedAnalysis": {
    "grammar": "Detailed grammar analysis...",
    "vocabulary": "Detailed vocabulary analysis...",
    "fluency": "Detailed fluency analysis...",
    "pronunciation": "Detailed pronunciation analysis...",
    "taskAchievement": "Detailed task achievement analysis...",
    "interaction": "Detailed interaction analysis..."
  }
}`;
    const ai = c.env.AI;
    const response = await ai.run("@cf/meta/llama-3.3-70b-instruct-fp8-fast", {
      messages: [
        {
          role: "system",
          content: "You are a professional English language assessment expert. Always respond with valid JSON."
        },
        { role: "user", content: prompt }
      ],
      temperature: 0.3,
      max_tokens: 2e3
    });
    try {
      const evaluation = JSON.parse(response.response);
      return successResponse(c, {
        evaluation,
        evaluatedText: text
      });
    } catch (parseError) {
      return successResponse(c, {
        evaluation: {
          textResponse: response.response,
          scores: {
            grammar: 70,
            vocabulary: 70,
            fluency: 70,
            pronunciation: 70,
            taskAchievement: 70,
            interaction: 70
          },
          averageScore: 70,
          cefrLevel: "B1"
        },
        evaluatedText: text
      });
    }
  } catch (error48) {
    console.error("English evaluation error:", error48);
    return c.json({ error: error48.message || "Evaluation failed" }, 500);
  }
});
app2.post("/check-grammar", async (c) => {
  try {
    const { text } = await c.req.json();
    if (!text) {
      return c.json({ error: "Text is required" }, 400);
    }
    const prompt = `Check the grammar of the following text and provide corrections:

Text: "${text}"

Provide a response in JSON format:
{
  "hasErrors": boolean,
  "correctedText": "the corrected version of the text",
  "errors": [
    {
      "type": "grammar/spelling/punctuation",
      "original": "original text",
      "correction": "corrected text",
      "explanation": "why this is wrong and how to fix it"
    }
  ],
  "suggestions": ["general writing improvement suggestions"]
}`;
    const ai = c.env.AI;
    const response = await ai.run("@cf/meta/llama-3.3-70b-instruct-fp8-fast", {
      messages: [
        {
          role: "system",
          content: "You are a grammar expert. Always respond with valid JSON."
        },
        { role: "user", content: prompt }
      ],
      temperature: 0.2,
      max_tokens: 1500
    });
    try {
      const result = JSON.parse(response.response);
      return successResponse(c, result);
    } catch (parseError) {
      return c.json({
        error: "Failed to parse grammar check response",
        rawResponse: response.response
      }, 400);
    }
  } catch (error48) {
    console.error("Grammar check error:", error48);
    return c.json({ error: error48.message || "Grammar check failed" }, 500);
  }
});
app2.post("/conversation-feedback", async (c) => {
  try {
    const { conversation, topic, level } = await c.req.json();
    if (!conversation || conversation.length === 0) {
      return c.json({ error: "Conversation is required" }, 400);
    }
    const conversationText = conversation.map((turn) => `${turn.speaker}: ${turn.text}`).join("\n");
    const prompt = `Analyze this English conversation and provide detailed feedback:

${topic ? `Topic: ${topic}` : ""}
${level ? `Expected Level: ${level}` : ""}

Conversation:
${conversationText}

Provide comprehensive feedback in JSON format:
{
  "overallAssessment": "general assessment of the conversation",
  "participantFeedback": {
    "<speaker_name>": {
      "strengths": ["strength 1", "strength 2"],
      "weaknesses": ["weakness 1", "weakness 2"],
      "languageUse": "assessment of grammar, vocabulary, fluency",
      "communicationSkills": "assessment of interaction, turn-taking, etc."
    }
  },
  "suggestions": {
    "vocabulary": ["useful words/phrases for this topic"],
    "expressions": ["natural expressions to use"],
    "grammar": ["grammar points to focus on"]
  },
  "nextSteps": ["recommendation 1", "recommendation 2"]
}`;
    const ai = c.env.AI;
    const response = await ai.run("@cf/meta/llama-3.3-70b-instruct-fp8-fast", {
      messages: [
        {
          role: "system",
          content: "You are an experienced English conversation coach. Always respond with valid JSON."
        },
        { role: "user", content: prompt }
      ],
      temperature: 0.4,
      max_tokens: 2e3
    });
    try {
      const feedback = JSON.parse(response.response);
      return successResponse(c, {
        feedback,
        conversationLength: conversation.length,
        topic,
        level
      });
    } catch (parseError) {
      return successResponse(c, {
        feedback: {
          textResponse: response.response
        },
        conversationLength: conversation.length,
        topic,
        level
      });
    }
  } catch (error48) {
    console.error("Conversation feedback error:", error48);
    return c.json({ error: error48.message || "Feedback generation failed" }, 500);
  }
});
app2.get("/models", (c) => {
  return successResponse(c, {
    available_models: [
      {
        id: "@cf/meta/llama-3.3-70b-instruct-fp8-fast",
        name: "Llama 3.3 70B Instruct",
        description: "Fast 70B parameter model optimized for instruction following",
        context_window: 24e3,
        recommended: true
      },
      {
        id: "@cf/meta/llama-3-8b-instruct",
        name: "Llama 3 8B Instruct",
        description: "Smaller, faster model for general tasks",
        context_window: 8192
      },
      {
        id: "@cf/microsoft/phi-2",
        name: "Phi-2",
        description: "Small but capable model from Microsoft",
        context_window: 2048
      },
      {
        id: "@cf/qwen/qwen1.5-14b-chat-awq",
        name: "Qwen 1.5 14B",
        description: "Multilingual model with strong performance",
        context_window: 32768
      }
    ],
    features: [
      "Text generation",
      "English evaluation",
      "Grammar checking",
      "Conversation feedback",
      "Streaming support"
    ]
  });
});
var llm_default = app2;

// src/routes/images.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var app3 = new Hono2();
app3.use("/*", cors());
app3.post("/upload", async (c) => {
  try {
    const formData = await c.req.formData();
    const file2 = formData.get("image");
    if (!file2) {
      return c.json({ error: "No image file provided" }, 400);
    }
    const userId = formData.get("userId");
    const type = formData.get("type") || "profile";
    if (!file2 || !userId) {
      return c.json({ error: "Image file and userId are required" }, 400);
    }
    const allowedTypes = ["image/jpeg", "image/png", "image/webp", "image/gif"];
    if (!allowedTypes.includes(file2.type)) {
      return c.json({ error: "Invalid file type. Only JPEG, PNG, WebP, and GIF are allowed" }, 400);
    }
    const maxSize = 10 * 1024 * 1024;
    if (file2.size > maxSize) {
      return c.json({ error: "File size exceeds 10MB limit" }, 400);
    }
    const timestamp = Date.now();
    const fileExt = file2.name.split(".").pop();
    const fileName = `${type}/${userId}/${timestamp}.${fileExt}`;
    const arrayBuffer = await file2.arrayBuffer();
    await c.env.STORAGE.put(fileName, arrayBuffer, {
      httpMetadata: {
        contentType: file2.type
      },
      customMetadata: {
        userId,
        type,
        originalName: file2.name,
        uploadedAt: (/* @__PURE__ */ new Date()).toISOString()
      }
    });
    const baseUrl = `https://${c.req.header("host")}`;
    const variants = {
      original: `${baseUrl}/api/v1/images/serve/${fileName}`,
      thumbnail: `${baseUrl}/api/v1/images/transform/${fileName}?width=150&height=150&fit=cover`,
      medium: `${baseUrl}/api/v1/images/transform/${fileName}?width=400&height=400&fit=contain`,
      large: `${baseUrl}/api/v1/images/transform/${fileName}?width=800&height=800&fit=contain`
    };
    await c.env.CACHE.put(
      `image:${fileName}`,
      JSON.stringify({
        fileName,
        userId,
        type,
        originalName: file2.name,
        size: file2.size,
        contentType: file2.type,
        uploadedAt: (/* @__PURE__ */ new Date()).toISOString(),
        variants
      }),
      { expirationTtl: 86400 * 30 }
      // 30 
    );
    return c.json({
      success: true,
      fileName,
      variants,
      size: file2.size,
      type: file2.type
    });
  } catch (error48) {
    console.error("Image upload error:", error48);
    return c.json({ error: error48.message || "Failed to upload image" }, 500);
  }
});
app3.get("/transform/*", async (c) => {
  try {
    const path = c.req.param("*");
    if (!path) {
      return c.json({ error: "Image path is required" }, 400);
    }
    const { searchParams } = new URL(c.req.url);
    const width = parseInt(searchParams.get("width") || "0");
    const height = parseInt(searchParams.get("height") || "0");
    const quality = parseInt(searchParams.get("quality") || "85");
    const fit = searchParams.get("fit") || "contain";
    const format = searchParams.get("format") || "auto";
    const object2 = await c.env.STORAGE.get(path);
    if (!object2) {
      return c.json({ error: "Image not found" }, 404);
    }
    const cacheKey = `transformed:${path}:w${width}:h${height}:q${quality}:${fit}:${format}`;
    const cached2 = await c.env.CACHE.get(cacheKey, { type: "arrayBuffer" });
    if (cached2) {
      return new Response(cached2, {
        headers: {
          "Content-Type": format === "auto" ? "image/webp" : `image/${format}`,
          "Cache-Control": "public, max-age=31536000",
          "X-Cache": "HIT"
        }
      });
    }
    const imageBuffer = await object2.arrayBuffer();
    let transformedBuffer = imageBuffer;
    let contentType = object2.httpMetadata?.contentType || "image/jpeg";
    if (format !== "auto" && format !== object2.httpMetadata?.contentType?.split("/")[1]) {
      contentType = `image/${format}`;
    } else if (format === "auto") {
      contentType = "image/webp";
    }
    return new Response(transformedBuffer, {
      headers: {
        "Content-Type": contentType,
        "Cache-Control": "public, max-age=31536000",
        "X-Cache": "HIT",
        "X-Image-Format": format || "original"
      }
    });
  } catch (error48) {
    console.error("Image transform error:", error48);
    return c.json({ error: error48.message || "Failed to transform image" }, 500);
  }
});
app3.get("/serve/*", async (c) => {
  try {
    const path = c.req.param("*");
    if (!path) {
      return c.json({ error: "Image path is required" }, 400);
    }
    const object2 = await c.env.STORAGE.get(path);
    if (!object2) {
      return c.json({ error: "Image not found" }, 404);
    }
    const headers = new Headers();
    object2.writeHttpMetadata(headers);
    headers.set("Cache-Control", "public, max-age=31536000");
    headers.set("Content-Security-Policy", "default-src 'none'; img-src 'self';");
    headers.set("X-Content-Type-Options", "nosniff");
    return new Response(object2.body, { headers });
  } catch (error48) {
    console.error("Image serve error:", error48);
    return c.json({ error: error48.message || "Failed to serve image" }, 500);
  }
});
app3.delete("/:fileName", async (c) => {
  try {
    const fileName = c.req.param("fileName");
    const userId = c.req.header("x-user-id");
    if (!fileName || !userId) {
      return c.json({ error: "fileName and userId are required" }, 400);
    }
    const metadata = await c.env.CACHE.get(`image:${fileName}`, { type: "json" });
    if (!metadata || metadata.userId !== userId) {
      return c.json({ error: "Unauthorized" }, 403);
    }
    await c.env.STORAGE.delete(fileName);
    await c.env.CACHE.delete(`image:${fileName}`);
    return c.json({
      success: true,
      message: "Image deleted successfully"
    });
  } catch (error48) {
    console.error("Image delete error:", error48);
    return c.json({ error: error48.message || "Failed to delete image" }, 500);
  }
});
app3.get("/list/:userId", async (c) => {
  try {
    const userId = c.req.param("userId");
    const type = c.req.query("type");
    if (!userId) {
      return c.json({ error: "userId is required" }, 400);
    }
    const prefix = type ? `${type}/${userId}/` : userId;
    const list = await c.env.STORAGE.list({ prefix, limit: 1e3 });
    const images = await Promise.all(
      list.objects.map(async (obj) => {
        const metadata = await c.env.CACHE.get(`image:${obj.key}`, { type: "json" });
        return {
          key: obj.key,
          size: obj.size,
          uploadedAt: obj.uploaded.toISOString(),
          metadata: metadata || {
            fileName: obj.key,
            contentType: obj.httpMetadata?.contentType
          }
        };
      })
    );
    return c.json({
      success: true,
      images,
      count: images.length
    });
  } catch (error48) {
    console.error("Image list error:", error48);
    return c.json({ error: error48.message || "Failed to list images" }, 500);
  }
});
app3.get("/info/:fileName", async (c) => {
  try {
    const fileName = c.req.param("fileName");
    if (!fileName) {
      return c.json({ error: "fileName is required" }, 400);
    }
    const metadata = await c.env.CACHE.get(`image:${fileName}`, { type: "json" });
    if (!metadata) {
      const object2 = await c.env.STORAGE.head(fileName);
      if (!object2) {
        return c.json({ error: "Image not found" }, 404);
      }
      return c.json({
        fileName,
        size: object2.size,
        uploadedAt: object2.uploaded.toISOString(),
        contentType: object2.httpMetadata?.contentType,
        customMetadata: object2.customMetadata
      });
    }
    return c.json(metadata);
  } catch (error48) {
    console.error("Image info error:", error48);
    return c.json({ error: error48.message || "Failed to get image info" }, 500);
  }
});
var images_default = app3;

// src/routes/transcribe.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/classic/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFile: () => ZodFile,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint3,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  codec: () => codec,
  coerce: () => coerce_exports,
  config: () => config2,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  decode: () => decode4,
  decodeAsync: () => decodeAsync2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  encode: () => encode2,
  encodeAsync: () => encodeAsync2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt2,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse3,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeEncode: () => safeEncode2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  util: () => util_exports,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCodec: () => $ZodCodec,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _check: () => _check,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _decode: () => _decode,
  _decodeAsync: () => _decodeAsync,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _encode: () => _encode,
  _encodeAsync: () => _encodeAsync,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeDecode: () => _safeDecode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeEncode: () => _safeEncode,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _superRefine: () => _superRefine,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  clone: () => clone,
  config: () => config2,
  decode: () => decode3,
  decodeAsync: () => decodeAsync,
  encode: () => encode,
  encodeAsync: () => encodeAsync,
  flattenError: () => flattenError,
  formatError: () => formatError,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  parse: () => parse2,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version2
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/core.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var NEVER = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    var _a;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name);
    initializer3(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  __name(init, "init");
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
    static {
      __name(this, "Definition");
    }
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  __name(_, "_");
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: /* @__PURE__ */ __name((inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }, "value")
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
__name($constructor, "$constructor");
var $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  static {
    __name(this, "$ZodAsyncError");
  }
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var $ZodEncodeError = class extends Error {
  static {
    __name(this, "$ZodEncodeError");
  }
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
};
var globalConfig = {};
function config2(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
__name(config2, "config");

// node_modules/zod/v4/core/parse.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/errors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert3,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function assertEqual(val) {
  return val;
}
__name(assertEqual, "assertEqual");
function assertNotEqual(val) {
  return val;
}
__name(assertNotEqual, "assertNotEqual");
function assertIs(_arg) {
}
__name(assertIs, "assertIs");
function assertNever(_x) {
  throw new Error();
}
__name(assertNever, "assertNever");
function assert3(_) {
}
__name(assert3, "assert");
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
__name(getEnumValues, "getEnumValues");
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
__name(joinValues, "joinValues");
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
__name(jsonStringifyReplacer, "jsonStringifyReplacer");
function cached(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
__name(cached, "cached");
function nullish(input) {
  return input === null || input === void 0;
}
__name(nullish, "nullish");
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
__name(cleanRegex, "cleanRegex");
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
__name(floatSafeRemainder, "floatSafeRemainder");
var EVALUATING = Symbol("evaluating");
function defineLazy(object2, key, getter) {
  let value = void 0;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
__name(defineLazy, "defineLazy");
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
__name(objectClone, "objectClone");
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
__name(assignProp, "assignProp");
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
__name(mergeDefs, "mergeDefs");
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
__name(cloneDef, "cloneDef");
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
__name(getElementAtPath, "getElementAtPath");
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
__name(promiseAllObject, "promiseAllObject");
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
__name(randomString, "randomString");
function esc(str) {
  return JSON.stringify(str);
}
__name(esc, "esc");
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
__name(isObject, "isObject");
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && "Cloudflare-Workers"?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
__name(isPlainObject, "isPlainObject");
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
__name(shallowClone, "shallowClone");
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
__name(numKeys, "numKeys");
var getParsedType = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
}, "getParsedType");
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
__name(escapeRegex, "escapeRegex");
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
__name(clone, "clone");
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: /* @__PURE__ */ __name(() => params, "error") };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: /* @__PURE__ */ __name(() => params.error, "error") };
  return params;
}
__name(normalizeParams, "normalizeParams");
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
__name(createTransparentProxy, "createTransparentProxy");
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
__name(stringifyPrimitive, "stringifyPrimitive");
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
__name(optionalKeys, "optionalKeys");
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
__name(pick, "pick");
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
__name(omit, "omit");
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone(schema, def);
}
__name(extend, "extend");
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: schema._zod.def.checks
  };
  return clone(schema, def);
}
__name(safeExtend, "safeExtend");
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
__name(merge, "merge");
function partial(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
__name(partial, "partial");
function required(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
__name(required, "required");
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
__name(aborted, "aborted");
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a;
    (_a = iss).path ?? (_a.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
__name(prefixIssues, "prefixIssues");
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
__name(unwrapMessage, "unwrapMessage");
function finalizeIssue(iss, ctx, config3) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config3.customError?.(iss)) ?? unwrapMessage(config3.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
__name(finalizeIssue, "finalizeIssue");
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
__name(getSizableOrigin, "getSizableOrigin");
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
__name(getLengthableOrigin, "getLengthableOrigin");
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
__name(issue, "issue");
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
__name(cleanEnum, "cleanEnum");
function base64ToUint8Array(base643) {
  const binaryString = atob(base643);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
__name(base64ToUint8Array, "base64ToUint8Array");
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
__name(uint8ArrayToBase64, "uint8ArrayToBase64");
function base64urlToUint8Array(base64url3) {
  const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array(base643 + padding);
}
__name(base64urlToUint8Array, "base64urlToUint8Array");
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
__name(uint8ArrayToBase64url, "uint8ArrayToBase64url");
function hexToUint8Array(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
__name(hexToUint8Array, "hexToUint8Array");
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
__name(uint8ArrayToHex, "uint8ArrayToHex");
var Class = class {
  static {
    __name(this, "Class");
  }
  constructor(..._args) {
  }
};

// node_modules/zod/v4/core/errors.js
var initializer = /* @__PURE__ */ __name((inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: /* @__PURE__ */ __name(() => inst.message, "value"),
    enumerable: false
  });
}, "initializer");
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error48, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error48.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
__name(flattenError, "flattenError");
function formatError(error48, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = /* @__PURE__ */ __name((error49) => {
    for (const issue2 of error49.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  }, "processError");
  processError(error48);
  return fieldErrors;
}
__name(formatError, "formatError");
function treeifyError(error48, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = /* @__PURE__ */ __name((error49, path = []) => {
    var _a, _b;
    for (const issue2 of error49.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  }, "processError");
  processError(error48);
  return result;
}
__name(treeifyError, "treeifyError");
function toDotPath(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
__name(toDotPath, "toDotPath");
function prettifyError(error48) {
  const lines = [];
  const issues = [...error48.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}
__name(prettifyError, "prettifyError");

// node_modules/zod/v4/core/parse.js
var _parse = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config2())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
}, "_parse");
var parse2 = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config2())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
}, "_parseAsync");
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config2())))
  } : { success: true, data: result.value };
}, "_safeParse");
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config2())))
  } : { success: true, data: result.value };
}, "_safeParseAsync");
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
var _encode = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
}, "_encode");
var encode = /* @__PURE__ */ _encode($ZodRealError);
var _decode = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
}, "_decode");
var decode3 = /* @__PURE__ */ _decode($ZodRealError);
var _encodeAsync = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
}, "_encodeAsync");
var encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
var _decodeAsync = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
}, "_decodeAsync");
var decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
var _safeEncode = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
}, "_safeEncode");
var safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
var _safeDecode = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
}, "_safeDecode");
var safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
var _safeEncodeAsync = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
}, "_safeEncodeAsync");
var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
var _safeDecodeAsync = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
}, "_safeDecodeAsync");
var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);

// node_modules/zod/v4/core/schemas.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/checks.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint2,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain2,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time3,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = /* @__PURE__ */ __name((version3) => {
  if (!version3)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version3}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
}, "uuid");
var uuid4 = /* @__PURE__ */ uuid(4);
var uuid6 = /* @__PURE__ */ uuid(6);
var uuid7 = /* @__PURE__ */ uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail = unicodeEmail;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
__name(emoji, "emoji");
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain2 = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
__name(timeSource, "timeSource");
function time3(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
__name(time3, "time");
function datetime(args) {
  const time5 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time5}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
__name(datetime, "datetime");
var string = /* @__PURE__ */ __name((params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
}, "string");
var bigint2 = /^-?\d+n?$/;
var integer = /^-?\d+$/;
var number = /^-?\d+(?:\.\d+)?/;
var boolean = /^(?:true|false)$/i;
var _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
__name(fixedBase64, "fixedBase64");
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
__name(fixedBase64url, "fixedBase64url");
var md5_hex = /^[0-9a-fA-F]{32}$/;
var md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
var md5_base64url = /* @__PURE__ */ fixedBase64url(22);
var sha1_hex = /^[0-9a-fA-F]{40}$/;
var sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
var sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
var sha256_hex = /^[0-9a-fA-F]{64}$/;
var sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
var sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
var sha384_hex = /^[0-9a-fA-F]{96}$/;
var sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
var sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
var sha512_hex = /^[0-9a-fA-F]{128}$/;
var sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
var sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a = inst._zod).onattach ?? (_a.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a;
    (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a = inst._zod).check ?? (_a.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
__name(handleCheckPropertyResult, "handleCheckPropertyResult");
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Doc = class {
  static {
    __name(this, "Doc");
  }
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/zod/v4/core/versions.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var version2 = {
  major: 4,
  minor: 1,
  patch: 12
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version2;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = /* @__PURE__ */ __name((payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    }, "runChecks");
    const handleCanaryResult = /* @__PURE__ */ __name((canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    }, "handleCanaryResult");
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: /* @__PURE__ */ __name((value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    }, "validate"),
    vendor: "zod",
    version: 1
  };
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url2 = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url2.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time3(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
__name(isValidBase64, "isValidBase64");
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
__name(isValidBase64URL, "isValidBase64URL");
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
__name(isValidJWT, "isValidJWT");
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint2;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
__name(handleArrayResult, "handleArrayResult");
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
__name(handlePropertyResult, "handlePropertyResult");
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
__name(normalizeDef, "normalizeDef");
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  for (const key of Object.keys(input)) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
    } else {
      handlePropertyResult(r, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
__name(handleCatchall, "handleCatchall");
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: /* @__PURE__ */ __name(() => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }, "get")
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject2 = isObject;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
      } else {
        handlePropertyResult(r, payload, key, input);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = /* @__PURE__ */ __name((shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = /* @__PURE__ */ __name((key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    }, "parseStr");
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc(key);
      doc.write(`const ${id} = ${parseStr(key)};`);
      doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  }, "generateFastpass");
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config2())))
  });
  return final;
}
__name(handleUnionResults, "handleUnionResults");
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map2 = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map2.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map2.set(v, o);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
__name(mergeValues, "mergeValues");
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
__name(handleIntersectionResults, "handleIntersectionResults");
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
__name(handleTupleResult, "handleTupleResult");
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config2())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config2()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config2()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
__name(handleMapResult, "handleMapResult");
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
__name(handleSetResult, "handleSetResult");
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
__name(handleOptionalResult, "handleOptionalResult");
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
__name(handleDefaultResult, "handleDefaultResult");
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
__name(handleNonOptionalResult, "handleNonOptionalResult");
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config2()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config2()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
__name(handlePipeResult, "handlePipeResult");
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      }
      return handleCodecAResult(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      }
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
__name(handleCodecAResult, "handleCodecAResult");
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
__name(handleCodecTxResult, "handleCodecTxResult");
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
__name(handleReadonlyResult, "handleReadonlyResult");
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
  $ZodType.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse2(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse2(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? void 0);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? void 0);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
__name(handleRefineResult, "handleRefineResult");

// node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  bg: () => bg_default,
  ca: () => ca_default,
  cs: () => cs_default,
  da: () => da_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  id: () => id_default,
  is: () => is_default,
  it: () => it_default,
  ja: () => ja_default,
  ka: () => ka_default,
  kh: () => kh_default,
  km: () => km_default,
  ko: () => ko_default,
  lt: () => lt_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  uk: () => uk_default,
  ur: () => ur_default,
  vi: () => vi_default,
  yo: () => yo_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/locales/ar.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error3 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
}, "error");
function ar_default() {
  return {
    localeError: error3()
  };
}
__name(ar_default, "default");

// node_modules/zod/v4/locales/az.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error4 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue2.expected}, daxil olan ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
}, "error");
function az_default() {
  return {
    localeError: error4()
  };
}
__name(az_default, "default");

// node_modules/zod/v4/locales/be.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getBelarusianPlural(count3, one, few, many) {
  const absCount = Math.abs(count3);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
__name(getBelarusianPlural, "getBelarusianPlural");
var error5 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0456\u045E";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
}, "error");
function be_default() {
  return {
    localeError: error5()
  };
}
__name(be_default, "default");

// node_modules/zod/v4/locales/bg.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parsedType = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "\u043C\u0430\u0441\u0438\u0432";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
}, "parsedType");
var error6 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const Nouns = {
    regex: "\u0432\u0445\u043E\u0434",
    email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    json_string: "JSON \u043D\u0438\u0437",
    e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
        let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
        if (_issue.format === "emoji")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "datetime")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "date")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        if (_issue.format === "time")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "duration")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        return `${invalid_adj} ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
    }
  };
}, "error");
function bg_default() {
  return {
    localeError: error6()
  };
}
__name(bg_default, "default");

// node_modules/zod/v4/locales/ca.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error7 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipus inv\xE0lid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType8(issue2.input)}`;
      // return `Tipus invlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
      case "invalid_element":
        return `Element inv\xE0lid a ${issue2.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
}, "error");
function ca_default() {
  return {
    localeError: error7()
  };
}
__name(ca_default, "default");

// node_modules/zod/v4/locales/cs.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error8 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
      }
      case "string": {
        return "\u0159et\u011Bzec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue2.expected}, obdr\u017Eeno ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue2.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
}, "error");
function cs_default() {
  return {
    localeError: error8()
  };
}
__name(cs_default, "default");

// node_modules/zod/v4/locales/da.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error9 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  const TypeNames = {
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "s\xE6t",
    file: "fil"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  __name(getTypeName, "getTypeName");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
        return "objekt";
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkesl\xE6t",
    date: "ISO-dato",
    time: "ISO-klokkesl\xE6t",
    duration: "ISO-varighed",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${getTypeName(issue2.expected)}, fik ${getTypeName(parsedType8(issue2.input))}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8gle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig v\xE6rdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
}, "error");
function da_default() {
  return {
    localeError: error9()
  };
}
__name(da_default, "default");

// node_modules/zod/v4/locales/de.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error10 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ung\xFCltige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue2.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
}, "error");
function de_default() {
  return {
    localeError: error10()
  };
}
__name(de_default, "default");

// node_modules/zod/v4/locales/en.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parsedType2 = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
}, "parsedType");
var error11 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
}, "error");
function en_default() {
  return {
    localeError: error11()
  };
}
__name(en_default, "default");

// node_modules/zod/v4/locales/eo.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parsedType3 = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
}, "parsedType");
var error12 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nevalida enigo: atendi\u011Dis ${issue2.expected}, ricevi\u011Dis ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
}, "error");
function eo_default() {
  return {
    localeError: error12()
  };
}
__name(eo_default, "default");

// node_modules/zod/v4/locales/es.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error13 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  const TypeNames = {
    string: "texto",
    number: "n\xFAmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "n\xFAmero grande",
    symbol: "s\xEDmbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funci\xF3n",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeraci\xF3n",
    union: "uni\xF3n",
    literal: "literal",
    promise: "promesa",
    void: "vac\xEDo",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  __name(getTypeName, "getTypeName");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
        return "object";
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrada inv\xE1lida: se esperaba ${getTypeName(issue2.expected)}, recibido ${getTypeName(parsedType8(issue2.input))}`;
      // return `Entrada invlida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${getTypeName(issue2.origin)}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${getTypeName(issue2.origin)}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
}, "error");
function es_default() {
  return {
    localeError: error13()
  };
}
__name(es_default, "default");

// node_modules/zod/v4/locales/fa.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error14 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u0627\u06CC\u0647";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType8(issue2.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
}, "error");
function fa_default() {
  return {
    localeError: error14()
  };
}
__name(fa_default, "default");

// node_modules/zod/v4/locales/fi.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error15 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
}, "error");
function fi_default() {
  return {
    localeError: error15()
  };
}
__name(fi_default, "default");

// node_modules/zod/v4/locales/fr.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error16 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : ${issue2.expected} attendu, ${parsedType8(issue2.input)} re\xE7u`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
}, "error");
function fr_default() {
  return {
    localeError: error16()
  };
}
__name(fr_default, "default");

// node_modules/zod/v4/locales/fr-CA.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error17 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : attendu ${issue2.expected}, re\xE7u ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
}, "error");
function fr_CA_default() {
  return {
    localeError: error17()
  };
}
__name(fr_CA_default, "default");

// node_modules/zod/v4/locales/he.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error18 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "\u05E7\u05DC\u05D8",
    email: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
    url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
    emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
    date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
    time: "\u05D6\u05DE\u05DF ISO",
    duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
    ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
    ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
    cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
    cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
    base64: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
    base64url: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
    json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
    e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
    jwt: "JWT",
    template_literal: "\u05E7\u05DC\u05D8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${parsedType8(issue2.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element":
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
}, "error");
function he_default() {
  return {
    localeError: error18()
  };
}
__name(he_default, "default");

// node_modules/zod/v4/locales/hu.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error19 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "sz\xE1m";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "t\xF6mb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue2.expected}, a kapott \xE9rt\xE9k ${parsedType8(issue2.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
}, "error");
function hu_default() {
  return {
    localeError: error19()
  };
}
__name(hu_default, "default");

// node_modules/zod/v4/locales/id.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error20 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
}, "error");
function id_default() {
  return {
    localeError: error20()
  };
}
__name(id_default, "default");

// node_modules/zod/v4/locales/is.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parsedType4 = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "n\xFAmer";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "fylki";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
}, "parsedType");
var error21 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "stafi", verb: "a\xF0 hafa" },
    file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
    array: { unit: "hluti", verb: "a\xF0 hafa" },
    set: { unit: "hluti", verb: "a\xF0 hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const Nouns = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl\xF3\xF0",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og t\xEDmi",
    date: "ISO dagsetning",
    time: "ISO t\xEDmi",
    duration: "ISO t\xEDmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 t\xF6lugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Rangt gildi: \xDE\xFA sl\xF3st inn ${parsedType4(issue2.input)} \xFEar sem \xE1 a\xF0 vera ${issue2.expected}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill \xED ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi \xED ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
}, "error");
function is_default() {
  return {
    localeError: error21()
  };
}
__name(is_default, "default");

// node_modules/zod/v4/locales/it.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error22 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType8(issue2.input)}`;
      // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
}, "error");
function it_default() {
  return {
    localeError: error22()
  };
}
__name(it_default, "default");

// node_modules/zod/v4/locales/ja.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error23 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u914D\u5217";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u7121\u52B9\u306A\u5165\u529B: ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType8(issue2.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
}, "error");
function ja_default() {
  return {
    localeError: error23()
  };
}
__name(ja_default, "default");

// node_modules/zod/v4/locales/ka.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parsedType5 = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  const typeMap = {
    string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
    undefined: "undefined",
    bigint: "bigint",
    symbol: "symbol",
    function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0"
  };
  return typeMap[t] ?? t;
}, "parsedType");
var error24 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const Nouns = {
    regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
    email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    url: "URL",
    emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
    date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
    time: "\u10D3\u10E0\u10DD",
    duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
    ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
    jwt: "JWT",
    template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${parsedType5(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
        }
        if (_issue.format === "ends_with")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
        if (_issue.format === "includes")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
        if (_issue.format === "regex")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
      case "unrecognized_keys":
        return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
      case "invalid_union":
        return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
      case "invalid_element":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
      default:
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
    }
  };
}, "error");
function ka_default() {
  return {
    localeError: error24()
  };
}
__name(ka_default, "default");

// node_modules/zod/v4/locales/kh.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/locales/km.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error25 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u17A2\u17B6\u179A\u17C1 (Array)";
        }
        if (data === null) {
          return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
}, "error");
function km_default() {
  return {
    localeError: error25()
  };
}
__name(km_default, "default");

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}
__name(kh_default, "default");

// node_modules/zod/v4/locales/ko.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error26 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType8(issue2.input)}\uC785\uB2C8\uB2E4`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
}, "error");
function ko_default() {
  return {
    localeError: error26()
  };
}
__name(ko_default, "default");

// node_modules/zod/v4/locales/lt.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parsedType6 = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  return parsedTypeFromType(t, data);
}, "parsedType");
var parsedTypeFromType = /* @__PURE__ */ __name((t, data = void 0) => {
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "skai\u010Dius";
    }
    case "bigint": {
      return "sveikasis skai\u010Dius";
    }
    case "string": {
      return "eilut\u0117";
    }
    case "boolean": {
      return "login\u0117 reik\u0161m\u0117";
    }
    case "undefined":
    case "void": {
      return "neapibr\u0117\u017Eta reik\u0161m\u0117";
    }
    case "function": {
      return "funkcija";
    }
    case "symbol": {
      return "simbolis";
    }
    case "object": {
      if (data === void 0)
        return "ne\u017Einomas objektas";
      if (data === null)
        return "nulin\u0117 reik\u0161m\u0117";
      if (Array.isArray(data))
        return "masyvas";
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
      return "objektas";
    }
    //Zod types below
    case "null": {
      return "nulin\u0117 reik\u0161m\u0117";
    }
  }
  return t;
}, "parsedTypeFromType");
var capitalizeFirstCharacter = /* @__PURE__ */ __name((text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
}, "capitalizeFirstCharacter");
function getUnitTypeFromNumber(number4) {
  const abs = Math.abs(number4);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
__name(getUnitTypeFromNumber, "getUnitTypeFromNumber");
var error27 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
          notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
          notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne didesnis kaip",
          notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
          notInclusive: "turi b\u016Bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  __name(getSizing, "getSizing");
  const Nouns = {
    regex: "\u012Fvestis",
    email: "el. pa\u0161to adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm\u0117",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 u\u017Ekoduota eilut\u0117",
    base64url: "base64url u\u017Ekoduota eilut\u0117",
    json_string: "JSON eilut\u0117",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "\u012Fvestis"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Gautas tipas ${parsedType6(issue2.input)}, o tik\u0117tasi - ${parsedTypeFromType(issue2.expected)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
      case "too_big": {
        const origin = parsedTypeFromType(issue2.origin);
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = parsedTypeFromType(issue2.origin);
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga \u012Fvestis";
      case "invalid_element": {
        const origin = parsedTypeFromType(issue2.origin);
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
      }
      default:
        return "Klaidinga \u012Fvestis";
    }
  };
}, "error");
function lt_default() {
  return {
    localeError: error27()
  };
}
__name(lt_default, "default");

// node_modules/zod/v4/locales/mk.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error28 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043D\u0438\u0437\u0430";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType8(issue2.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
}, "error");
function mk_default() {
  return {
    localeError: error28()
  };
}
__name(mk_default, "default");

// node_modules/zod/v4/locales/ms.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error29 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
}, "error");
function ms_default() {
  return {
    localeError: error29()
  };
}
__name(ms_default, "default");

// node_modules/zod/v4/locales/nl.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error30 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
}, "error");
function nl_default() {
  return {
    localeError: error30()
  };
}
__name(nl_default, "default");

// node_modules/zod/v4/locales/no.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error31 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
}, "error");
function no_default() {
  return {
    localeError: error31()
  };
}
__name(no_default, "default");

// node_modules/zod/v4/locales/ota.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error32 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `F\xE2sit giren: umulan ${issue2.expected}, al\u0131nan ${parsedType8(issue2.input)}`;
      // return `Fsit giren: umulan ${issue.expected}, alnan ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
}, "error");
function ota_default() {
  return {
    localeError: error32()
  };
}
__name(ota_default, "default");

// node_modules/zod/v4/locales/ps.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error33 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0627\u0631\u06D0";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType8(issue2.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
}, "error");
function ps_default() {
  return {
    localeError: error33()
  };
}
__name(ps_default, "default");

// node_modules/zod/v4/locales/pl.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error34 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
}, "error");
function pl_default() {
  return {
    localeError: error34()
  };
}
__name(pl_default, "default");

// node_modules/zod/v4/locales/pt.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error35 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\xFAmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipo inv\xE1lido: esperado ${issue2.expected}, recebido ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue2.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
}, "error");
function pt_default() {
  return {
    localeError: error35()
  };
}
__name(pt_default, "default");

// node_modules/zod/v4/locales/ru.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getRussianPlural(count3, one, few, many) {
  const absCount = Math.abs(count3);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
__name(getRussianPlural, "getRussianPlural");
var error36 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
}, "error");
function ru_default() {
  return {
    localeError: error36()
  };
}
__name(ru_default, "default");

// node_modules/zod/v4/locales/sl.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error37 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neveljaven vnos: pri\u010Dakovano ${issue2.expected}, prejeto ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
}, "error");
function sl_default() {
  return {
    localeError: error37()
  };
}
__name(sl_default, "default");

// node_modules/zod/v4/locales/sv.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error38 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue2.expected}, fick ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
}, "error");
function sv_default() {
  return {
    localeError: error38()
  };
}
__name(sv_default, "default");

// node_modules/zod/v4/locales/ta.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error39 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0B85\u0BA3\u0BBF";
        }
        if (data === null) {
          return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
}, "error");
function ta_default() {
  return {
    localeError: error39()
  };
}
__name(ta_default, "default");

// node_modules/zod/v4/locales/th.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error40 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
        }
        if (data === null) {
          return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
}, "error");
function th_default() {
  return {
    localeError: error40()
  };
}
__name(th_default, "default");

// node_modules/zod/v4/locales/tr.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parsedType7 = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
}, "parsedType");
var error41 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ge\xE7ersiz de\u011Fer: beklenen ${issue2.expected}, al\u0131nan ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
}, "error");
function tr_default() {
  return {
    localeError: error41()
  };
}
__name(tr_default, "default");

// node_modules/zod/v4/locales/ua.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/locales/uk.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error42 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType8(issue2.input)}`;
      // return `  :  ${issue.expected},  ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
}, "error");
function uk_default() {
  return {
    localeError: error42()
  };
}
__name(uk_default, "default");

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}
__name(ua_default, "default");

// node_modules/zod/v4/locales/ur.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error43 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u06D2";
        }
        if (data === null) {
          return "\u0646\u0644";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType8(issue2.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
}, "error");
function ur_default() {
  return {
    localeError: error43()
  };
}
__name(ur_default, "default");

// node_modules/zod/v4/locales/vi.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error44 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "s\u1ED1";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "m\u1EA3ng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
}, "error");
function vi_default() {
  return {
    localeError: error44()
  };
}
__name(vi_default, "default");

// node_modules/zod/v4/locales/zh-CN.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error45 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u6570\u7EC4";
        }
        if (data === null) {
          return "\u7A7A\u503C(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
}, "error");
function zh_CN_default() {
  return {
    localeError: error45()
  };
}
__name(zh_CN_default, "default");

// node_modules/zod/v4/locales/zh-TW.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error46 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
}, "error");
function zh_TW_default() {
  return {
    localeError: error46()
  };
}
__name(zh_TW_default, "default");

// node_modules/zod/v4/locales/yo.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error47 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\xE0mi", verb: "n\xED" },
    file: { unit: "bytes", verb: "n\xED" },
    array: { unit: "nkan", verb: "n\xED" },
    set: { unit: "nkan", verb: "n\xED" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType8 = /* @__PURE__ */ __name((data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\u1ECD\u0301mb\xE0";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "akop\u1ECD";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  }, "parsedType");
  const Nouns = {
    regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
    email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\xE0k\xF3k\xF2 ISO",
    date: "\u1ECDj\u1ECD\u0301 ISO",
    time: "\xE0k\xF3k\xF2 ISO",
    duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
    ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
    ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
    cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
    cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
    base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
    base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
    json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
    e164: "n\u1ECD\u0301mb\xE0 E.164",
    jwt: "JWT",
    template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
        return `A\u1E63\xEC\u1E63e: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      case "invalid_union":
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      case "invalid_element":
        return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      default:
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
    }
  };
}, "error");
function yo_default() {
  return {
    localeError: error47()
  };
}
__name(yo_default, "default");

// node_modules/zod/v4/core/registries.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");
var $ZodRegistry = class {
  static {
    __name(this, "$ZodRegistry");
  }
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
__name(registry, "registry");
var globalRegistry = /* @__PURE__ */ registry();

// node_modules/zod/v4/core/api.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
__name(_string, "_string");
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
__name(_coercedString, "_coercedString");
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_email, "_email");
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_guid, "_guid");
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_uuid, "_uuid");
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
__name(_uuidv4, "_uuidv4");
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
__name(_uuidv6, "_uuidv6");
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
__name(_uuidv7, "_uuidv7");
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_url, "_url");
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_emoji2, "_emoji");
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_nanoid, "_nanoid");
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_cuid, "_cuid");
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_cuid2, "_cuid2");
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_ulid, "_ulid");
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_xid, "_xid");
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_ksuid, "_ksuid");
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_ipv4, "_ipv4");
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_ipv6, "_ipv6");
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_cidrv4, "_cidrv4");
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_cidrv6, "_cidrv6");
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_base64, "_base64");
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_base64url, "_base64url");
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_e164, "_e164");
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_jwt, "_jwt");
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
__name(_isoDateTime, "_isoDateTime");
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
__name(_isoDate, "_isoDate");
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
__name(_isoTime, "_isoTime");
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
__name(_isoDuration, "_isoDuration");
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
__name(_number, "_number");
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
__name(_coercedNumber, "_coercedNumber");
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
__name(_int, "_int");
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
__name(_float32, "_float32");
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
__name(_float64, "_float64");
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
__name(_int32, "_int32");
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
__name(_uint32, "_uint32");
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
__name(_boolean, "_boolean");
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
__name(_coercedBoolean, "_coercedBoolean");
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
__name(_bigint, "_bigint");
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
__name(_coercedBigint, "_coercedBigint");
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
__name(_int64, "_int64");
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
__name(_uint64, "_uint64");
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
__name(_symbol, "_symbol");
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
__name(_undefined2, "_undefined");
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
__name(_null2, "_null");
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
__name(_any, "_any");
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
__name(_unknown, "_unknown");
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
__name(_never, "_never");
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
__name(_void, "_void");
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
__name(_date, "_date");
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
__name(_coercedDate, "_coercedDate");
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
__name(_nan, "_nan");
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
__name(_lt, "_lt");
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
__name(_lte, "_lte");
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
__name(_gt, "_gt");
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
__name(_gte, "_gte");
function _positive(params) {
  return _gt(0, params);
}
__name(_positive, "_positive");
function _negative(params) {
  return _lt(0, params);
}
__name(_negative, "_negative");
function _nonpositive(params) {
  return _lte(0, params);
}
__name(_nonpositive, "_nonpositive");
function _nonnegative(params) {
  return _gte(0, params);
}
__name(_nonnegative, "_nonnegative");
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
__name(_multipleOf, "_multipleOf");
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
__name(_maxSize, "_maxSize");
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
__name(_minSize, "_minSize");
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
__name(_size, "_size");
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
__name(_maxLength, "_maxLength");
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
__name(_minLength, "_minLength");
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
__name(_length, "_length");
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
__name(_regex, "_regex");
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
__name(_lowercase, "_lowercase");
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
__name(_uppercase, "_uppercase");
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
__name(_includes, "_includes");
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
__name(_startsWith, "_startsWith");
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
__name(_endsWith, "_endsWith");
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
__name(_property, "_property");
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
__name(_mime, "_mime");
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
__name(_overwrite, "_overwrite");
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
__name(_normalize, "_normalize");
function _trim() {
  return _overwrite((input) => input.trim());
}
__name(_trim, "_trim");
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
__name(_toLowerCase, "_toLowerCase");
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
__name(_toUpperCase, "_toUpperCase");
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
__name(_array, "_array");
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
__name(_union, "_union");
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
__name(_discriminatedUnion, "_discriminatedUnion");
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
__name(_intersection, "_intersection");
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
__name(_tuple, "_tuple");
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
__name(_record, "_record");
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
__name(_map, "_map");
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
__name(_set, "_set");
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
__name(_enum, "_enum");
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
__name(_nativeEnum, "_nativeEnum");
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
__name(_literal, "_literal");
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
__name(_file, "_file");
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
__name(_transform, "_transform");
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
__name(_optional, "_optional");
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
__name(_nullable, "_nullable");
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
__name(_default, "_default");
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
__name(_nonoptional, "_nonoptional");
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
__name(_success, "_success");
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
__name(_catch, "_catch");
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
__name(_pipe, "_pipe");
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
__name(_readonly, "_readonly");
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
__name(_templateLiteral, "_templateLiteral");
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
__name(_lazy, "_lazy");
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
__name(_promise, "_promise");
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
__name(_custom, "_custom");
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
__name(_refine, "_refine");
function _superRefine(fn) {
  const ch = _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
__name(_superRefine, "_superRefine");
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
__name(_check, "_check");
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: /* @__PURE__ */ __name((input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    }, "transform"),
    reverseTransform: /* @__PURE__ */ __name((input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    }, "reverseTransform"),
    error: params.error
  });
  return codec2;
}
__name(_stringbool, "_stringbool");
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}
__name(_stringFormat, "_stringFormat");

// node_modules/zod/v4/core/to-json-schema.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var JSONSchemaGenerator = class {
  static {
    __name(this, "JSONSchemaGenerator");
  }
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {
    });
    this.io = params?.io ?? "output";
    this.seen = /* @__PURE__ */ new Map();
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json2 = _json;
            json2.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minLength = minimum;
            if (typeof maximum === "number")
              json2.maxLength = maximum;
            if (format) {
              json2.format = formatMap[format] ?? format;
              if (json2.format === "")
                delete json2.format;
            }
            if (contentEncoding)
              json2.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json2.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json2 = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json2.type = "integer";
            else
              json2.type = "number";
            if (typeof exclusiveMinimum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.minimum = exclusiveMinimum;
                json2.exclusiveMinimum = true;
              } else {
                json2.exclusiveMinimum = exclusiveMinimum;
              }
            }
            if (typeof minimum === "number") {
              json2.minimum = minimum;
              if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                if (exclusiveMinimum >= minimum)
                  delete json2.minimum;
                else
                  delete json2.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.maximum = exclusiveMaximum;
                json2.exclusiveMaximum = true;
              } else {
                json2.exclusiveMaximum = exclusiveMaximum;
              }
            }
            if (typeof maximum === "number") {
              json2.maximum = maximum;
              if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                if (exclusiveMaximum <= maximum)
                  delete json2.maximum;
                else
                  delete json2.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json2.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            if (this.target === "openapi-3.0") {
              _json.type = "string";
              _json.nullable = true;
              _json.enum = [null];
            } else
              _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json2 = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minItems = minimum;
            if (typeof maximum === "number")
              json2.maxItems = maximum;
            json2.type = "array";
            json2.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json2 = _json;
            json2.type = "object";
            json2.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json2.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === void 0;
              } else {
                return v.optout === void 0;
              }
            }));
            if (requiredKeys.size > 0) {
              json2.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json2.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json2.additionalProperties = false;
            } else if (def.catchall) {
              json2.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json2 = _json;
            const options = def.options.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, "anyOf", i]
            }));
            json2.anyOf = options;
            break;
          }
          case "intersection": {
            const json2 = _json;
            const a = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = /* @__PURE__ */ __name((val) => "allOf" in val && Object.keys(val).length === 1, "isSimpleIntersection");
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [a],
              ...isSimpleIntersection(b) ? b.allOf : [b]
            ];
            json2.allOf = allOf;
            break;
          }
          case "tuple": {
            const json2 = _json;
            json2.type = "array";
            const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
            const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
            const prefixItems = def.items.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, prefixPath, i]
            }));
            const rest = def.rest ? this.process(def.rest, {
              ...params,
              path: [...params.path, restPath, ...this.target === "openapi-3.0" ? [def.items.length] : []]
            }) : null;
            if (this.target === "draft-2020-12") {
              json2.prefixItems = prefixItems;
              if (rest) {
                json2.items = rest;
              }
            } else if (this.target === "openapi-3.0") {
              json2.items = {
                anyOf: prefixItems
              };
              if (rest) {
                json2.items.anyOf.push(rest);
              }
              json2.minItems = prefixItems.length;
              if (!rest) {
                json2.maxItems = prefixItems.length;
              }
            } else {
              json2.items = prefixItems;
              if (rest) {
                json2.additionalItems = rest;
              }
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minItems = minimum;
            if (typeof maximum === "number")
              json2.maxItems = maximum;
            break;
          }
          case "record": {
            const json2 = _json;
            json2.type = "object";
            if (this.target === "draft-7" || this.target === "draft-2020-12") {
              json2.propertyNames = this.process(def.keyType, {
                ...params,
                path: [...params.path, "propertyNames"]
              });
            }
            json2.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json2 = _json;
            const values = getEnumValues(def.entries);
            if (values.every((v) => typeof v === "number"))
              json2.type = "number";
            if (values.every((v) => typeof v === "string"))
              json2.type = "string";
            json2.enum = values;
            break;
          }
          case "literal": {
            const json2 = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === void 0) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {
                }
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {
            } else if (vals.length === 1) {
              const val = vals[0];
              json2.type = val === null ? "null" : typeof val;
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.enum = [val];
              } else {
                json2.const = val;
              }
            } else {
              if (vals.every((v) => typeof v === "number"))
                json2.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json2.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json2.type = "string";
              if (vals.every((v) => v === null))
                json2.type = "null";
              json2.enum = vals;
            }
            break;
          }
          case "file": {
            const json2 = _json;
            const file2 = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== void 0)
              file2.minLength = minimum;
            if (maximum !== void 0)
              file2.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file2.contentMediaType = mime[0];
                Object.assign(json2, file2);
              } else {
                json2.anyOf = mime.map((m) => {
                  const mFile = { ...file2, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json2, file2);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            if (this.target === "openapi-3.0") {
              result.ref = def.innerType;
              _json.nullable = true;
            } else {
              _json.anyOf = [inner, { type: "null" }];
            }
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json2 = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json2.type = "string";
            json2.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          // passthrough types
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw") {
              throw new Error("Function types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {
            def;
          }
        }
      }
    }
    const meta = this.metadataRegistry.get(schema);
    if (meta)
      Object.assign(result.schema, meta);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a = result.schema).default ?? (_a.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: _params?.external ?? void 0
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = /* @__PURE__ */ __name((entry) => {
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry[0])?.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    }, "makeURI");
    const extractToDef = /* @__PURE__ */ __name((entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref: ref2, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref2;
    }, "extractToDef");
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = this.metadataRegistry.get(entry[0])?.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = /* @__PURE__ */ __name((zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref2 = seen.ref;
      seen.ref = null;
      if (ref2) {
        flattenRef(ref2, params2);
        const refSchema = this.seen.get(ref2).schema;
        if (refSchema.$ref && (params2.target === "draft-7" || params2.target === "draft-4" || params2.target === "openapi-3.0")) {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    }, "flattenRef");
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (this.target === "draft-4") {
      result.$schema = "http://json-schema.org/draft-04/schema#";
    } else if (this.target === "openapi-3.0") {
    } else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id = params.external.registry.get(schema)?.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = params.external?.defs ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {
    } else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
};
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
__name(toJSONSchema, "toJSONSchema");
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    // inner types
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    case "function": {
      return false;
    }
    default:
      def;
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}
__name(isTransforming, "isTransforming");

// node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/classic/schemas.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/classic/checks.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time4
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
__name(datetime2, "datetime");
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
__name(date2, "date");
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time4(params) {
  return _isoTime(ZodISOTime, params);
}
__name(time4, "time");
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}
__name(duration2, "duration");

// node_modules/zod/v4/classic/parse.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/classic/errors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var initializer2 = /* @__PURE__ */ __name((inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: /* @__PURE__ */ __name((mapper) => formatError(inst, mapper), "value")
      // enumerable: false,
    },
    flatten: {
      value: /* @__PURE__ */ __name((mapper) => flattenError(inst, mapper), "value")
      // enumerable: false,
    },
    addIssue: {
      value: /* @__PURE__ */ __name((issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }, "value")
      // enumerable: false,
    },
    addIssues: {
      value: /* @__PURE__ */ __name((issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }, "value")
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, "initializer");
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse3 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
var encode2 = /* @__PURE__ */ _encode(ZodRealError);
var decode4 = /* @__PURE__ */ _decode(ZodRealError);
var encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
var decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
var safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
var safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
var safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
var safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(util_exports.mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }));
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) => parse3(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode2(inst, data, params);
  inst.decode = (data, params) => decode4(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time4(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
__name(string2, "string");
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
__name(email2, "email");
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
__name(guid2, "guid");
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
__name(uuid2, "uuid");
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
__name(uuidv4, "uuidv4");
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
__name(uuidv6, "uuidv6");
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
__name(uuidv7, "uuidv7");
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
__name(url, "url");
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
__name(httpUrl, "httpUrl");
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
__name(emoji2, "emoji");
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
__name(nanoid2, "nanoid");
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
__name(cuid3, "cuid");
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
__name(cuid22, "cuid2");
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
__name(ulid2, "ulid");
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
__name(xid2, "xid");
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
__name(ksuid2, "ksuid");
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
__name(ipv42, "ipv4");
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
__name(ipv62, "ipv6");
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
__name(cidrv42, "cidrv4");
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
__name(cidrv62, "cidrv6");
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
__name(base642, "base64");
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
__name(base64url2, "base64url");
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
__name(e1642, "e164");
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt2(params) {
  return _jwt(ZodJWT, params);
}
__name(jwt2, "jwt");
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
__name(stringFormat, "stringFormat");
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
__name(hostname2, "hostname");
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
__name(hex2, "hex");
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = regexes_exports[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
__name(hash, "hash");
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
__name(number2, "number");
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
__name(int, "int");
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
__name(float32, "float32");
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
__name(float64, "float64");
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
__name(int32, "int32");
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
__name(uint32, "uint32");
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
__name(boolean2, "boolean");
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint3(params) {
  return _bigint(ZodBigInt, params);
}
__name(bigint3, "bigint");
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
__name(int64, "int64");
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
__name(uint64, "uint64");
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
__name(symbol, "symbol");
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
__name(_undefined3, "_undefined");
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
__name(_null3, "_null");
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
__name(any, "any");
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
__name(unknown, "unknown");
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
__name(never, "never");
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
__name(_void2, "_void");
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
__name(date3, "date");
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
__name(array, "array");
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
__name(keyof, "keyof");
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  util_exports.defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return util_exports.safeExtend(inst, incoming);
  };
  inst.merge = (other) => util_exports.merge(inst, other);
  inst.pick = (mask) => util_exports.pick(inst, mask);
  inst.omit = (mask) => util_exports.omit(inst, mask);
  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
__name(object, "object");
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
__name(strictObject, "strictObject");
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
__name(looseObject, "looseObject");
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
__name(union, "union");
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
__name(discriminatedUnion, "discriminatedUnion");
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
__name(intersection, "intersection");
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
__name(tuple, "tuple");
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
__name(record, "record");
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = void 0;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
__name(partialRecord, "partialRecord");
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
__name(map, "map");
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
__name(set, "set");
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
__name(_enum2, "_enum");
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
__name(nativeEnum, "nativeEnum");
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
__name(literal, "literal");
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
__name(file, "file");
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
__name(transform, "transform");
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
__name(optional, "optional");
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
__name(nullable, "nullable");
function nullish2(innerType) {
  return optional(nullable(innerType));
}
__name(nullish2, "nullish");
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
__name(_default2, "_default");
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
__name(prefault, "prefault");
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
__name(nonoptional, "nonoptional");
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
__name(success, "success");
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
__name(_catch2, "_catch");
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
__name(nan, "nan");
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
__name(pipe, "pipe");
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
__name(codec, "codec");
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
__name(readonly, "readonly");
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
__name(templateLiteral, "templateLiteral");
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
__name(lazy, "lazy");
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
__name(promise, "promise");
var ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodType.init(inst, def);
});
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
__name(_function, "_function");
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
__name(check, "check");
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
__name(custom, "custom");
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
__name(refine, "refine");
function superRefine(fn) {
  return _superRefine(fn);
}
__name(superRefine, "superRefine");
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: /* @__PURE__ */ __name((data) => data instanceof cls, "fn"),
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
__name(_instanceof, "_instanceof");
var stringbool = /* @__PURE__ */ __name((...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean,
  String: ZodString
}, ...args), "stringbool");
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
__name(json, "json");
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
__name(preprocess, "preprocess");

// node_modules/zod/v4/classic/compat.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config2({
    customError: map2
  });
}
__name(setErrorMap, "setErrorMap");
function getErrorMap() {
  return config2().customError;
}
__name(getErrorMap, "getErrorMap");
var ZodFirstPartyTypeKind;
/* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

// node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint4,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function string3(params) {
  return _coercedString(ZodString, params);
}
__name(string3, "string");
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
__name(number3, "number");
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
__name(boolean3, "boolean");
function bigint4(params) {
  return _coercedBigint(ZodBigInt, params);
}
__name(bigint4, "bigint");
function date4(params) {
  return _coercedDate(ZodDate, params);
}
__name(date4, "date");

// node_modules/zod/v4/classic/external.js
config2(en_default());

// src/utils/auth.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_jwt4();
async function verifyToken(token, secret) {
  try {
    const payload = await verify2(token, secret, "HS512");
    if (payload.exp && payload.exp < Date.now() / 1e3) {
      return null;
    }
    return {
      id: payload.userId || payload.sub,
      email: payload.email,
      role: payload.role || "user",
      permissions: payload.permissions || []
    };
  } catch (error48) {
    log3.error("Token verification error", error48, { component: "AUTH_SERVICE" });
    return null;
  }
}
__name(verifyToken, "verifyToken");
async function authMiddleware(c, next) {
  const authHeader = c.req.header("Authorization");
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return c.json({ error: "Unauthorized" }, 401);
  }
  const token = authHeader.slice(7);
  const secret = c.env.JWT_SECRET || "development-secret-change-in-production";
  const user = await verifyToken(token, secret);
  if (!user) {
    return c.json({ error: "Invalid or expired token" }, 401);
  }
  c.set("user", user);
  await next();
}
__name(authMiddleware, "authMiddleware");
var validateAuth = authMiddleware;

// src/routes/transcribe.ts
var app4 = new Hono2();
app4.get("/stream", async (c) => {
  const upgradeHeader = c.req.header("upgrade");
  if (!upgradeHeader || upgradeHeader !== "websocket") {
    return c.json({ error: "Expected WebSocket" }, 426);
  }
  const webSocketPair = new WebSocketPair();
  const [client, server] = Object.values(webSocketPair);
  server.accept();
  handleWebSocket(server, c.env);
  return new Response(null, {
    status: 101,
    webSocket: client
  });
});
async function handleWebSocket(ws, env2) {
  let config3 = {
    language: "en",
    model: "whisper-large-v3-turbo",
    task: "transcribe",
    enableTranslation: false,
    targetLanguages: []
  };
  const audioBuffer = [];
  let isProcessing = false;
  let sessionActive = true;
  ws.addEventListener("message", async (event) => {
    try {
      if (typeof event.data === "string") {
        const message = JSON.parse(event.data);
        if (message.type === "config") {
          config3 = { ...config3, ...message };
          ws.send(JSON.stringify({
            type: "config_updated",
            config: config3
          }));
        } else if (message.type === "end_session") {
          sessionActive = false;
          ws.close();
        }
      } else if (event.data instanceof ArrayBuffer) {
        audioBuffer.push(event.data);
        const totalSize = audioBuffer.reduce((sum, buf) => sum + buf.byteLength, 0);
        const targetSize = 16e3 * 2;
        if (totalSize >= targetSize && !isProcessing) {
          isProcessing = true;
          const combinedBuffer = new ArrayBuffer(totalSize);
          const view = new Uint8Array(combinedBuffer);
          let offset = 0;
          for (const buffer of audioBuffer) {
            view.set(new Uint8Array(buffer), offset);
            offset += buffer.byteLength;
          }
          audioBuffer.length = 0;
          try {
            const transcription = await processAudio(env2.AI, combinedBuffer, {
              task: config3.task,
              language: config3.language,
              vad_filter: true
            });
            if (transcription.text && transcription.text.trim()) {
              const transcribedText = transcription.text.trim();
              let translations = {};
              if (config3.enableTranslation && config3.targetLanguages.length > 0) {
                try {
                  translations = await translateToMultipleLanguages(
                    env2.AI,
                    transcribedText,
                    config3.targetLanguages,
                    transcription.language || "auto"
                  );
                } catch (error48) {
                  log3.error("Translation error", error48, { component: "TRANSCRIBE_SERVICE" });
                }
              }
              ws.send(JSON.stringify({
                type: "transcription",
                text: transcribedText,
                language: transcription.language,
                words: transcription.words,
                translations,
                is_final: true,
                timestamp: Date.now(),
                confidence: transcription.confidence || 0.95
              }));
            }
          } catch (error48) {
            log3.error("Transcription error", error48, { component: "TRANSCRIBE_SERVICE" });
            ws.send(JSON.stringify({
              type: "error",
              message: "Transcription failed"
            }));
          }
          isProcessing = false;
        }
      }
    } catch (error48) {
      log3.error("WebSocket error", error48, { component: "TRANSCRIBE_SERVICE" });
      ws.send(JSON.stringify({
        type: "error",
        message: "Processing error"
      }));
    }
  });
  ws.addEventListener("close", () => {
    sessionActive = false;
    audioBuffer.length = 0;
  });
  const pingInterval = setInterval(() => {
    if (sessionActive && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: "ping" }));
    } else {
      clearInterval(pingInterval);
    }
  }, 3e4);
}
__name(handleWebSocket, "handleWebSocket");
var transcribeSchema = external_exports.object({
  audio_url: external_exports.string().url().optional(),
  audio_base64: external_exports.string().optional(),
  language: external_exports.string().optional(),
  task: external_exports.enum(["transcribe", "translate"]).optional(),
  word_timestamps: external_exports.boolean().optional()
});
app4.post("/", validateAuth, async (c) => {
  try {
    const body = await c.req.json();
    const { audio_url, audio_base64, language, task, word_timestamps } = transcribeSchema.parse(body);
    let audioBuffer;
    if (audio_url) {
      const response = await fetch(audio_url);
      if (!response.ok) {
        return c.json({ error: "Failed to fetch audio" }, 400);
      }
      audioBuffer = await response.arrayBuffer();
    } else if (audio_base64) {
      const binaryString = atob(audio_base64);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      audioBuffer = bytes.buffer;
    } else {
      return c.json({ error: "No audio provided" }, 400);
    }
    const result = await processAudio(c.env.AI, audioBuffer, {
      task: task || "transcribe",
      language: language || "auto",
      vad_filter: true
    });
    return c.json({
      success: true,
      transcription: result
    });
  } catch (error48) {
    log3.error("Transcription error", error48, { component: "TRANSCRIBE_SERVICE" });
    return c.json({
      error: "Transcription failed",
      message: error48 instanceof Error ? error48.message : "Unknown error"
    }, 500);
  }
});
var transcribe_default = app4;

// src/routes/cache.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/middleware/cache.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/services/cache.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var CacheService = class {
  static {
    __name(this, "CacheService");
  }
  constructor(kv, prefix = "cache", defaultTTL = 3600) {
    this.kv = kv;
    this.prefix = prefix;
    this.defaultTTL = defaultTTL;
  }
  //   
  makeKey(...parts) {
    return [this.prefix, ...parts].join(":");
  }
  //  
  async set(key, data, options = {}) {
    const ttl = options.ttl || this.defaultTTL;
    const now = Date.now();
    const entry = {
      data,
      createdAt: now,
      expiresAt: now + ttl * 1e3,
      tags: options.tags,
      version: "1.0"
    };
    await this.kv.put(
      this.makeKey(key),
      JSON.stringify(entry),
      {
        expirationTtl: ttl,
        metadata: {
          tags: options.tags,
          priority: options.priority || "normal"
        }
      }
    );
    if (options.tags && options.tags.length > 0) {
      await this.updateTagIndex(key, options.tags);
    }
  }
  //  
  async get(key) {
    const fullKey = this.makeKey(key);
    const cached2 = await this.kv.get(fullKey, { type: "json" });
    if (!cached2) {
      return null;
    }
    if (cached2.expiresAt < Date.now()) {
      await this.kv.delete(fullKey);
      return null;
    }
    return cached2.data;
  }
  //   
  async has(key) {
    const result = await this.get(key);
    return result !== null;
  }
  //  
  async delete(key) {
    const fullKey = this.makeKey(key);
    await this.kv.delete(fullKey);
  }
  //   
  async deleteByTag(tag) {
    const tagKey = this.makeKey("tags", tag);
    const keys = await this.kv.get(tagKey, { type: "json" });
    if (keys && keys.length > 0) {
      await Promise.all(keys.map((key) => this.kv.delete(this.makeKey(key))));
      await this.kv.delete(tagKey);
    }
  }
  //   
  async deleteByPrefix(prefix) {
    const fullPrefix = this.makeKey(prefix);
    const list = await this.kv.list({ prefix: fullPrefix });
    await Promise.all(
      list.keys.map((key) => this.kv.delete(key.name))
    );
  }
  //   
  async updateTagIndex(key, tags) {
    await Promise.all(
      tags.map(async (tag) => {
        const tagKey = this.makeKey("tags", tag);
        const existing = await this.kv.get(tagKey, { type: "json" }) || [];
        if (!existing.includes(key)) {
          existing.push(key);
          await this.kv.put(tagKey, JSON.stringify(existing), {
            expirationTtl: 86400 * 7
            // 7
          });
        }
      })
    );
  }
  //  
  async getStats() {
    const list = await this.kv.list({ prefix: this.prefix });
    return {
      totalKeys: list.keys.length,
      estimatedSize: list.keys.reduce((sum, key) => sum + (key.metadata?.size || 0), 0),
      oldestKey: list.keys[0]?.name
    };
  }
};
var SessionCache = class {
  static {
    __name(this, "SessionCache");
  }
  constructor(kv) {
    this.cache = new CacheService(kv, "session", 3600);
  }
  //  
  async setSession(sessionId, data, ttl = 3600) {
    await this.cache.set(sessionId, data, {
      ttl,
      tags: ["session", `user:${data.userId}`]
    });
  }
  //  
  async getSession(sessionId) {
    return this.cache.get(sessionId);
  }
  //  
  async refreshSession(sessionId, ttl = 3600) {
    const session = await this.getSession(sessionId);
    if (!session) return false;
    await this.setSession(sessionId, session, ttl);
    return true;
  }
  //   
  async deleteUserSessions(userId) {
    await this.cache.deleteByTag(`user:${userId}`);
  }
  //   
  async deleteAllSessions() {
    await this.cache.deleteByTag("session");
  }
};
var APICache = class {
  static {
    __name(this, "APICache");
  }
  constructor(kv) {
    this.cache = new CacheService(kv, "api", 300);
  }
  // API    
  makeAPIKey(method, url2, params) {
    const paramString = params ? JSON.stringify(params) : "";
    return `${method}:${url2}:${paramString}`;
  }
  // API  
  async cacheResponse(method, url2, response, params, ttl = 300) {
    const key = this.makeAPIKey(method, url2, params);
    await this.cache.set(key, response, { ttl, tags: ["api", method] });
  }
  //   
  async getCachedResponse(method, url2, params) {
    const key = this.makeAPIKey(method, url2, params);
    return this.cache.get(key);
  }
  //     
  async invalidateMethod(method) {
    await this.cache.deleteByTag(method);
  }
  //  API  
  async invalidateAll() {
    await this.cache.deleteByTag("api");
  }
};
var UserCache = class {
  static {
    __name(this, "UserCache");
  }
  constructor(kv) {
    this.cache = new CacheService(kv, "user", 86400);
  }
  //   
  async setUser(userId, profile3) {
    await this.cache.set(`profile:${userId}`, profile3, {
      ttl: 86400,
      tags: ["user-profile"]
    });
  }
  //   
  async getUser(userId) {
    return this.cache.get(`profile:${userId}`);
  }
  //   
  async setUserSettings(userId, settings) {
    await this.cache.set(`settings:${userId}`, settings, {
      ttl: 86400 * 7,
      // 7
      tags: ["user-settings"]
    });
  }
  //   
  async getUserSettings(userId) {
    return this.cache.get(`settings:${userId}`);
  }
  //     
  async invalidateUser(userId) {
    await Promise.all([
      this.cache.delete(`profile:${userId}`),
      this.cache.delete(`settings:${userId}`)
    ]);
  }
};

// src/middleware/cache.ts
async function invalidateCache(kv, patterns) {
  const apiCache = new APICache(kv);
  await Promise.all(
    patterns.map((pattern) => {
      if (pattern === "*") {
        return apiCache.invalidateAll();
      }
      return apiCache.invalidateMethod(pattern);
    })
  );
}
__name(invalidateCache, "invalidateCache");
async function warmCache(env2, endpoints) {
  const apiCache = new APICache(env2.CACHE);
  await Promise.all(
    endpoints.map(async ({ url: url2, ttl = 3600 }) => {
      try {
        const response = await fetch(url2);
        if (response.ok) {
          const data = await response.json();
          const urlObj = new URL(url2);
          const cacheKey = `${urlObj.pathname}${urlObj.search}`;
          await apiCache.cacheResponse("GET", cacheKey, data, null, ttl);
        }
      } catch (error48) {
        console.error(`Failed to warm cache for ${url2}:`, error48);
      }
    })
  );
}
__name(warmCache, "warmCache");
async function getCacheStats(kv) {
  const list = await kv.list({ limit: 1e3 });
  const cacheTypes = {};
  for (const key of list.keys) {
    const [prefix] = key.name.split(":");
    cacheTypes[prefix] = (cacheTypes[prefix] || 0) + 1;
  }
  return {
    totalKeys: list.keys.length,
    estimatedSize: list.keys.reduce((sum, key) => sum + (key.metadata?.size || 0), 0),
    cacheTypes
  };
}
__name(getCacheStats, "getCacheStats");

// src/routes/cache.ts
var app5 = new Hono2();
app5.use("/*", cors());
app5.use("/*", async (c, next) => {
  const apiKey = c.req.header("x-api-key");
  if (apiKey !== c.env.INTERNAL_SECRET) {
    return c.json({ error: "Unauthorized" }, 401);
  }
  await next();
});
app5.get("/stats", async (c) => {
  try {
    const stats = await getCacheStats(c.env.CACHE);
    return c.json({
      success: true,
      stats,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error48) {
    return c.json({ error: error48.message }, 500);
  }
});
app5.post("/invalidate", async (c) => {
  try {
    const body = await c.req.json();
    if (body.type === "all") {
      const cacheService = new CacheService(c.env.CACHE);
      await cacheService.deleteByPrefix("");
      return c.json({
        success: true,
        message: "All cache cleared"
      });
    }
    if (body.type === "api") {
      const apiCache = new APICache(c.env.CACHE);
      await apiCache.invalidateAll();
      return c.json({
        success: true,
        message: "API cache cleared"
      });
    }
    if (body.type === "session") {
      const sessionCache = new SessionCache(c.env.CACHE);
      await sessionCache.deleteAllSessions();
      return c.json({
        success: true,
        message: "Session cache cleared"
      });
    }
    if (body.type === "user" && body.userId) {
      const userCache = new UserCache(c.env.CACHE);
      await userCache.invalidateUser(body.userId);
      const sessionCache = new SessionCache(c.env.CACHE);
      await sessionCache.deleteUserSessions(body.userId);
      return c.json({
        success: true,
        message: `Cache cleared for user ${body.userId}`
      });
    }
    if (body.patterns) {
      await invalidateCache(c.env.CACHE, body.patterns);
      return c.json({
        success: true,
        message: `Cache invalidated for patterns: ${body.patterns.join(", ")}`
      });
    }
    if (body.tag) {
      const cacheService = new CacheService(c.env.CACHE);
      await cacheService.deleteByTag(body.tag);
      return c.json({
        success: true,
        message: `Cache cleared for tag: ${body.tag}`
      });
    }
    return c.json({ error: "No invalidation criteria provided" }, 400);
  } catch (error48) {
    return c.json({ error: error48.message }, 500);
  }
});
app5.post("/warm", async (c) => {
  try {
    const body = await c.req.json();
    if (!body.endpoints || body.endpoints.length === 0) {
      return c.json({ error: "No endpoints provided" }, 400);
    }
    c.executionCtx.waitUntil(
      warmCache(c.env, body.endpoints)
    );
    return c.json({
      success: true,
      message: `Warming cache for ${body.endpoints.length} endpoints`,
      endpoints: body.endpoints
    });
  } catch (error48) {
    return c.json({ error: error48.message }, 500);
  }
});
app5.get("/get/:key", async (c) => {
  try {
    const key = c.req.param("key");
    const cacheService = new CacheService(c.env.CACHE);
    const value = await cacheService.get(key);
    if (!value) {
      return c.json({ error: "Key not found" }, 404);
    }
    return c.json({
      success: true,
      key,
      value,
      exists: true
    });
  } catch (error48) {
    return c.json({ error: error48.message }, 500);
  }
});
app5.post("/set", async (c) => {
  try {
    const body = await c.req.json();
    if (!body.key || body.value === void 0) {
      return c.json({ error: "Key and value are required" }, 400);
    }
    const cacheService = new CacheService(c.env.CACHE);
    await cacheService.set(body.key, body.value, {
      ttl: body.ttl,
      tags: body.tags
    });
    return c.json({
      success: true,
      key: body.key,
      ttl: body.ttl || 3600
    });
  } catch (error48) {
    return c.json({ error: error48.message }, 500);
  }
});
app5.get("/keys", async (c) => {
  try {
    const prefix = c.req.query("prefix") || "";
    const limit = parseInt(c.req.query("limit") || "100");
    const list = await c.env.CACHE.list({
      prefix,
      limit: Math.min(limit, 1e3)
    });
    return c.json({
      success: true,
      keys: list.keys.map((key) => ({
        name: key.name,
        expiration: key.expiration,
        metadata: key.metadata
      })),
      cursor: list.cursor,
      complete: list.list_complete
    });
  } catch (error48) {
    return c.json({ error: error48.message }, 500);
  }
});
app5.post("/session/refresh", async (c) => {
  try {
    const body = await c.req.json();
    if (!body.sessionId) {
      return c.json({ error: "Session ID is required" }, 400);
    }
    const sessionCache = new SessionCache(c.env.CACHE);
    const refreshed = await sessionCache.refreshSession(
      body.sessionId,
      body.ttl || 3600
    );
    if (!refreshed) {
      return c.json({ error: "Session not found" }, 404);
    }
    return c.json({
      success: true,
      sessionId: body.sessionId,
      refreshed: true,
      ttl: body.ttl || 3600
    });
  } catch (error48) {
    return c.json({ error: error48.message }, 500);
  }
});
var cache_default = app5;

// src/routes/translate.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var app6 = new Hono2();
app6.use("/*", cors());
var LANGUAGE_CODES = {
  "ko": "Korean",
  "en": "English",
  "ja": "Japanese",
  "zh": "Chinese",
  "es": "Spanish",
  "fr": "French",
  "de": "German",
  "ru": "Russian",
  "ar": "Arabic",
  "hi": "Hindi",
  "pt": "Portuguese",
  "it": "Italian",
  "nl": "Dutch",
  "sv": "Swedish",
  "pl": "Polish",
  "tr": "Turkish",
  "vi": "Vietnamese",
  "th": "Thai",
  "id": "Indonesian",
  "ms": "Malay"
};
async function detectLanguage(text, ai) {
  try {
    const prompt = `Detect the language of the following text and respond with ONLY the ISO 639-1 language code (e.g., 'en' for English, 'ko' for Korean, 'ja' for Japanese, etc.).

Text: "${text}"

Language code:`;
    const response = await ai.run("@cf/meta/llama-3.3-70b-instruct-fp8-fast", {
      messages: [
        { role: "system", content: "You are a language detection expert. Respond only with the ISO 639-1 language code." },
        { role: "user", content: prompt }
      ],
      temperature: 0.1,
      max_tokens: 10
    });
    const detectedCode = response.response.trim().toLowerCase();
    return LANGUAGE_CODES[detectedCode] ? detectedCode : "en";
  } catch (error48) {
    log3.error("Language detection error", error48, { component: "TRANSLATE_SERVICE" });
    return "en";
  }
}
__name(detectLanguage, "detectLanguage");
app6.post("/translate", async (c) => {
  try {
    const body = await c.req.json();
    if (!body.text || !body.target) {
      return c.json({ error: "Text and target language are required" }, 400);
    }
    const sourceLanguage = body.source || await detectLanguage(body.text, c.env.AI);
    const targetLanguage = body.target;
    if (sourceLanguage === targetLanguage) {
      return c.json({
        success: true,
        originalText: body.text,
        translatedText: body.text,
        sourceLanguage,
        targetLanguage,
        isIdentical: true
      });
    }
    const prompt = `Translate the following text from ${LANGUAGE_CODES[sourceLanguage] || sourceLanguage} to ${LANGUAGE_CODES[targetLanguage] || targetLanguage}.
${body.preserveFormatting ? "Preserve the original formatting including line breaks and punctuation." : ""}

Original text:
"${body.text}"

Translation:`;
    const response = await c.env.AI.run("@cf/meta/llama-3.3-70b-instruct-fp8-fast", {
      messages: [
        {
          role: "system",
          content: "You are a professional translator. Provide accurate, natural translations while maintaining the original meaning and tone. Respond only with the translation, no explanations."
        },
        { role: "user", content: prompt }
      ],
      temperature: 0.3,
      max_tokens: Math.min(body.text.length * 3, 2e3)
      //      
    });
    const translatedText = response.response.trim().replace(/^["']/, "").replace(/["']$/, "");
    return c.json({
      success: true,
      originalText: body.text,
      translatedText,
      sourceLanguage,
      targetLanguage,
      model: "@cf/meta/llama-3.3-70b-instruct-fp8-fast"
    });
  } catch (error48) {
    log3.error("Translation error", error48, { component: "TRANSLATE_SERVICE" });
    return c.json({ error: error48.message || "Translation failed" }, 500);
  }
});
app6.post("/translate/batch", async (c) => {
  try {
    const body = await c.req.json();
    if (!body.texts || body.texts.length === 0 || !body.target) {
      return c.json({ error: "Texts array and target language are required" }, 400);
    }
    const textsToTranslate = body.texts.slice(0, 10);
    const translations = await Promise.all(
      textsToTranslate.map(async (text) => {
        try {
          const sourceLanguage = body.source || await detectLanguage(text, c.env.AI);
          if (sourceLanguage === body.target) {
            return {
              originalText: text,
              translatedText: text,
              sourceLanguage,
              targetLanguage: body.target,
              isIdentical: true
            };
          }
          const prompt = `Translate from ${LANGUAGE_CODES[sourceLanguage] || sourceLanguage} to ${LANGUAGE_CODES[body.target] || body.target}: "${text}"`;
          const response = await c.env.AI.run("@cf/meta/llama-3.3-70b-instruct-fp8-fast", {
            messages: [
              { role: "system", content: "You are a translator. Provide only the translation, no explanations." },
              { role: "user", content: prompt }
            ],
            temperature: 0.3,
            max_tokens: Math.min(text.length * 3, 1e3)
          });
          return {
            originalText: text,
            translatedText: response.response.trim().replace(/^["']|["']$/g, ""),
            sourceLanguage,
            targetLanguage: body.target
          };
        } catch (error48) {
          return {
            originalText: text,
            translatedText: "",
            error: "Translation failed",
            sourceLanguage: body.source || "unknown",
            targetLanguage: body.target
          };
        }
      })
    );
    return c.json({
      success: true,
      translations,
      total: translations.length
    });
  } catch (error48) {
    log3.error("Batch translation error", error48, { component: "TRANSLATE_SERVICE" });
    return c.json({ error: error48.message || "Batch translation failed" }, 500);
  }
});
app6.post("/translate/subtitle", async (c) => {
  try {
    const body = await c.req.json();
    if (!body.subtitle?.text || !body.targetLanguage) {
      return c.json({ error: "Subtitle text and target language are required" }, 400);
    }
    const sourceLanguage = body.subtitle.language || await detectLanguage(body.subtitle.text, c.env.AI);
    if (sourceLanguage === body.targetLanguage) {
      return c.json({
        success: true,
        originalSubtitle: body.subtitle,
        translatedSubtitle: {
          ...body.subtitle,
          translatedText: body.subtitle.text,
          targetLanguage: body.targetLanguage
        }
      });
    }
    let contextPrompt = "";
    if (body.context && body.context.length > 0) {
      contextPrompt = `Previous conversation context:
${body.context.slice(-3).join("\n")}

`;
    }
    const prompt = `${contextPrompt}Translate this subtitle from ${LANGUAGE_CODES[sourceLanguage] || sourceLanguage} to ${LANGUAGE_CODES[body.targetLanguage] || body.targetLanguage}. Keep it concise for subtitles:

"${body.subtitle.text}"`;
    const response = await c.env.AI.run("@cf/meta/llama-3.3-70b-instruct-fp8-fast", {
      messages: [
        {
          role: "system",
          content: "You are a subtitle translator. Provide concise, natural translations suitable for real-time display. Consider the conversation context if provided."
        },
        { role: "user", content: prompt }
      ],
      temperature: 0.3,
      max_tokens: 200
    });
    const translatedText = response.response.trim().replace(/^["']|["']$/g, "");
    return c.json({
      success: true,
      originalSubtitle: body.subtitle,
      translatedSubtitle: {
        ...body.subtitle,
        translatedText,
        targetLanguage: body.targetLanguage,
        sourceLanguage
      }
    });
  } catch (error48) {
    log3.error("Subtitle translation error", error48, { component: "TRANSLATE_SERVICE" });
    return c.json({ error: error48.message || "Subtitle translation failed" }, 500);
  }
});
app6.get("/languages", (c) => {
  const languages = Object.entries(LANGUAGE_CODES).map(([code, name]) => ({
    code,
    name,
    nativeName: getNativeName(code)
  }));
  return c.json({
    success: true,
    languages,
    total: languages.length
  });
});
function getNativeName(code) {
  const nativeNames = {
    "ko": "\uD55C\uAD6D\uC5B4",
    "en": "English",
    "ja": "\u65E5\u672C\u8A9E",
    "zh": "\u4E2D\u6587",
    "es": "Espa\xF1ol",
    "fr": "Fran\xE7ais",
    "de": "Deutsch",
    "ru": "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
    "ar": "\u0627\u0644\u0639\u0631\u0628\u064A\u0629",
    "hi": "\u0939\u093F\u0928\u094D\u0926\u0940",
    "pt": "Portugu\xEAs",
    "it": "Italiano",
    "nl": "Nederlands",
    "sv": "Svenska",
    "pl": "Polski",
    "tr": "T\xFCrk\xE7e",
    "vi": "Ti\u1EBFng Vi\u1EC7t",
    "th": "\u0E44\u0E17\u0E22",
    "id": "Bahasa Indonesia",
    "ms": "Bahasa Melayu"
  };
  return nativeNames[code] || LANGUAGE_CODES[code] || code;
}
__name(getNativeName, "getNativeName");
var translate_default = app6;

// src/routes/analytics.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_analytics();

// src/services/learningAnalytics.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_db();
async function collectUserSessionData(env2, userId, monthsBack = 3) {
  const startDate = /* @__PURE__ */ new Date();
  startDate.setMonth(startDate.getMonth() - monthsBack);
  const sessions = await query(
    env2.DB,
    `SELECT
      s.session_id,
      s.created_at,
      s.duration_minutes,
      s.session_type,
      CASE
        WHEN s.host_user_id = ? THEN s.guest_user_id
        ELSE s.host_user_id
      END as partner_id
    FROM sessions s
    WHERE (s.host_user_id = ? OR s.guest_user_id = ?)
      AND s.created_at >= ?
      AND s.status = 'completed'
    ORDER BY s.created_at DESC
    LIMIT 100`,
    [userId, userId, userId, startDate.toISOString()]
  );
  return sessions.map((s) => ({
    sessionId: String(s.session_id),
    date: s.created_at,
    duration: s.duration_minutes || 30,
    type: s.session_type || "video",
    partnerId: s.partner_id || void 0
  }));
}
__name(collectUserSessionData, "collectUserSessionData");
async function analyzeStudyHabits(ai, sessions) {
  if (sessions.length === 0) {
    return {
      preferredTimeSlots: [],
      averageSessionDuration: 0,
      sessionsPerWeek: 0,
      consistency: 0,
      mostProductiveTime: "morning"
    };
  }
  const totalDuration = sessions.reduce((sum, s) => sum + s.duration, 0);
  const averageSessionDuration = Math.round(totalDuration / sessions.length);
  const weeks = Math.ceil((Date.now() - new Date(sessions[sessions.length - 1].date).getTime()) / (7 * 24 * 60 * 60 * 1e3));
  const sessionsPerWeek = Math.round(sessions.length / Math.max(weeks, 1) * 10) / 10;
  const messages = [
    {
      role: "system",
      content: `You are a learning analytics expert. Analyze study session patterns and provide insights.

Respond in JSON format:
{
  "preferredTimeSlots": ["morning", "evening"],
  "consistency": 75,
  "mostProductiveTime": "morning"
}`
    },
    {
      role: "user",
      content: `Analyze these study session patterns:

Sessions: ${sessions.length} sessions over ${weeks} weeks
Average duration: ${averageSessionDuration} minutes
Sessions per week: ${sessionsPerWeek}

Session dates: ${sessions.slice(0, 20).map((s) => s.date).join(", ")}

Determine:
- Preferred time slots (morning/afternoon/evening)
- Study consistency (0-100)
- Most productive time of day`
    }
  ];
  try {
    const response = await generateChatCompletion(ai, messages, {
      model: "@cf/meta/llama-3.3-70b-instruct-fp8-fast",
      temperature: 0.3,
      max_tokens: 500
    });
    const sanitized = sanitizeJsonResponse(response);
    const parsed = JSON.parse(sanitized);
    return {
      preferredTimeSlots: Array.isArray(parsed.preferredTimeSlots) ? parsed.preferredTimeSlots : [],
      averageSessionDuration,
      sessionsPerWeek,
      consistency: typeof parsed.consistency === "number" ? parsed.consistency : 50,
      mostProductiveTime: parsed.mostProductiveTime || "morning"
    };
  } catch (error48) {
    log3.error("Failed to analyze study habits:", error48);
    return {
      preferredTimeSlots: ["morning"],
      averageSessionDuration,
      sessionsPerWeek,
      consistency: 50,
      mostProductiveTime: "morning"
    };
  }
}
__name(analyzeStudyHabits, "analyzeStudyHabits");
async function analyzeProgress(ai, userId, sessions, env2) {
  const levelTests = await query(
    env2.DB,
    `SELECT overall_level, created_at
    FROM level_test_results
    WHERE user_id = ?
    ORDER BY created_at DESC
    LIMIT 10`,
    [userId]
  );
  const currentLevel = levelTests[0]?.overall_level || "A1";
  const startingLevel = levelTests[levelTests.length - 1]?.overall_level || currentLevel;
  const firstSession = sessions[sessions.length - 1];
  const monthsLearning = firstSession ? Math.ceil((Date.now() - new Date(firstSession.date).getTime()) / (30 * 24 * 60 * 60 * 1e3)) : 1;
  const messages = [
    {
      role: "system",
      content: `You are a language learning progress analyst. Analyze improvement and predict future progress.

Respond in JSON format:
{
  "improvementRate": 75,
  "projection": {
    "nextLevel": "B1",
    "estimatedMonths": 4,
    "confidence": 80
  }
}`
    },
    {
      role: "user",
      content: `Analyze learning progress:

Current Level: ${currentLevel}
Starting Level: ${startingLevel}
Months Learning: ${monthsLearning}
Total Sessions: ${sessions.length}
Sessions per Week: ${(sessions.length / (monthsLearning * 4.33)).toFixed(1)}

Level progression: ${levelTests.map((t) => `${t.overall_level} (${t.created_at})`).join(", ")}

Calculate:
- Improvement rate (0-100)
- Next level prediction
- Estimated months to next level
- Confidence in prediction (0-100)`
    }
  ];
  try {
    const response = await generateChatCompletion(ai, messages, {
      model: "@cf/meta/llama-3.3-70b-instruct-fp8-fast",
      temperature: 0.3,
      max_tokens: 500
    });
    const sanitized = sanitizeJsonResponse(response);
    const parsed = JSON.parse(sanitized);
    return {
      currentLevel,
      startingLevel,
      monthsLearning,
      improvementRate: typeof parsed.improvementRate === "number" ? parsed.improvementRate : 50,
      projection: {
        nextLevel: parsed.projection?.nextLevel || "B1",
        estimatedMonths: parsed.projection?.estimatedMonths || 6,
        confidence: parsed.projection?.confidence || 50
      }
    };
  } catch (error48) {
    log3.error("Failed to analyze progress:", error48);
    return {
      currentLevel,
      startingLevel,
      monthsLearning,
      improvementRate: 50,
      projection: {
        nextLevel: "B1",
        estimatedMonths: 6,
        confidence: 50
      }
    };
  }
}
__name(analyzeProgress, "analyzeProgress");
async function analyzeStrengthsWeaknesses(ai, sessions) {
  const sessionsWithScores = sessions.filter((s) => s.scores);
  if (sessionsWithScores.length === 0) {
    return { strengths: [], weaknesses: [] };
  }
  const areas = ["pronunciation", "fluency", "grammar", "vocabulary", "coherence"];
  const averages = {};
  areas.forEach((area) => {
    const scores = sessionsWithScores.map((s) => s.scores?.[area]).filter((score) => score !== void 0);
    if (scores.length > 0) {
      averages[area] = Math.round(scores.reduce((sum, s) => sum + s, 0) / scores.length);
    }
  });
  const messages = [
    {
      role: "system",
      content: `You are a language learning analyst. Identify strengths and weaknesses from performance data.

Respond in JSON format:
{
  "strengths": [
    {
      "area": "pronunciation",
      "score": 85,
      "trend": "improving",
      "details": "Consistently strong in consonant sounds"
    }
  ],
  "weaknesses": [
    {
      "area": "grammar",
      "score": 55,
      "trend": "stable",
      "details": "Struggles with verb tenses",
      "recommendations": ["Focus on past tense practice", "Use grammar exercises"]
    }
  ]
}`
    },
    {
      role: "user",
      content: `Analyze performance across areas:

${Object.entries(averages).map(([area, score]) => `${area}: ${score}/100`).join("\n")}

Total sessions analyzed: ${sessionsWithScores.length}

Identify:
- Top 3 strengths (score >= 70)
- Top 3 weaknesses (score < 70)
- Trends for each area
- Specific recommendations for weaknesses`
    }
  ];
  try {
    const response = await generateChatCompletion(ai, messages, {
      model: "@cf/meta/llama-3.3-70b-instruct-fp8-fast",
      temperature: 0.3,
      max_tokens: 1200
    });
    const sanitized = sanitizeJsonResponse(response);
    const parsed = JSON.parse(sanitized);
    return {
      strengths: Array.isArray(parsed.strengths) ? parsed.strengths : [],
      weaknesses: Array.isArray(parsed.weaknesses) ? parsed.weaknesses : []
    };
  } catch (error48) {
    log3.error("Failed to analyze strengths/weaknesses:", error48);
    return { strengths: [], weaknesses: [] };
  }
}
__name(analyzeStrengthsWeaknesses, "analyzeStrengthsWeaknesses");
async function generateInsightsAndPath(ai, pattern) {
  const messages = [
    {
      role: "system",
      content: `You are a personalized learning coach. Generate actionable insights and a customized learning path.

Respond in JSON format:
{
  "insights": {
    "keyFindings": ["Finding 1", "Finding 2"],
    "recommendations": ["Recommendation 1", "Recommendation 2"],
    "milestones": [
      {
        "title": "Milestone 1",
        "description": "Description",
        "targetDate": "2025-12-01",
        "priority": "high"
      }
    ]
  },
  "personalizedPath": {
    "shortTerm": [
      {
        "goal": "Improve grammar accuracy",
        "activities": ["Daily grammar exercises", "Practice with partner"],
        "estimatedWeeks": 4
      }
    ],
    "mediumTerm": [],
    "longTerm": []
  }
}`
    },
    {
      role: "user",
      content: `Generate personalized learning insights and path:

Current Level: ${pattern.progress?.currentLevel}
Study Frequency: ${pattern.studyHabits?.sessionsPerWeek} sessions/week
Consistency: ${pattern.studyHabits?.consistency}/100

Strengths: ${pattern.strengths?.map((s) => s.area).join(", ") || "None identified"}
Weaknesses: ${pattern.weaknesses?.map((w) => w.area).join(", ") || "None identified"}

Next Level Goal: ${pattern.progress?.projection?.nextLevel} in ${pattern.progress?.projection?.estimatedMonths} months

Create:
- 3-5 key findings
- 3-5 actionable recommendations
- 2-3 milestones with dates
- Short-term (1-2 months), medium-term (3-6 months), long-term (6-12 months) learning goals`
    }
  ];
  try {
    const response = await generateChatCompletion(ai, messages, {
      model: "@cf/meta/llama-3.3-70b-instruct-fp8-fast",
      temperature: 0.7,
      max_tokens: 2e3
    });
    const sanitized = sanitizeJsonResponse(response);
    const parsed = JSON.parse(sanitized);
    return {
      insights: {
        keyFindings: Array.isArray(parsed.insights?.keyFindings) ? parsed.insights.keyFindings : [],
        recommendations: Array.isArray(parsed.insights?.recommendations) ? parsed.insights.recommendations : [],
        milestones: Array.isArray(parsed.insights?.milestones) ? parsed.insights.milestones : []
      },
      personalizedPath: {
        shortTerm: Array.isArray(parsed.personalizedPath?.shortTerm) ? parsed.personalizedPath.shortTerm : [],
        mediumTerm: Array.isArray(parsed.personalizedPath?.mediumTerm) ? parsed.personalizedPath.mediumTerm : [],
        longTerm: Array.isArray(parsed.personalizedPath?.longTerm) ? parsed.personalizedPath.longTerm : []
      }
    };
  } catch (error48) {
    log3.error("Failed to generate insights and path:", error48);
    return {
      insights: { keyFindings: [], recommendations: [], milestones: [] },
      personalizedPath: { shortTerm: [], mediumTerm: [], longTerm: [] }
    };
  }
}
__name(generateInsightsAndPath, "generateInsightsAndPath");
async function analyzeLearningPattern(env2, userId, monthsBack = 3) {
  const sessions = await collectUserSessionData(env2, userId, monthsBack);
  const [studyHabits, progress, { strengths, weaknesses }] = await Promise.all([
    analyzeStudyHabits(env2.AI, sessions),
    analyzeProgress(env2.AI, userId, sessions, env2),
    analyzeStrengthsWeaknesses(env2.AI, sessions)
  ]);
  const videoSessions = sessions.filter((s) => s.type === "video").length;
  const audioSessions = sessions.filter((s) => s.type === "audio").length;
  const textSessions = sessions.filter((s) => s.type === "text").length;
  const learningStyle = {
    primary: videoSessions > audioSessions && videoSessions > textSessions ? ["visual"] : audioSessions > textSessions ? ["auditory"] : ["reading"],
    engagement: { videoSessions, audioSessions, textSessions },
    preferredActivities: ["conversation"]
    // 
  };
  const engagement = {
    overallScore: Math.min(studyHabits.consistency, 100),
    activeParticipation: Math.min(studyHabits.sessionsPerWeek * 10, 100),
    initiativeLevel: 70,
    // 
    motivationFactors: ["language exchange", "career"],
    riskFactors: studyHabits.consistency < 50 ? ["low consistency"] : []
  };
  const partialPattern = {
    studyHabits,
    progress,
    strengths,
    weaknesses
  };
  const { insights, personalizedPath } = await generateInsightsAndPath(env2.AI, partialPattern);
  return {
    userId,
    analysisDate: (/* @__PURE__ */ new Date()).toISOString(),
    studyHabits,
    progress,
    strengths,
    weaknesses,
    learningStyle,
    engagement,
    insights,
    personalizedPath
  };
}
__name(analyzeLearningPattern, "analyzeLearningPattern");

// src/routes/analytics.ts
init_errors();
var app7 = new Hono2();
var metricsQuerySchema = external_exports.object({
  start: external_exports.string().datetime().optional(),
  end: external_exports.string().datetime().optional(),
  groupBy: external_exports.enum(["path", "status", "country"]).optional(),
  interval: external_exports.enum(["1m", "5m", "1h", "1d"]).optional()
});
app7.get("/metrics", authMiddleware, async (c) => {
  try {
    const query2 = metricsQuerySchema.parse(c.req.query());
    const end = query2.end ? new Date(query2.end) : /* @__PURE__ */ new Date();
    const start = query2.start ? new Date(query2.start) : new Date(end.getTime() - 24 * 60 * 60 * 1e3);
    const metrics = await getAggregatedMetrics(
      c.env,
      { start, end },
      query2.groupBy
    );
    if (!metrics) {
      return successResponse(c, {
        timeRange: { start, end },
        groupBy: query2.groupBy ?? null,
        fallback: true,
        metrics: {
          count: 0,
          avgDuration: 0,
          avgCpuTime: 0,
          p95Duration: 0,
          p95CpuTime: 0,
          buckets: []
        }
      }, {
        note: "analytics_fallback"
      });
    }
    return successResponse(c, {
      timeRange: { start, end },
      groupBy: query2.groupBy,
      metrics
    });
  } catch (error48) {
    console.error("Metrics query error:", error48);
    return successResponse(c, {
      timeRange: {
        start: new Date(Date.now() - 24 * 60 * 60 * 1e3),
        end: /* @__PURE__ */ new Date()
      },
      groupBy: null,
      fallback: true,
      metrics: {
        count: 0,
        avgDuration: 0,
        avgCpuTime: 0,
        p95Duration: 0,
        p95CpuTime: 0,
        buckets: []
      }
    }, {
      note: "analytics_error_fallback"
    });
  }
});
app7.get("/dashboard", authMiddleware, async (c) => {
  try {
    const now = /* @__PURE__ */ new Date();
    const ranges = {
      last24h: { start: new Date(now.getTime() - 24 * 60 * 60 * 1e3), end: now },
      last7d: { start: new Date(now.getTime() - 7 * 24 * 60 * 60 * 1e3), end: now },
      last30d: { start: new Date(now.getTime() - 30 * 24 * 60 * 60 * 1e3), end: now }
    };
    const [
      overview24h,
      overview7d,
      overview30d,
      topPaths,
      errorsByStatus,
      geoDistribution
    ] = await Promise.all([
      getAggregatedMetrics(c.env, ranges.last24h),
      getAggregatedMetrics(c.env, ranges.last7d),
      getAggregatedMetrics(c.env, ranges.last30d),
      getAggregatedMetrics(c.env, ranges.last24h, "path"),
      getAggregatedMetrics(c.env, ranges.last24h, "status"),
      getAggregatedMetrics(c.env, ranges.last24h, "country")
    ]);
    return successResponse(c, {
      overview: {
        last24h: overview24h,
        last7d: overview7d,
        last30d: overview30d
      },
      topPaths,
      errorsByStatus,
      geoDistribution,
      timestamp: now.toISOString()
    });
  } catch (error48) {
    console.error("Dashboard data error:", error48);
    return c.json({ success: false, error: { message: "Failed to load dashboard data" } }, { status: 500 });
  }
});
app7.get("/stream", async (c) => {
  const upgradeHeader = c.req.header("upgrade");
  if (!upgradeHeader || upgradeHeader !== "websocket") {
    return c.json({ error: "Expected WebSocket" }, 426);
  }
  const webSocketPair = new globalThis.WebSocketPair();
  const [client, server] = Object.values(webSocketPair);
  server.accept();
  const authHeader = c.req.header("authorization");
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    server.send(JSON.stringify({ type: "error", message: "Unauthorized" }));
    server.close(1008, "Unauthorized");
    return new Response(null, { status: 101, webSocket: client });
  }
  const { streamMetrics: streamMetrics2 } = await Promise.resolve().then(() => (init_analytics(), analytics_exports));
  streamMetrics2(server, c.env);
  return new Response(null, {
    status: 101,
    webSocket: client
  });
});
app7.get("/errors", authMiddleware, async (c) => {
  try {
    const query2 = metricsQuerySchema.parse(c.req.query());
    const end = query2.end ? new Date(query2.end) : /* @__PURE__ */ new Date();
    const start = query2.start ? new Date(query2.start) : new Date(end.getTime() - 24 * 60 * 60 * 1e3);
    const result = await c.env.ANALYTICS?.query({
      timeRange: [start, end],
      filter: {
        blob1: "error"
      },
      aggregations: {
        count: { count: {} },
        topErrors: {
          topK: {
            field: "blob4",
            // error message
            k: 10
          }
        },
        errorsByType: {
          topK: {
            field: "blob5",
            // error type
            k: 10
          }
        }
      }
    });
    return successResponse(c, {
      timeRange: { start, end },
      errors: result || null
    });
  } catch (error48) {
    console.error("Error stats error:", error48);
    return errorResponse(c, "Failed to query error statistics");
  }
});
app7.get("/ai-usage", authMiddleware, async (c) => {
  try {
    const query2 = metricsQuerySchema.parse(c.req.query());
    const end = query2.end ? new Date(query2.end) : /* @__PURE__ */ new Date();
    const start = query2.start ? new Date(query2.start) : new Date(end.getTime() - 24 * 60 * 60 * 1e3);
    const result = await c.env.ANALYTICS?.query({
      timeRange: [start, end],
      filter: {
        blob5: { $ne: "" }
        // AI model  
      },
      aggregations: {
        totalTokens: { sum: { field: "double3" } },
        avgTokensPerRequest: { avg: { field: "double3" } },
        totalAiDuration: { sum: { field: "double4" } },
        avgAiDuration: { avg: { field: "double4" } },
        modelUsage: {
          topK: {
            field: "blob5",
            // AI model
            k: 10
          }
        }
      }
    });
    return successResponse(c, {
      timeRange: { start, end },
      aiUsage: result || null
    });
  } catch (error48) {
    console.error("AI usage stats error:", error48);
    return errorResponse(c, "Failed to query AI usage statistics");
  }
});
app7.get("/performance", authMiddleware, async (c) => {
  try {
    const query2 = metricsQuerySchema.parse(c.req.query());
    const end = query2.end ? new Date(query2.end) : /* @__PURE__ */ new Date();
    const start = query2.start ? new Date(query2.start) : new Date(end.getTime() - 24 * 60 * 60 * 1e3);
    const result = await c.env.ANALYTICS?.query({
      timeRange: [start, end],
      filter: {
        blob1: "api_request"
      },
      aggregations: {
        p50Duration: { quantile: { field: "double1", quantile: 0.5 } },
        p75Duration: { quantile: { field: "double1", quantile: 0.75 } },
        p90Duration: { quantile: { field: "double1", quantile: 0.9 } },
        p95Duration: { quantile: { field: "double1", quantile: 0.95 } },
        p99Duration: { quantile: { field: "double1", quantile: 0.99 } },
        p50CpuTime: { quantile: { field: "double2", quantile: 0.5 } },
        p75CpuTime: { quantile: { field: "double2", quantile: 0.75 } },
        p90CpuTime: { quantile: { field: "double2", quantile: 0.9 } },
        p95CpuTime: { quantile: { field: "double2", quantile: 0.95 } },
        p99CpuTime: { quantile: { field: "double2", quantile: 0.99 } }
      },
      groupBy: query2.groupBy ? [`blob${getFieldIndex2(query2.groupBy)}`] : void 0
    });
    return successResponse(c, {
      timeRange: { start, end },
      groupBy: query2.groupBy,
      performance: result || null
    });
  } catch (error48) {
    console.error("Performance stats error:", error48);
    return errorResponse(c, "Failed to query performance statistics");
  }
});
function getFieldIndex2(field) {
  const fieldMap = {
    "path": 3,
    "status": 1,
    "country": 2
  };
  return fieldMap[field] || 1;
}
__name(getFieldIndex2, "getFieldIndex");
app7.post("/events", async (c) => {
  try {
    const { events } = await c.req.json();
    if (!Array.isArray(events)) {
      return errorResponse(c, "Events must be an array", "INVALID_INPUT", null, 400);
    }
    for (const event of events) {
      await c.env.ANALYTICS?.writeDataPoint({
        blobs: [
          "client_event",
          event.event,
          event.userId,
          event.sessionId,
          event.properties?.page || ""
        ],
        doubles: [
          event.timestamp,
          event.properties?.pageLoadTime || 0,
          event.properties?.duration || 0,
          0
        ],
        indexes: [
          event.properties?.sessionType || "",
          event.properties?.feature || "",
          event.properties?.variant || ""
        ]
      });
    }
    return successResponse(c, {
      message: "Events recorded",
      count: events.length
    });
  } catch (error48) {
    console.error("Events recording error:", error48);
    return errorResponse(c, "Failed to record events");
  }
});
app7.get("/learning-pattern", authMiddleware, async (c) => {
  try {
    const userId = c.get("userId");
    if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
    const monthsBack = parseInt(c.req.query("monthsBack") || "3");
    if (monthsBack < 1 || monthsBack > 12) {
      throw new AppError("monthsBack must be between 1 and 12", 400, "INVALID_MONTHS_BACK");
    }
    const pattern = await analyzeLearningPattern(c.env, userId, monthsBack);
    return successResponse(c, pattern);
  } catch (error48) {
    if (error48 instanceof AppError) {
      return errorResponse(c, error48.message, error48.statusCode);
    }
    console.error("Learning pattern analysis error:", error48);
    return errorResponse(c, "Learning pattern analysis failed");
  }
});
app7.get("/progress-summary", authMiddleware, async (c) => {
  try {
    const userId = c.get("userId");
    if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
    if (!c.env.AI) {
      console.warn("AI binding not available, returning default progress summary");
      return successResponse(c, {
        currentLevel: "A1",
        sessionsThisWeek: 0,
        consistency: 0,
        nextMilestone: null,
        topStrength: null,
        topWeakness: null,
        fallback: true
      });
    }
    const pattern = await analyzeLearningPattern(c.env, userId, 1);
    return successResponse(c, {
      currentLevel: pattern.progress.currentLevel,
      sessionsThisWeek: Math.round(pattern.studyHabits.sessionsPerWeek),
      consistency: pattern.studyHabits.consistency,
      nextMilestone: pattern.insights.milestones[0] || null,
      topStrength: pattern.strengths[0]?.area || null,
      topWeakness: pattern.weaknesses[0]?.area || null
    });
  } catch (error48) {
    if (error48 instanceof AppError) {
      return errorResponse(c, error48.message, error48.statusCode);
    }
    console.error("Progress summary error:", error48);
    return successResponse(c, {
      currentLevel: "A1",
      sessionsThisWeek: 0,
      consistency: 0,
      nextMilestone: null,
      topStrength: null,
      topWeakness: null,
      fallback: true,
      error: error48 instanceof Error ? error48.message : "Unknown error"
    });
  }
});
app7.get("/recommendations", authMiddleware, async (c) => {
  try {
    const userId = c.get("userId");
    if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
    const pattern = await analyzeLearningPattern(c.env, userId, 3);
    return successResponse(c, {
      recommendations: pattern.insights.recommendations,
      personalizedPath: pattern.personalizedPath,
      weaknessesWithSolutions: pattern.weaknesses.map((w) => ({
        area: w.area,
        score: w.score,
        recommendations: w.recommendations
      }))
    });
  } catch (error48) {
    if (error48 instanceof AppError) {
      return errorResponse(c, error48.message, error48.statusCode);
    }
    console.error("Recommendations error:", error48);
    return errorResponse(c, "Recommendations generation failed");
  }
});

// src/routes/internal.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/constants/whisper.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var WHISPER_MODELS = {
  ENGLISH_ONLY: "@cf/openai/whisper-tiny-en",
  //   ()
  MULTILINGUAL: "@cf/openai/whisper"
  //  
};
var ENGLISH_LANGUAGE_CODES = [
  "en",
  //  
  "en-US",
  //  
  "en-GB",
  //  
  "en-AU",
  //  
  "en-CA",
  //  
  "en-NZ",
  //  
  "en-IE",
  //  
  "en-ZA"
  //  
];
var MAJOR_SUPPORTED_LANGUAGES = {
  //  
  ko: "\uD55C\uAD6D\uC5B4",
  ja: "\uC77C\uBCF8\uC5B4",
  zh: "\uC911\uAD6D\uC5B4",
  vi: "\uBCA0\uD2B8\uB0A8\uC5B4",
  th: "\uD0DC\uAD6D\uC5B4",
  id: "\uC778\uB3C4\uB124\uC2DC\uC544\uC5B4",
  //  
  es: "\uC2A4\uD398\uC778\uC5B4",
  fr: "\uD504\uB791\uC2A4\uC5B4",
  de: "\uB3C5\uC77C\uC5B4",
  it: "\uC774\uD0C8\uB9AC\uC544\uC5B4",
  pt: "\uD3EC\uB974\uD22C\uAC08\uC5B4",
  ru: "\uB7EC\uC2DC\uC544\uC5B4",
  nl: "\uB124\uB35C\uB780\uB4DC\uC5B4",
  pl: "\uD3F4\uB780\uB4DC\uC5B4",
  sv: "\uC2A4\uC6E8\uB374\uC5B4",
  // //
  ar: "\uC544\uB78D\uC5B4",
  tr: "\uD130\uD0A4\uC5B4",
  hi: "\uD78C\uB514\uC5B4",
  he: "\uD788\uBE0C\uB9AC\uC5B4",
  fa: "\uD398\uB974\uC2DC\uC544\uC5B4"
};
var WHISPER_FILE_LIMITS = {
  MAX_SIZE: 25 * 1024 * 1024,
  // 25MB ( )
  RECOMMENDED_SIZE: 4 * 1024 * 1024,
  // 4MB ()
  OPTIMAL_DURATION: 30
  // 30 ()
};
function selectWhisperModel(language) {
  const lang = language || "auto";
  if (ENGLISH_LANGUAGE_CODES.includes(lang)) {
    return {
      model: WHISPER_MODELS.ENGLISH_ONLY,
      isEnglishOnly: true,
      languageName: "English"
    };
  }
  const languageName = MAJOR_SUPPORTED_LANGUAGES[lang];
  return {
    model: WHISPER_MODELS.MULTILINGUAL,
    isEnglishOnly: false,
    languageName: languageName || `Language: ${lang}`
  };
}
__name(selectWhisperModel, "selectWhisperModel");
function validateAudioSize(sizeInBytes) {
  if (sizeInBytes > WHISPER_FILE_LIMITS.MAX_SIZE) {
    return {
      isValid: false,
      isOptimal: false,
      message: `File too large: ${(sizeInBytes / 1024 / 1024).toFixed(2)}MB (max: 25MB)`
    };
  }
  if (sizeInBytes > WHISPER_FILE_LIMITS.RECOMMENDED_SIZE) {
    return {
      isValid: true,
      isOptimal: false,
      message: `File is large: ${(sizeInBytes / 1024 / 1024).toFixed(2)}MB (recommended: <4MB)`
    };
  }
  return {
    isValid: true,
    isOptimal: true
  };
}
__name(validateAudioSize, "validateAudioSize");

// src/routes/internal.ts
var internalRoutes = new Hono2();
internalRoutes.use("*", internalAuth());
internalRoutes.post("/transcribe", async (c) => {
  try {
    const body = await c.req.json();
    const { audio_url, audio_base64, language, user_context } = body;
    let audioBuffer;
    if (audio_url) {
      const response = await fetch(audio_url);
      if (!response.ok) {
        return c.json({ error: "Failed to fetch audio from URL" }, 400);
      }
      audioBuffer = await response.arrayBuffer();
    } else if (audio_base64) {
      const binaryString = atob(audio_base64);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      audioBuffer = bytes.buffer;
    } else {
      return c.json({ error: "Either audio_url or audio_base64 must be provided" }, 400);
    }
    const sizeValidation = validateAudioSize(audioBuffer.byteLength);
    if (!sizeValidation.isValid) {
      return c.json({
        error: "Audio file too large",
        message: sizeValidation.message,
        details: {
          currentSize: audioBuffer.byteLength,
          maxSize: WHISPER_FILE_LIMITS.MAX_SIZE,
          recommendedSize: WHISPER_FILE_LIMITS.RECOMMENDED_SIZE
        }
      }, 400);
    }
    if (!sizeValidation.isOptimal) {
      const warningMessage = sizeValidation.message || "Audio file size exceeds recommended threshold";
      log3.warn(warningMessage, void 0, {
        component: "INTERNAL_API",
        audioSize: audioBuffer.byteLength
      });
    }
    let result;
    try {
      const audioArray = [...new Uint8Array(audioBuffer)];
      const modelSelection = selectWhisperModel(language);
      log3.info("Processing audio for transcription", void 0, {
        component: "INTERNAL_API",
        audioSize: audioBuffer.byteLength,
        arrayLength: audioArray.length,
        language: language || "auto",
        model: modelSelection.model,
        languageName: modelSelection.languageName
      });
      const whisperResponse = await c.env.AI.run(modelSelection.model, {
        audio: audioArray
      });
      result = {
        text: whisperResponse?.text || "",
        language: whisperResponse?.language || language || "unknown",
        vtt: whisperResponse?.vtt,
        words: whisperResponse?.words
      };
      log3.info("Transcription successful", void 0, {
        component: "INTERNAL_API",
        textLength: result.text.length,
        detectedLanguage: result.language
      });
    } catch (whisperError) {
      log3.error("Whisper processing error", whisperError instanceof Error ? whisperError : new Error(String(whisperError)), void 0, {
        component: "INTERNAL_API",
        audioSize: audioBuffer.byteLength,
        error: whisperError instanceof Error ? whisperError.message : "Unknown error"
      });
      return c.json({
        error: "Transcription failed",
        message: whisperError instanceof Error ? whisperError.message : "Unknown error",
        details: {
          audioSize: audioBuffer.byteLength,
          maxAllowedSize: WHISPER_FILE_LIMITS.MAX_SIZE
        }
      }, 500);
    }
    return successResponse(c, {
      transcript: result.text || "",
      language: result.language,
      confidence: 1,
      // Whisper doesn't provide confidence scores
      word_count: result.text ? result.text.split(/\s+/).filter((word) => word.length > 0).length : 0,
      processing_time: 0,
      // Would need to measure actual processing time
      vtt: result.vtt,
      words: result.words,
      user_context: user_context || null
    });
  } catch (error48) {
    log3.error("Internal transcription error", error48, void 0, { component: "INTERNAL_API" });
    return c.json({
      error: "Transcription failed",
      message: error48 instanceof Error ? error48.message : "Unknown error"
    }, 500);
  }
});
internalRoutes.post("/level-test", async (c) => {
  try {
    const body = await c.req.json();
    const { transcript, language, questions, user_context } = body;
    if (!transcript) {
      return c.json({ error: "Transcript is required" }, 400);
    }
    const evaluation = await evaluateLanguageLevel(
      c.env.AI,
      transcript,
      questions || "Please introduce yourself and talk about your interests."
    );
    return successResponse(c, {
      evaluation,
      analyzed_text: transcript,
      language: language || "en",
      user_context: user_context || null,
      processed_at: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error48) {
    log3.error("Internal level test error", error48, { component: "INTERNAL_API" });
    return c.json({
      error: "Level test evaluation failed",
      message: error48 instanceof Error ? error48.message : "Unknown error"
    }, 500);
  }
});
internalRoutes.patch("/webrtc/rooms/:roomId/metadata", async (c) => {
  const roomId = c.req.param("roomId");
  if (!roomId) {
    return c.json({ error: "roomId is required" }, 400);
  }
  try {
    const metadata = await c.req.json();
    if (!metadata || typeof metadata !== "object") {
      return c.json({ error: "metadata object is required" }, 400);
    }
    const id = c.env.ROOM.idFromName(roomId);
    const room = c.env.ROOM.get(id);
    const response = await room.fetch(new Request("http://room/metadata", {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(metadata)
    }));
    if (!response.ok) {
      const errorBody = await response.json().catch(() => ({}));
      return c.json({
        error: "Failed to update metadata",
        details: errorBody?.message || null
      }, response.status);
    }
    const cacheKey = `room:${roomId}`;
    const cached2 = await c.env.CACHE.get(cacheKey);
    if (cached2) {
      try {
        const cachedData = JSON.parse(cached2);
        const updated = {
          ...cachedData,
          metadata: {
            ...cachedData.metadata || {},
            ...metadata
          }
        };
        await c.env.CACHE.put(cacheKey, JSON.stringify(updated), { expirationTtl: 3600 });
      } catch (cacheError) {
        log3.warn("Failed to update cached room metadata", void 0, {
          component: "INTERNAL_API",
          roomId,
          error: cacheError instanceof Error ? cacheError.message : String(cacheError)
        });
      }
    }
    const activeRooms = await getActiveRooms(c.env.CACHE);
    const index = activeRooms.findIndex((room2) => room2.roomId === roomId);
    if (index >= 0) {
      const updatedRoom = {
        ...activeRooms[index],
        metadata: {
          ...activeRooms[index].metadata || {},
          ...metadata
        },
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      await upsertActiveRoom(c.env.CACHE, updatedRoom);
    }
    const result = await response.json().catch(() => ({ success: true }));
    return successResponse(c, result);
  } catch (error48) {
    log3.error("WebRTC metadata sync error", error48, void 0, { component: "INTERNAL_API", roomId });
    return c.json({
      error: "Failed to sync metadata",
      message: error48 instanceof Error ? error48.message : "Unknown error"
    }, 500);
  }
});
internalRoutes.post("/conversation-feedback", async (c) => {
  try {
    const body = await c.req.json();
    const { transcript, context: context2, user_level, user_context } = body;
    if (!transcript) {
      return c.json({ error: "Transcript is required" }, 400);
    }
    const conversation = [
      {
        speaker: "user",
        text: transcript
      }
    ];
    const prompt = `Analyze this English conversation and provide detailed feedback:

Context: ${context2 || "General conversation"}
User Level: ${user_level || "Unknown"}

Conversation:
User: ${transcript}

Provide comprehensive feedback in JSON format:
{
  "overallAssessment": "general assessment of the conversation",
  "strengths": ["strength 1", "strength 2"],
  "weaknesses": ["weakness 1", "weakness 2"],
  "corrections": [
    {
      "original": "incorrect phrase",
      "correction": "corrected phrase",
      "explanation": "why this correction is needed"
    }
  ],
  "suggestions": ["suggestion 1", "suggestion 2"],
  "encouragement": "positive feedback message",
  "fluencyScore": 75
}`;
    const aiResponse = await generateChatCompletion(c.env.AI, [
      {
        role: "system",
        content: "You are an experienced English conversation coach. Always respond with valid JSON."
      },
      { role: "user", content: prompt }
    ], {
      temperature: 0.4,
      max_tokens: 1500,
      response_format: { type: "json_object" }
    });
    let feedback;
    try {
      const sanitized = sanitizeJsonResponse(aiResponse.text);
      feedback = JSON.parse(sanitized);
    } catch (parseError) {
      log3.warn("Conversation feedback parse error", void 0, {
        component: "INTERNAL_API",
        rawPreview: aiResponse.text?.slice(0, 500),
        sanitizedPreview: sanitizeJsonResponse(aiResponse.text)?.slice(0, 500),
        errorMessage: parseError instanceof Error ? parseError.message : String(parseError),
        model: aiResponse.model
      });
      feedback = {
        overallAssessment: "The conversation shows your effort to communicate in English.",
        strengths: ["Shows willingness to practice English"],
        weaknesses: ["Could benefit from more practice"],
        corrections: [],
        suggestions: ["Continue practicing regularly", "Focus on clear pronunciation"],
        encouragement: "Keep practicing! You're making progress.",
        fluencyScore: 70
      };
    }
    return successResponse(c, {
      feedback,
      analyzed_text: transcript,
      context: context2 || "general",
      user_level: user_level || "unknown",
      user_context: user_context || null,
      processed_at: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error48) {
    log3.error("Internal conversation feedback error", error48, void 0, { component: "INTERNAL_API" });
    return c.json({
      error: "Conversation feedback generation failed",
      message: error48 instanceof Error ? error48.message : "Unknown error"
    }, 500);
  }
});
internalRoutes.post("/learning-recommendations", async (c) => {
  try {
    const body = await c.req.json();
    const { user_level, weaknesses, strengths, user_context } = body;
    const recommendations = generateStaticRecommendations(user_level, weaknesses);
    return successResponse(c, {
      recommendations,
      user_level: user_level || "B1",
      based_on_weaknesses: weaknesses || [],
      based_on_strengths: strengths || [],
      user_context: user_context || null,
      generated_at: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error48) {
    log3.error("Internal learning recommendations error", error48, void 0, { component: "INTERNAL_API" });
    return c.json({
      error: "Learning recommendations generation failed",
      message: error48 instanceof Error ? error48.message : "Unknown error"
    }, 500);
  }
});
function generateStaticRecommendations(userLevel, weaknesses) {
  const levelContent = {
    "A1": {
      contents: [
        "Basic vocabulary flashcards (colors, numbers, family)",
        "Simple conversation dialogues",
        "English learning apps for beginners",
        "Children's English books"
      ],
      exercises: [
        "Daily greeting practice",
        "Basic sentence construction",
        "Pronunciation drills for common words",
        "Simple Q&A practice"
      ],
      timePerDay: "15-20 minutes"
    },
    "A2": {
      contents: [
        "Elementary reading passages",
        "Basic grammar workbooks",
        "English learning videos for beginners",
        "Simple news articles"
      ],
      exercises: [
        "Present and past tense practice",
        "Describing daily activities",
        "Basic conversation scenarios",
        "Listening to slow English podcasts"
      ],
      timePerDay: "20-30 minutes"
    },
    "B1": {
      contents: [
        "Intermediate reading materials",
        "English podcasts for learners",
        "Grammar reference books",
        "English news articles"
      ],
      exercises: [
        "Conversation role-play scenarios",
        "Grammar pattern drills",
        "Writing short paragraphs",
        "Listening comprehension practice"
      ],
      timePerDay: "30-45 minutes"
    },
    "B2": {
      contents: [
        "Advanced reading materials",
        "TED talks and presentations",
        "English novels and literature",
        "Professional English materials"
      ],
      exercises: [
        "Debate and discussion practice",
        "Academic writing exercises",
        "Business English conversations",
        "Complex listening materials"
      ],
      timePerDay: "45-60 minutes"
    },
    "C1": {
      contents: [
        "Advanced literature excerpts",
        "Native speaker podcasts",
        "Academic papers and articles",
        "Professional development materials"
      ],
      exercises: [
        "Advanced debate topics",
        "Professional presentation practice",
        "Academic writing and research",
        "Nuanced language practice"
      ],
      timePerDay: "60+ minutes"
    },
    "C2": {
      contents: [
        "Native-level literature",
        "Specialized academic content",
        "Professional publications",
        "Cultural and historical materials"
      ],
      exercises: [
        "Advanced writing and editing",
        "Teaching and mentoring others",
        "Professional presentations",
        "Creative language use"
      ],
      timePerDay: "60+ minutes"
    }
  };
  const level = userLevel.toUpperCase();
  const baseRecommendations = levelContent[level] || levelContent["B1"];
  const weaknessRecommendations = {
    "grammar": [
      "Focus on grammar exercises and rules",
      "Use grammar checking tools",
      "Practice sentence construction"
    ],
    "vocabulary": [
      "Expand vocabulary with themed word lists",
      "Use spaced repetition flashcards",
      "Read extensively in your interest areas"
    ],
    "pronunciation": [
      "Practice with pronunciation apps",
      "Record yourself speaking",
      "Listen to native speakers carefully"
    ],
    "fluency": [
      "Practice speaking regularly",
      "Join conversation groups",
      "Think in English daily"
    ]
  };
  let additionalSuggestions = [];
  weaknesses.forEach((weakness) => {
    const suggestions = weaknessRecommendations[weakness.toLowerCase()];
    if (suggestions) {
      additionalSuggestions = additionalSuggestions.concat(suggestions);
    }
  });
  return {
    recommendedContents: baseRecommendations.contents,
    practiceExercises: baseRecommendations.exercises,
    estimatedTimePerDay: baseRecommendations.timePerDay,
    focusAreas: weaknesses,
    additionalSuggestions,
    nextLevelGoals: getNextLevelGoals(level)
  };
}
__name(generateStaticRecommendations, "generateStaticRecommendations");
function getNextLevelGoals(currentLevel) {
  const goals = {
    "A1": ["Master basic grammar patterns", "Build core vocabulary (500-1000 words)", "Have simple conversations"],
    "A2": ["Use past and future tenses confidently", "Describe experiences and events", "Understand simple texts"],
    "B1": ["Express opinions and preferences", "Handle routine tasks requiring English", "Understand main ideas of complex texts"],
    "B2": ["Discuss abstract topics", "Write clear, detailed text", "Interact fluently with native speakers"],
    "C1": ["Use language flexibly for social and professional purposes", "Write well-structured, detailed text", "Understand virtually everything"],
    "C2": ["Express yourself spontaneously and precisely", "Understand everything with ease", "Summarize and argue effectively"]
  };
  return goals[currentLevel] || goals["B1"];
}
__name(getNextLevelGoals, "getNextLevelGoals");
var internal_default = internalRoutes;

// src/routes/auth.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_errors();

// src/services/user.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_db();
init_security();
init_errors();
function mapRowToProfile(row) {
  return {
    id: row.user_id,
    email: row.email ?? void 0,
    name: row.name ?? void 0,
    englishName: row.english_name ?? void 0,
    birthday: row.birthday ?? void 0,
    birthyear: row.birthyear ?? void 0,
    gender: row.gender ?? void 0,
    profileImage: row.profile_image ?? void 0,
    selfBio: row.self_bio ?? void 0,
    location: row.location_id ? {
      id: row.location_id,
      country: row.location_country ?? "",
      city: row.location_city ?? void 0,
      timeZone: row.location_time_zone ?? void 0
    } : void 0,
    nativeLanguage: row.native_lang_id ? {
      id: row.native_lang_id,
      name: row.native_language_name ?? "",
      code: row.native_language_code ?? ""
    } : void 0,
    onboardingCompleted: row.is_onboarding_completed === 1,
    communicationMethod: row.communication_method ?? void 0,
    dailyMinute: row.daily_minute ?? void 0,
    partnerGender: row.partner_gender ?? void 0,
    learningExpectation: row.learning_expectation ?? void 0,
    createdAt: row.created_at,
    updatedAt: row.updated_at
  };
}
__name(mapRowToProfile, "mapRowToProfile");
async function getUserProfile(env2, userId) {
  const row = await queryFirst(
    env2.DB,
    `SELECT 
        u.user_id,
        u.email,
        u.name,
        u.english_name,
        u.birthday,
        u.birthyear,
        u.gender,
        u.profile_image,
        u.self_bio,
        u.location_id,
        u.native_lang_id,
        u.communication_method,
        u.daily_minute,
        u.partner_gender,
        u.learning_expectation,
        u.is_onboarding_completed,
        u.created_at,
        u.updated_at,
        l.country AS location_country,
        l.city AS location_city,
        l.time_zone AS location_time_zone,
        lang.language_name AS native_language_name,
        lang.language_code AS native_language_code
      FROM users u
      LEFT JOIN locations l ON u.location_id = l.location_id
      LEFT JOIN languages lang ON u.native_lang_id = lang.language_id
      WHERE u.user_id = ?
      LIMIT 1`,
    [userId]
  );
  if (!row) {
    return null;
  }
  return mapRowToProfile(row);
}
__name(getUserProfile, "getUserProfile");
async function updateUserProfile(env2, userId, payload) {
  const setters = [];
  const params = [];
  const map2 = {
    name: "name",
    englishName: "english_name",
    selfBio: "self_bio",
    gender: "gender",
    birthday: "birthday",
    birthyear: "birthyear",
    locationId: "location_id",
    nativeLanguageId: "native_lang_id",
    communicationMethod: "communication_method",
    dailyMinute: "daily_minute",
    partnerGender: "partner_gender",
    learningExpectation: "learning_expectation",
    onboardingCompleted: "is_onboarding_completed",
    profileImage: "profile_image"
  };
  for (const [key, value] of Object.entries(payload)) {
    if (value === void 0) continue;
    if (key === "onboardingCompleted") {
      setters.push(`${map2[key]} = ?`);
      params.push(value ? 1 : 0);
    } else {
      setters.push(`${map2[key]} = ?`);
      params.push(value === null ? null : value);
    }
  }
  if (setters.length > 0) {
    setters.push("updated_at = ?");
    params.push((/* @__PURE__ */ new Date()).toISOString());
    params.push(userId);
    await execute(env2.DB, `UPDATE users SET ${setters.join(", ")} WHERE user_id = ?`, params);
  }
  const profile3 = await getUserProfile(env2, userId);
  if (!profile3) {
    throw new Error("User not found after update");
  }
  return profile3;
}
__name(updateUserProfile, "updateUserProfile");
async function getUserSettings(env2, userId) {
  const rows = await query(
    env2.DB,
    "SELECT setting_key, setting_value FROM user_settings WHERE user_id = ? ORDER BY setting_key",
    [userId]
  );
  const result = {};
  const notificationPreferences = {};
  for (const row of rows) {
    const [section, key] = row.setting_key.split(".");
    if (!key) continue;
    const rawValue = row.setting_value;
    const normalized = rawValue === "true" ? true : rawValue === "false" ? false : rawValue ?? void 0;
    switch (section) {
      case "notifications":
        if (typeof normalized === "boolean") {
          notificationPreferences[key] = normalized;
        }
        break;
      case "preferences":
        if (key === "language" && typeof normalized === "string") {
          result.language = normalized;
        } else if (key === "timezone" && typeof normalized === "string") {
          result.timeZone = normalized;
        } else if (key === "marketingOptIn" && typeof normalized === "boolean") {
          result.marketingOptIn = normalized;
        }
        break;
      case "privacy":
        break;
      default:
        break;
    }
  }
  if (Object.keys(notificationPreferences).length > 0) {
    result.notificationPreferences = notificationPreferences;
  }
  return result;
}
__name(getUserSettings, "getUserSettings");
async function updateUserSettings(env2, userId, settings) {
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const entries = [];
  if (settings.language) {
    entries.push(["preferences.language", settings.language]);
  }
  if (settings.timeZone) {
    entries.push(["preferences.timezone", settings.timeZone]);
  }
  if (settings.marketingOptIn !== void 0) {
    entries.push(["preferences.marketingOptIn", String(settings.marketingOptIn)]);
  }
  if (settings.notificationPreferences) {
    for (const [key, value] of Object.entries(settings.notificationPreferences)) {
      entries.push([`notifications.${key}`, String(value)]);
    }
  }
  await transaction(
    env2.DB,
    entries.map(([key, value]) => ({
      sql: "INSERT OR REPLACE INTO user_settings (user_id, setting_key, setting_value, updated_at) VALUES (?, ?, ?, ?)",
      params: [userId, key, value, now]
    }))
  );
  return getUserSettings(env2, userId);
}
__name(updateUserSettings, "updateUserSettings");
async function saveProfileImage(env2, userId, fileName, contentType, body) {
  const safeName = sanitizeFileName(fileName) || "profile-image";
  const key = `users/${userId}/profile/${Date.now()}-${safeName}`;
  await saveToR2(env2.STORAGE, key, body, contentType, {
    userId,
    type: "profile-image"
  });
  await updateUserProfile(env2, userId, { profileImage: key });
  return `/api/v1/upload/file/${key}`;
}
__name(saveProfileImage, "saveProfileImage");
async function deleteProfileImage(env2, userId) {
  const row = await queryFirst(
    env2.DB,
    "SELECT profile_image FROM users WHERE user_id = ? LIMIT 1",
    [userId]
  );
  if (!row) {
    throw new AppError("\uC0AC\uC6A9\uC790\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.", 404, "USER_NOT_FOUND");
  }
  const currentKey = row.profile_image ?? void 0;
  if (currentKey) {
    try {
      await deleteFromR2(env2.STORAGE, currentKey);
    } catch (error48) {
      console.warn("[user] Failed to delete profile image from R2", error48);
    }
  }
  await updateUserProfile(env2, userId, { profileImage: null });
}
__name(deleteProfileImage, "deleteProfileImage");
async function listLocations(env2) {
  const rows = await query(
    env2.DB,
    "SELECT location_id, country, city, time_zone FROM locations ORDER BY country, city"
  );
  return rows.map((row) => ({
    id: row.location_id,
    country: row.country,
    city: row.city ?? void 0,
    timeZone: row.time_zone ?? void 0
  }));
}
__name(listLocations, "listLocations");

// src/routes/auth.ts
init_auth();

// src/middleware/rateLimit.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var RateLimiter = class {
  static {
    __name(this, "RateLimiter");
  }
  constructor(options) {
    this.options = {
      keyPrefix: "ratelimit",
      skipSuccessfulRequests: false,
      skipFailedRequests: false,
      ...options
    };
  }
  /**
   * KV  
   */
  getKey(identifier, endpoint) {
    const { keyPrefix } = this.options;
    return `${keyPrefix}:${identifier}:${endpoint}`;
  }
  /**
   *     
   */
  getWindowStart() {
    const now = Date.now();
    return now - now % this.options.windowMs;
  }
  /**
   * Rate limit   
   */
  async check(kv, identifier, endpoint) {
    const key = this.getKey(identifier, endpoint);
    const windowStart = this.getWindowStart();
    const resetTime = windowStart + this.options.windowMs;
    const stored = await kv.get(key, "json");
    let count3 = 0;
    if (stored && stored.resetTime === resetTime) {
      count3 = stored.count;
    }
    count3++;
    const allowed = count3 <= this.options.maxRequests;
    const newInfo = { count: count3, resetTime };
    const ttl = Math.ceil(this.options.windowMs / 1e3);
    await kv.put(key, JSON.stringify(newInfo), { expirationTtl: ttl });
    return { allowed, info: newInfo };
  }
  /**
   * Rate limit   (  )
   */
  async getInfo(kv, identifier, endpoint) {
    const key = this.getKey(identifier, endpoint);
    return await kv.get(key, "json");
  }
  /**
   * Rate limit 
   */
  async reset(kv, identifier, endpoint) {
    const key = this.getKey(identifier, endpoint);
    await kv.delete(key);
  }
};
function rateLimitMiddleware(options) {
  const limiter = new RateLimiter(options);
  return async (c, next) => {
    const kv = c.env.CACHE;
    if (!kv) {
      console.warn("KV namespace not available, skipping rate limit");
      return next();
    }
    const userId = c.get("userId");
    const ip = c.req.header("CF-Connecting-IP") || c.req.header("X-Forwarded-For") || c.req.header("X-Real-IP") || "unknown";
    const identifier = userId || ip;
    const endpoint = c.req.path;
    const { allowed, info: info3 } = await limiter.check(kv, identifier, endpoint);
    c.header("X-RateLimit-Limit", options.maxRequests.toString());
    c.header("X-RateLimit-Remaining", Math.max(0, options.maxRequests - info3.count).toString());
    c.header("X-RateLimit-Reset", info3.resetTime.toString());
    if (!allowed) {
      const retryAfter = Math.ceil((info3.resetTime - Date.now()) / 1e3);
      c.header("Retry-After", retryAfter.toString());
      return c.json({
        success: false,
        error: {
          message: "\uC694\uCCAD\uC774 \uB108\uBB34 \uB9CE\uC2B5\uB2C8\uB2E4. \uC7A0\uC2DC \uD6C4 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694.",
          code: "TOO_MANY_REQUESTS",
          retryAfter
        }
      }, 429);
    }
    await next();
  };
}
__name(rateLimitMiddleware, "rateLimitMiddleware");
var RateLimitPresets = {
  //  API ( 60)
  standard: {
    windowMs: 60 * 1e3,
    maxRequests: 60
  },
  //  API ( 5)
  auth: {
    windowMs: 60 * 1e3,
    maxRequests: 5
  },
  //  API ( 10)
  upload: {
    windowMs: 60 * 1e3,
    maxRequests: 10
  },
  // AI API ( 20)
  ai: {
    windowMs: 60 * 1e3,
    maxRequests: 20
  },
  // WebRTC API ( 30)
  webrtc: {
    windowMs: 60 * 1e3,
    maxRequests: 30
  },
  //  API ( 10)
  chat: {
    windowMs: 1e3,
    maxRequests: 10
  },
  //  API ( 30)
  search: {
    windowMs: 60 * 1e3,
    maxRequests: 30
  }
};
function endpointRateLimit(preset) {
  const options = RateLimitPresets[preset];
  return rateLimitMiddleware({
    ...options,
    keyPrefix: `endpoint:${preset}`
  });
}
__name(endpointRateLimit, "endpointRateLimit");

// src/routes/auth.ts
var authRoutes = new Hono2();
authRoutes.use("*", endpointRateLimit("auth"));
var wrapAuthError = /* @__PURE__ */ __name((error48) => {
  if (error48 instanceof AppError) {
    return error48;
  }
  const message = error48 instanceof Error ? error48.message : "Authentication failure";
  return new AppError(message, 500, "AUTH_OPERATION_FAILED");
}, "wrapAuthError");
authRoutes.get("/login/:provider", async (c) => {
  const provider = c.req.param("provider");
  const target = c.req.query("target") || c.req.query("redirect_uri") || void 0;
  try {
    const result = await generateLoginUrl(c.env, provider, target);
    const acceptHeader = c.req.header("Accept") || "";
    if (!acceptHeader.includes("application/json") && result.url) {
      return c.redirect(result.url);
    }
    return successResponse(c, result);
  } catch (error48) {
    throw wrapAuthError(error48);
  }
});
authRoutes.get("/naver", async (c) => {
  const target = c.req.query("target") || void 0;
  try {
    const result = await generateLoginUrl(c.env, "naver", target);
    if (result.url) {
      return c.redirect(result.url);
    }
    return successResponse(c, result);
  } catch (error48) {
    throw wrapAuthError(error48);
  }
});
authRoutes.get("/google", async (c) => {
  const target = c.req.query("target") || void 0;
  try {
    const result = await generateLoginUrl(c.env, "google", target);
    if (result.url) {
      return c.redirect(result.url);
    }
    return successResponse(c, result);
  } catch (error48) {
    throw wrapAuthError(error48);
  }
});
authRoutes.get("/callback/:provider", async (c) => {
  const provider = c.req.param("provider");
  const code = c.req.query("code");
  const state = c.req.query("state") || void 0;
  if (!code) {
    throw new AppError("Missing OAuth code", 400, "INVALID_OAUTH_CALLBACK");
  }
  try {
    const result = await handleOAuthCallback(
      c.env,
      provider,
      { code, state },
      {
        userAgent: c.req.header("User-Agent") || void 0,
        ipAddress: c.req.header("CF-Connecting-IP") || c.req.header("X-Forwarded-For") || c.req.header("X-Real-IP") || void 0
      }
    );
    const acceptsJson = (c.req.header("Accept") || "").includes("application/json");
    if (!acceptsJson) {
      const redirectTarget = result.callbackUrl || result.redirectUri;
      if (!redirectTarget) {
        return successResponse(c, result);
      }
      const redirectUrl = new URL(redirectTarget);
      redirectUrl.searchParams.set("accessToken", result.accessToken);
      redirectUrl.searchParams.set("refreshToken", result.refreshToken);
      redirectUrl.searchParams.set("provider", provider);
      if (state) {
        redirectUrl.searchParams.set("state", state);
      }
      if (result.redirectUri && result.redirectUri !== redirectTarget) {
        redirectUrl.searchParams.set("redirect", result.redirectUri);
      }
      return c.redirect(redirectUrl.toString());
    }
    return successResponse(c, result);
  } catch (error48) {
    throw wrapAuthError(error48);
  }
});
authRoutes.post("/refresh", async (c) => {
  const authorization = c.req.header("Authorization");
  if (!authorization) {
    throw new AppError("Authorization header required", 400, "MISSING_AUTH_HEADER");
  }
  const match = authorization.match(/^Bearer\s+(.+)$/i);
  if (!match) {
    throw new AppError("Invalid Authorization format", 400, "INVALID_AUTH_HEADER");
  }
  const refreshToken = match[1];
  try {
    const result = await refreshTokens(
      c.env,
      refreshToken,
      {
        userAgent: c.req.header("User-Agent") || void 0,
        ipAddress: c.req.header("CF-Connecting-IP") || c.req.header("X-Forwarded-For") || c.req.header("X-Real-IP") || void 0
      }
    );
    return successResponse(c, result);
  } catch (error48) {
    throw wrapAuthError(error48);
  }
});
authRoutes.post("/logout", async (c) => {
  const authorization = c.req.header("Authorization");
  if (!authorization) {
    throw new AppError("Authorization header required", 400, "MISSING_AUTH_HEADER");
  }
  const match = authorization.match(/^Bearer\s+(.+)$/i);
  if (!match) {
    throw new AppError("Invalid Authorization format", 400, "INVALID_AUTH_HEADER");
  }
  const accessToken = match[1];
  const refreshToken = c.req.header("X-Refresh-Token") || void 0;
  try {
    await logoutUser(c.env, accessToken, refreshToken);
    return successResponse(c, { success: true });
  } catch (error48) {
    throw wrapAuthError(error48);
  }
});
authRoutes.get("/me", auth(), async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const profile3 = await getUserProfile(c.env, userId);
    if (!profile3) {
      throw new AppError("User not found", 404, "USER_NOT_FOUND");
    }
    return successResponse(c, {
      id: profile3.id,
      email: profile3.email,
      name: profile3.name ?? profile3.englishName,
      englishName: profile3.englishName,
      onboardingCompleted: profile3.onboardingCompleted
    });
  } catch (error48) {
    throw wrapAuthError(error48);
  }
});
authRoutes.get("/verify", auth(), async (c) => {
  const user = c.get("user");
  return successResponse(c, {
    valid: true,
    user: user ?? null
  });
});
var auth_default = authRoutes;

// src/routes/users.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_errors();

// src/services/onboarding.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_db();
async function listLanguageOptions(env2) {
  return query(
    env2.DB,
    "SELECT language_id, language_name, language_code FROM languages WHERE is_active IS NULL OR is_active = 1 ORDER BY language_name"
  );
}
__name(listLanguageOptions, "listLanguageOptions");
async function listLanguageLevelTypes(env2, category) {
  const normalizedCategory = (category ?? "").trim().toUpperCase();
  return query(
    env2.DB,
    `SELECT
        lang_level_id,
        lang_level_name,
        description,
        category,
        level_order
      FROM lang_level_type
      WHERE (
        category IS NOT NULL AND UPPER(category) = ?
      ) OR (
        category IS NULL AND (
          (? = 'LANGUAGE' AND lang_level_id BETWEEN 100 AND 199) OR
          (? = 'PARTNER' AND lang_level_id BETWEEN 200 AND 299)
        )
      )
      ORDER BY
        CASE WHEN level_order IS NULL THEN 1 ELSE 0 END,
        level_order,
        lang_level_id`,
    [normalizedCategory, normalizedCategory, normalizedCategory]
  );
}
__name(listLanguageLevelTypes, "listLanguageLevelTypes");
async function listTopicOptions(env2) {
  return query(env2.DB, "SELECT topic_id, topic_name, description FROM topic WHERE is_active IS NULL OR is_active = 1 ORDER BY topic_name");
}
__name(listTopicOptions, "listTopicOptions");
async function listPartnerOptions(env2) {
  return query(
    env2.DB,
    "SELECT partner_personality_id, partner_personality, description FROM partner_personality ORDER BY partner_personality"
  );
}
__name(listPartnerOptions, "listPartnerOptions");
async function listScheduleOptions(env2) {
  return query(env2.DB, "SELECT schedule_id, day_of_week, schedule_name, time_slot FROM schedule ORDER BY schedule_id");
}
__name(listScheduleOptions, "listScheduleOptions");
async function listGroupSizeOptions(env2) {
  return query(
    env2.DB,
    "SELECT group_size_id, group_size FROM group_size ORDER BY group_size_id"
  );
}
__name(listGroupSizeOptions, "listGroupSizeOptions");
var DEFAULT_COMMUNICATION_METHODS = [
  {
    id: 1,
    code: "TEXT",
    displayName: "\uD14D\uC2A4\uD2B8 \uC911\uC2EC",
    description: "\uCC44\uD305\uC744 \uC704\uC8FC\uB85C \uD559\uC2B5\uD569\uB2C8\uB2E4.",
    sortOrder: 1
  },
  {
    id: 2,
    code: "VOICE",
    displayName: "\uC74C\uC131 \uC911\uC2EC",
    description: "\uC74C\uC131 \uD1B5\uD654\uB97C \uC911\uC2EC\uC73C\uB85C \uC5F0\uC2B5\uD569\uB2C8\uB2E4.",
    sortOrder: 2
  },
  {
    id: 3,
    code: "VIDEO",
    displayName: "\uC601\uC0C1 \uD1B5\uD654",
    description: "\uC601\uC0C1 \uD1B5\uD654\uB85C \uC2E4\uC2DC\uAC04 \uB300\uD654\uB97C \uC9C4\uD589\uD569\uB2C8\uB2E4.",
    sortOrder: 3
  },
  {
    id: 4,
    code: "HYBRID",
    displayName: "\uC0C1\uD669\uC5D0 \uB9DE\uAC8C",
    description: "\uC0C1\uD669\uC5D0 \uB530\uB77C \uD14D\uC2A4\uD2B8\uC640 \uC74C\uC131\uC744 \uD63C\uD569\uD569\uB2C8\uB2E4.",
    sortOrder: 4
  }
];
function normalizeCommunicationMethods(rows) {
  if (!rows.length) {
    return DEFAULT_COMMUNICATION_METHODS.map((item) => ({ ...item }));
  }
  return rows.map((row, index) => {
    const code = (row.method_code ?? "").trim().toUpperCase();
    if (!code) {
      return null;
    }
    return {
      id: row.communication_method_id ?? index + 1,
      code,
      displayName: row.display_name?.trim() || code,
      description: row.description ?? null,
      sortOrder: row.sort_order ?? index + 1
    };
  }).filter((item) => item !== null).sort((a, b) => {
    if (a.sortOrder === b.sortOrder) {
      return a.id - b.id;
    }
    return a.sortOrder - b.sortOrder;
  });
}
__name(normalizeCommunicationMethods, "normalizeCommunicationMethods");
async function listCommunicationMethodOptions(env2) {
  try {
    const rows = await query(
      env2.DB,
      `SELECT communication_method_id, method_code, display_name, description, sort_order, is_active
       FROM communication_method
       WHERE is_active IS NULL OR is_active = 1
       ORDER BY
         CASE WHEN sort_order IS NULL THEN 1 ELSE 0 END,
         sort_order,
         communication_method_id`
    );
    return normalizeCommunicationMethods(rows);
  } catch (error48) {
    console.warn("[onboarding] communication_method table unavailable, falling back to defaults", error48);
    return DEFAULT_COMMUNICATION_METHODS.map((item) => ({ ...item }));
  }
}
__name(listCommunicationMethodOptions, "listCommunicationMethodOptions");
var DEFAULT_DAILY_MINUTE_OPTIONS = [
  {
    code: "MINUTES_10",
    displayName: "10\uBD84",
    minutes: 10,
    description: "\uD558\uB8E8 10\uBD84 \uD559\uC2B5",
    sortOrder: 1
  },
  {
    code: "MINUTES_15",
    displayName: "15\uBD84",
    minutes: 15,
    description: "\uD558\uB8E8 15\uBD84 \uD559\uC2B5",
    sortOrder: 2
  },
  {
    code: "MINUTES_20",
    displayName: "20\uBD84",
    minutes: 20,
    description: "\uD558\uB8E8 20\uBD84 \uD559\uC2B5",
    sortOrder: 3
  },
  {
    code: "MINUTES_25",
    displayName: "25\uBD84",
    minutes: 25,
    description: "\uD558\uB8E8 25\uBD84 \uD559\uC2B5",
    sortOrder: 4
  },
  {
    code: "MINUTES_30",
    displayName: "30\uBD84",
    minutes: 30,
    description: "\uD558\uB8E8 30\uBD84 \uD559\uC2B5",
    sortOrder: 5
  }
];
async function fetchDailyMinuteRows(env2) {
  try {
    const table3 = await query(
      env2.DB,
      "SELECT name FROM sqlite_master WHERE type = 'table' AND name IN (?, ?)",
      ["daily_minute_option", "daily_minute"]
    );
    if (!table3.length) {
      return [];
    }
    const tableName = table3[0]?.name ?? "daily_minute_option";
    try {
      return await query(
        env2.DB,
        `SELECT
           COALESCE(method_code, code) AS code,
           COALESCE(display_name, name) AS display_name,
           minutes,
           description,
           sort_order
         FROM ${tableName}
         WHERE is_active IS NULL OR is_active = 1
         ORDER BY
           CASE WHEN sort_order IS NULL THEN 1 ELSE 0 END,
           sort_order,
           COALESCE(method_code, code, display_name)`
      );
    } catch (error48) {
      console.warn("[onboarding] daily_minute columns unavailable, falling back to defaults", error48);
      return [];
    }
  } catch (error48) {
    console.warn("[onboarding] daily_minute table unavailable, falling back to defaults", error48);
    return [];
  }
}
__name(fetchDailyMinuteRows, "fetchDailyMinuteRows");
async function listDailyMinuteOptions(env2) {
  const rows = await fetchDailyMinuteRows(env2);
  if (!rows.length) {
    return DEFAULT_DAILY_MINUTE_OPTIONS.map((item) => ({ ...item }));
  }
  return rows.map((row, index) => {
    const code = (row.code ?? "").trim().toUpperCase();
    if (!code) {
      return null;
    }
    return {
      code,
      displayName: row.display_name?.trim() || code,
      minutes: Number.isFinite(row.minutes) ? Number(row.minutes) : DEFAULT_DAILY_MINUTE_OPTIONS[index % DEFAULT_DAILY_MINUTE_OPTIONS.length].minutes,
      description: row.description ?? null,
      sortOrder: row.sort_order ?? index + 1
    };
  }).filter((item) => item !== null).sort((a, b) => {
    if (a.sortOrder === b.sortOrder) {
      return a.minutes - b.minutes;
    }
    return a.sortOrder - b.sortOrder;
  });
}
__name(listDailyMinuteOptions, "listDailyMinuteOptions");
async function listMotivationOptions(env2) {
  return query(
    env2.DB,
    "SELECT motivation_id, motivation_name, description FROM motivation WHERE is_active IS NULL OR is_active = 1 ORDER BY motivation_name"
  );
}
__name(listMotivationOptions, "listMotivationOptions");
async function listLearningStyleOptions(env2) {
  return query(
    env2.DB,
    "SELECT learning_style_id, learning_style_name, description FROM learning_style WHERE is_active IS NULL OR is_active = 1 ORDER BY learning_style_id"
  );
}
__name(listLearningStyleOptions, "listLearningStyleOptions");
async function listLearningExpectationOptions(env2) {
  return query(
    env2.DB,
    "SELECT learning_expectation_id, learning_expectation_name, description FROM learning_expectation WHERE is_active IS NULL OR is_active = 1 ORDER BY learning_expectation_id"
  );
}
__name(listLearningExpectationOptions, "listLearningExpectationOptions");
async function upsertOnboardingLanguages(env2, userId, payload) {
  await transaction(
    env2.DB,
    [
      { sql: "DELETE FROM onboarding_lang_level WHERE user_id = ?", params: [userId] },
      ...payload.map((item) => ({
        sql: `INSERT INTO onboarding_lang_level (user_id, language_id, current_level_id, target_level_id, created_at, updated_at)
              VALUES (?, ?, ?, ?, ?, ?)`,
        params: [
          userId,
          item.languageId,
          item.currentLevelId ?? null,
          item.targetLevelId ?? null,
          (/* @__PURE__ */ new Date()).toISOString(),
          (/* @__PURE__ */ new Date()).toISOString()
        ]
      }))
    ]
  );
}
__name(upsertOnboardingLanguages, "upsertOnboardingLanguages");
async function upsertOnboardingTopics(env2, userId, topicIds) {
  await transaction(
    env2.DB,
    [
      { sql: "DELETE FROM onboarding_topic WHERE user_id = ?", params: [userId] },
      ...topicIds.map((topicId) => ({
        sql: "INSERT INTO onboarding_topic (user_id, topic_id, created_at) VALUES (?, ?, ?)",
        params: [userId, topicId, (/* @__PURE__ */ new Date()).toISOString()]
      }))
    ]
  );
}
__name(upsertOnboardingTopics, "upsertOnboardingTopics");
async function upsertOnboardingPartner(env2, userId, preferences) {
  await transaction(
    env2.DB,
    [
      { sql: "DELETE FROM onboarding_partner WHERE user_id = ?", params: [userId] },
      ...preferences.map((pref) => ({
        sql: "INSERT INTO onboarding_partner (user_id, partner_personality_id, partner_gender, created_at) VALUES (?, ?, ?, ?)",
        params: [userId, pref.partnerPersonalityId, pref.partnerGender ?? null, (/* @__PURE__ */ new Date()).toISOString()]
      }))
    ]
  );
}
__name(upsertOnboardingPartner, "upsertOnboardingPartner");
async function upsertOnboardingSchedules(env2, userId, schedules) {
  await transaction(
    env2.DB,
    [
      { sql: "DELETE FROM onboarding_schedule WHERE user_id = ?", params: [userId] },
      ...schedules.map((item) => ({
        sql: `INSERT INTO onboarding_schedule (user_id, schedule_id, day_of_week, class_time, is_available, created_at)
              VALUES (?, ?, ?, ?, 1, ?)`,
        params: [userId, item.scheduleId, item.dayOfWeek, item.classTime ?? null, (/* @__PURE__ */ new Date()).toISOString()]
      }))
    ]
  );
}
__name(upsertOnboardingSchedules, "upsertOnboardingSchedules");
async function upsertOnboardingGroupSizes(env2, userId, groupSizeIds) {
  const normalized = Array.from(new Set(groupSizeIds.map((value) => Number(value)))).filter((value) => Number.isFinite(value));
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  const operations = [
    { sql: "DELETE FROM onboarding_group_size WHERE user_id = ?", params: [userId] },
    ...normalized.map((groupSizeId) => ({
      sql: "INSERT INTO onboarding_group_size (user_id, group_size_id, created_at) VALUES (?, ?, ?)",
      params: [userId, groupSizeId, timestamp]
    }))
  ];
  await transaction(env2.DB, operations);
}
__name(upsertOnboardingGroupSizes, "upsertOnboardingGroupSizes");
async function upsertOnboardingMotivations(env2, userId, motivations) {
  await transaction(
    env2.DB,
    [
      { sql: "DELETE FROM onboarding_motivation WHERE user_id = ?", params: [userId] },
      ...motivations.map((item) => ({
        sql: "INSERT INTO onboarding_motivation (user_id, motivation_id, priority, created_at) VALUES (?, ?, ?, ?)",
        params: [userId, item.motivationId, item.priority ?? null, (/* @__PURE__ */ new Date()).toISOString()]
      }))
    ]
  );
}
__name(upsertOnboardingMotivations, "upsertOnboardingMotivations");
async function upsertOnboardingLearningStyles(env2, userId, learningStyleIds) {
  const normalized = Array.from(new Set(learningStyleIds.map((value) => Number(value)))).filter((value) => Number.isFinite(value));
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  const operations = [
    { sql: "DELETE FROM onboarding_learning_style WHERE user_id = ?", params: [userId] },
    ...normalized.map((learningStyleId) => ({
      sql: "INSERT INTO onboarding_learning_style (user_id, learning_style_id, created_at) VALUES (?, ?, ?)",
      params: [userId, learningStyleId, timestamp]
    }))
  ];
  await transaction(env2.DB, operations);
}
__name(upsertOnboardingLearningStyles, "upsertOnboardingLearningStyles");
async function upsertOnboardingLearningExpectations(env2, userId, learningExpectationIds) {
  const normalized = Array.from(new Set(learningExpectationIds.map((value) => Number(value)))).filter((value) => Number.isFinite(value));
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  const operations = [
    { sql: "DELETE FROM onboarding_learning_expectation WHERE user_id = ?", params: [userId] },
    ...normalized.map((learningExpectationId, index) => ({
      sql: "INSERT INTO onboarding_learning_expectation (user_id, learning_expectation_id, priority, created_at) VALUES (?, ?, ?, ?)",
      params: [userId, learningExpectationId, index + 1, timestamp]
    }))
  ];
  await transaction(env2.DB, operations);
}
__name(upsertOnboardingLearningExpectations, "upsertOnboardingLearningExpectations");
async function loadOnboardingSummary(env2, userId) {
  const [
    languagesResult,
    topicsResult,
    motivationsResult,
    learningStylesResult,
    groupSizesResult,
    partnersResult,
    schedulesResult
  ] = await env2.DB.batch([
    env2.DB.prepare(
      "SELECT language_id, current_level_id, target_level_id FROM onboarding_lang_level WHERE user_id = ?"
    ).bind(userId),
    env2.DB.prepare("SELECT topic_id FROM onboarding_topic WHERE user_id = ?").bind(userId),
    env2.DB.prepare("SELECT motivation_id, priority FROM onboarding_motivation WHERE user_id = ?").bind(userId),
    env2.DB.prepare("SELECT learning_style_id FROM onboarding_learning_style WHERE user_id = ?").bind(userId),
    env2.DB.prepare("SELECT group_size_id FROM onboarding_group_size WHERE user_id = ?").bind(userId),
    env2.DB.prepare(
      "SELECT partner_personality_id, partner_gender FROM onboarding_partner WHERE user_id = ?"
    ).bind(userId),
    env2.DB.prepare(
      "SELECT schedule_id, day_of_week, class_time FROM onboarding_schedule WHERE user_id = ?"
    ).bind(userId)
  ]);
  const languages = languagesResult.results ?? [];
  const topics = topicsResult.results ?? [];
  const motivations = motivationsResult.results ?? [];
  const learningStyles = learningStylesResult.results ?? [];
  const groupSizes = groupSizesResult.results ?? [];
  const partners = partnersResult.results ?? [];
  const scheduleRows = schedulesResult.results ?? [];
  const profile3 = await getUserProfile(env2, userId);
  return {
    languages: languages.map((item) => ({
      languageId: item.language_id,
      currentLevelId: item.current_level_id ?? void 0,
      targetLevelId: item.target_level_id ?? void 0
    })),
    topics: topics.map((item) => item.topic_id),
    motivations: motivations.map((item) => ({
      motivationId: item.motivation_id,
      priority: item.priority ?? void 0
    })),
    learningStyles: learningStyles.map((item) => item.learning_style_id),
    groupSizes: groupSizes.map((item) => item.group_size_id),
    partnerPreferences: partners.map((item) => ({
      partnerPersonalityId: item.partner_personality_id,
      partnerGender: item.partner_gender ?? void 0
    })),
    schedules: scheduleRows.map((item) => ({
      scheduleId: item.schedule_id,
      dayOfWeek: item.day_of_week,
      classTime: item.class_time ?? void 0
    })),
    communicationMethod: profile3?.communicationMethod ?? void 0
  };
}
__name(loadOnboardingSummary, "loadOnboardingSummary");
async function completeOnboarding(env2, userId, payload = {}) {
  if (payload.targetLanguages) {
    await upsertOnboardingLanguages(env2, userId, payload.targetLanguages);
  }
  if (payload.topicIds) {
    await upsertOnboardingTopics(env2, userId, payload.topicIds);
  }
  if (payload.motivationIds) {
    await upsertOnboardingMotivations(
      env2,
      userId,
      payload.motivationIds.map((id, index) => ({ motivationId: id, priority: index + 1 }))
    );
  }
  if (payload.partnerPersonalityIds) {
    const preferences = payload.partnerPersonalityIds.map(
      (item) => typeof item === "number" ? { partnerPersonalityId: item } : item
    );
    await upsertOnboardingPartner(env2, userId, preferences);
  }
  if (payload.groupSizeIds) {
    await upsertOnboardingGroupSizes(env2, userId, payload.groupSizeIds);
  }
  if (payload.scheduleIds) {
    const schedules = payload.scheduleIds.map(
      (item) => typeof item === "number" ? { scheduleId: item, dayOfWeek: "UNKNOWN", classTime: null } : item
    );
    await upsertOnboardingSchedules(env2, userId, schedules);
  }
  if (payload.learningStyleIds) {
    await upsertOnboardingLearningStyles(env2, userId, payload.learningStyleIds);
  }
  if (payload.learningExpectationIds) {
    await upsertOnboardingLearningExpectations(env2, userId, payload.learningExpectationIds);
  }
  const profileUpdates = {
    nativeLanguageId: payload.nativeLanguageId ?? null,
    onboardingCompleted: true
  };
  if (typeof payload.communicationMethod === "string" && payload.communicationMethod.trim()) {
    profileUpdates.communicationMethod = payload.communicationMethod.trim().toUpperCase();
  }
  await updateUserProfile(env2, userId, profileUpdates);
}
__name(completeOnboarding, "completeOnboarding");

// src/routes/users.ts
function toUpdatePayload(body) {
  const payload = {};
  if (typeof body.name === "string") payload.name = body.name.trim();
  if (typeof body.englishName === "string") payload.englishName = body.englishName.trim();
  if (typeof body.selfBio === "string") payload.selfBio = body.selfBio.trim();
  if (typeof body.gender === "string") payload.gender = body.gender;
  if (typeof body.birthday === "string") payload.birthday = body.birthday;
  if (typeof body.birthyear === "string") payload.birthyear = body.birthyear;
  if (typeof body.communicationMethod === "string") payload.communicationMethod = body.communicationMethod;
  if (typeof body.dailyMinute === "string") payload.dailyMinute = body.dailyMinute;
  if (typeof body.partnerGender === "string") payload.partnerGender = body.partnerGender;
  if (typeof body.learningExpectation === "string") payload.learningExpectation = body.learningExpectation;
  if (typeof body.onboardingCompleted === "boolean") payload.onboardingCompleted = body.onboardingCompleted;
  const locationId = typeof body.locationId === "number" ? body.locationId : typeof body.location === "object" && body.location !== null && typeof body.location.id === "number" ? body.location.id : void 0;
  if (locationId !== void 0) payload.locationId = locationId;
  const nativeLanguageId = typeof body.nativeLanguageId === "number" ? body.nativeLanguageId : typeof body.nativeLanguage === "object" && body.nativeLanguage !== null && typeof body.nativeLanguage.id === "number" ? body.nativeLanguage.id : void 0;
  if (nativeLanguageId !== void 0) payload.nativeLanguageId = nativeLanguageId;
  return payload;
}
__name(toUpdatePayload, "toUpdatePayload");
async function processProfileImageUpload(c, userId) {
  const contentType = c.req.header("Content-Type");
  if (!contentType?.startsWith("multipart/form-data")) {
    throw new AppError("multipart/form-data required", 400, "INVALID_CONTENT_TYPE");
  }
  const formData = await c.req.formData();
  const fileEntry = formData.get("file") ?? formData.get("image");
  if (!fileEntry || typeof fileEntry === "string") {
    throw new AppError("image field required", 400, "INVALID_FORM_DATA");
  }
  const uploadFile = fileEntry;
  const arrayBuffer = await uploadFile.arrayBuffer();
  return saveProfileImage(
    c.env,
    userId,
    uploadFile.name,
    uploadFile.type || "application/octet-stream",
    arrayBuffer
  );
}
__name(processProfileImageUpload, "processProfileImageUpload");
var usersRoutes = new Hono2();
var requireAuth = auth();
var wrapError = /* @__PURE__ */ __name((error48, feature) => {
  if (error48 instanceof AppError) {
    return error48;
  }
  const message = error48 instanceof Error ? error48.message : `${feature} failed`;
  return new AppError(message, 500, "USER_OPERATION_FAILED");
}, "wrapError");
async function buildLanguageInfo(env2, userId) {
  const [profile3, summary, languageOptions] = await Promise.all([
    getUserProfile(env2, userId),
    loadOnboardingSummary(env2, userId),
    listLanguageOptions(env2)
  ]);
  const languageMap = new Map(
    languageOptions.map((item) => [item.language_id, item])
  );
  const nativeLanguageId = profile3?.nativeLanguage?.id ?? (summary.languages.length > 0 ? summary.languages[0].languageId : void 0);
  const nativeLanguage = nativeLanguageId ? {
    languageId: nativeLanguageId,
    languageName: languageMap.get(nativeLanguageId)?.language_name ?? null,
    languageCode: languageMap.get(nativeLanguageId)?.language_code ?? null
  } : null;
  const targetLanguages = summary.languages.filter((item) => item.languageId !== nativeLanguageId).map((item) => ({
    languageId: item.languageId,
    languageName: languageMap.get(item.languageId)?.language_name ?? null,
    currentLevelId: item.currentLevelId ?? void 0,
    targetLevelId: item.targetLevelId ?? void 0
  }));
  return {
    nativeLanguage,
    targetLanguages
  };
}
__name(buildLanguageInfo, "buildLanguageInfo");
async function buildMotivationInfo(env2, userId) {
  const [summary, motivationOptions, topicOptions] = await Promise.all([
    loadOnboardingSummary(env2, userId),
    listMotivationOptions(env2),
    listTopicOptions(env2)
  ]);
  const motivationMap = new Map(motivationOptions.map((item) => [item.motivation_id, item.motivation_name]));
  const topicMap = new Map(topicOptions.map((item) => [item.topic_id, item.topic_name]));
  return {
    motivations: summary.motivations.map((item) => ({
      motivationId: item.motivationId,
      priority: item.priority,
      name: motivationMap.get(item.motivationId) ?? null
    })),
    topics: summary.topics.map((id) => ({
      topicId: id,
      name: topicMap.get(id) ?? null
    }))
  };
}
__name(buildMotivationInfo, "buildMotivationInfo");
async function buildPartnerInfo(env2, userId) {
  const summary = await loadOnboardingSummary(env2, userId);
  return {
    partners: summary.partnerPreferences,
    groupSizes: summary.groupSizes
  };
}
__name(buildPartnerInfo, "buildPartnerInfo");
async function buildScheduleInfo(env2, userId) {
  const summary = await loadOnboardingSummary(env2, userId);
  return {
    schedules: summary.schedules
  };
}
__name(buildScheduleInfo, "buildScheduleInfo");
usersRoutes.use("*", requireAuth);
usersRoutes.get("/me/profile", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const profile3 = await getUserProfile(c.env, userId);
    if (!profile3) {
      throw new AppError("User not found", 404, "USER_NOT_FOUND");
    }
    return successResponse(c, profile3);
  } catch (error48) {
    throw wrapError(error48, "GET /api/v1/users/me/profile");
  }
});
usersRoutes.get("/profile", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const profile3 = await getUserProfile(c.env, userId);
    if (!profile3) {
      throw new AppError("User not found", 404, "USER_NOT_FOUND");
    }
    return successResponse(c, profile3);
  } catch (error48) {
    throw wrapError(error48, "GET /api/v1/user/profile");
  }
});
usersRoutes.put("/me/profile", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  const body = await c.req.json();
  const payload = toUpdatePayload(body);
  try {
    const profile3 = await updateUserProfile(c.env, userId, payload);
    return successResponse(c, profile3);
  } catch (error48) {
    throw wrapError(error48, "PUT /api/v1/users/me/profile");
  }
});
usersRoutes.patch("/profile", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  const body = await c.req.json();
  const payload = toUpdatePayload(body);
  try {
    const profile3 = await updateUserProfile(c.env, userId, payload);
    return successResponse(c, profile3);
  } catch (error48) {
    throw wrapError(error48, "PATCH /api/v1/user/profile");
  }
});
usersRoutes.get("/complete-profile", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const profile3 = await getUserProfile(c.env, userId);
    return successResponse(c, profile3);
  } catch (error48) {
    throw wrapError(error48, "GET /api/v1/user/complete-profile");
  }
});
usersRoutes.put("/complete-profile", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  const body = await c.req.json();
  const payload = toUpdatePayload(body);
  try {
    const profile3 = await updateUserProfile(c.env, userId, payload);
    return successResponse(c, profile3);
  } catch (error48) {
    throw wrapError(error48, "PUT /api/v1/user/complete-profile");
  }
});
usersRoutes.get("/me/settings", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const settings = await getUserSettings(c.env, userId);
    return successResponse(c, settings);
  } catch (error48) {
    throw wrapError(error48, "GET /api/v1/users/me/settings");
  }
});
usersRoutes.get("/settings", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const settings = await getUserSettings(c.env, userId);
    return successResponse(c, settings);
  } catch (error48) {
    throw wrapError(error48, "GET /api/v1/user/settings");
  }
});
usersRoutes.put("/me/settings", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  const body = await c.req.json();
  try {
    const settings = await updateUserSettings(c.env, userId, body);
    return successResponse(c, settings);
  } catch (error48) {
    throw wrapError(error48, "PUT /api/v1/users/me/settings");
  }
});
usersRoutes.put("/settings", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  const body = await c.req.json();
  try {
    const settings = await updateUserSettings(c.env, userId, body);
    return successResponse(c, settings);
  } catch (error48) {
    throw wrapError(error48, "PUT /api/v1/user/settings");
  }
});
usersRoutes.post("/me/profile-image", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const location = await processProfileImageUpload(c, userId);
    return successResponse(c, { url: location });
  } catch (error48) {
    throw wrapError(error48, "POST /api/v1/users/me/profile-image");
  }
});
usersRoutes.get("/language-info", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const info3 = await buildLanguageInfo(c.env, userId);
    return successResponse(c, info3);
  } catch (error48) {
    throw wrapError(error48, "GET /api/v1/user/language-info");
  }
});
usersRoutes.patch("/language-info", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  const body = await c.req.json();
  const languages = Array.isArray(body?.languages) ? body.languages : [];
  const languagePayload = [];
  for (const raw2 of languages) {
    const languageId = Number(raw2.languageId ?? raw2.language_id);
    if (!Number.isFinite(languageId)) {
      continue;
    }
    languagePayload.push({
      languageId,
      currentLevelId: raw2.currentLevelId ?? raw2.current_level_id ?? void 0,
      targetLevelId: raw2.targetLevelId ?? raw2.target_level_id ?? void 0
    });
  }
  await upsertOnboardingLanguages(c.env, userId, languagePayload);
  if (Number.isFinite(body?.nativeLanguageId)) {
    await updateUserProfile(c.env, userId, { nativeLanguageId: Number(body.nativeLanguageId) });
  }
  const info3 = await buildLanguageInfo(c.env, userId);
  return successResponse(c, info3);
});
usersRoutes.get("/motivation-info", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const info3 = await buildMotivationInfo(c.env, userId);
    return successResponse(c, info3);
  } catch (error48) {
    throw wrapError(error48, "GET /api/v1/user/motivation-info");
  }
});
usersRoutes.patch("/motivation-info", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  const body = await c.req.json();
  const motivationIds = Array.isArray(body?.motivationIds) ? body.motivationIds : [];
  const motivationPayload = [];
  motivationIds.forEach((raw2, index) => {
    const motivationId = Number(raw2);
    if (!Number.isFinite(motivationId)) {
      return;
    }
    motivationPayload.push({
      motivationId,
      priority: index + 1
    });
  });
  await upsertOnboardingMotivations(c.env, userId, motivationPayload);
  const info3 = await buildMotivationInfo(c.env, userId);
  return successResponse(c, info3);
});
usersRoutes.get("/partner-info", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const info3 = await buildPartnerInfo(c.env, userId);
    return successResponse(c, info3);
  } catch (error48) {
    throw wrapError(error48, "GET /api/v1/user/partner-info");
  }
});
usersRoutes.patch("/partner-info", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  const body = await c.req.json();
  const preferences = Array.isArray(body?.partnerPreferences) ? body.partnerPreferences : [];
  const partnerPayload = [];
  preferences.forEach((raw2) => {
    const partnerPersonalityId = Number(raw2.partnerPersonalityId ?? raw2.partner_personality_id ?? raw2);
    if (!Number.isFinite(partnerPersonalityId)) {
      return;
    }
    partnerPayload.push({
      partnerPersonalityId,
      partnerGender: raw2.partnerGender ?? raw2.partner_gender ?? void 0
    });
  });
  await upsertOnboardingPartner(c.env, userId, partnerPayload);
  const info3 = await buildPartnerInfo(c.env, userId);
  return successResponse(c, info3);
});
usersRoutes.get("/schedule-info", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const info3 = await buildScheduleInfo(c.env, userId);
    return successResponse(c, info3);
  } catch (error48) {
    throw wrapError(error48, "GET /api/v1/user/schedule-info");
  }
});
usersRoutes.patch("/schedule-info", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  const body = await c.req.json();
  const schedules = Array.isArray(body?.schedules) ? body.schedules : [];
  const normalized = [];
  schedules.forEach((raw2) => {
    const scheduleId = Number(raw2.scheduleId ?? raw2.schedule_id);
    if (!Number.isFinite(scheduleId)) {
      return;
    }
    normalized.push({
      scheduleId,
      dayOfWeek: raw2.dayOfWeek ?? raw2.day_of_week ?? "UNKNOWN",
      classTime: raw2.classTime ?? raw2.class_time ?? void 0
    });
  });
  await upsertOnboardingSchedules(c.env, userId, normalized);
  const info3 = await buildScheduleInfo(c.env, userId);
  return successResponse(c, info3);
});
usersRoutes.get("/me/profile-image", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const profile3 = await getUserProfile(c.env, userId);
    if (!profile3) {
      throw new AppError("User not found", 404, "USER_NOT_FOUND");
    }
    return successResponse(c, { profileImage: profile3.profileImage });
  } catch (error48) {
    throw wrapError(error48, "GET /api/v1/users/me/profile-image");
  }
});
usersRoutes.post("/profile-image", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const location = await processProfileImageUpload(c, userId);
    return successResponse(c, { url: location });
  } catch (error48) {
    throw wrapError(error48, "POST /api/v1/user/profile-image");
  }
});
usersRoutes.post("/profile/image", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const location = await processProfileImageUpload(c, userId);
    return successResponse(c, { url: location });
  } catch (error48) {
    throw wrapError(error48, "POST /api/v1/users/profile/image");
  }
});
usersRoutes.delete("/profile-image", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    await deleteProfileImage(c.env, userId);
    return successResponse(c, { success: true });
  } catch (error48) {
    throw wrapError(error48, "DELETE /api/v1/user/profile-image");
  }
});
usersRoutes.delete("/profile/image", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    await deleteProfileImage(c.env, userId);
    return successResponse(c, { success: true });
  } catch (error48) {
    throw wrapError(error48, "DELETE /api/v1/users/profile/image");
  }
});
usersRoutes.get("/profile-image", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const profile3 = await getUserProfile(c.env, userId);
    if (!profile3) {
      throw new AppError("User not found", 404, "USER_NOT_FOUND");
    }
    return successResponse(c, { profileImage: profile3.profileImage });
  } catch (error48) {
    throw wrapError(error48, "GET /api/v1/user/profile-image");
  }
});
usersRoutes.get("/me/name", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const profile3 = await getUserProfile(c.env, userId);
    if (!profile3) {
      throw new AppError("User not found", 404, "USER_NOT_FOUND");
    }
    return successResponse(c, { name: profile3.name });
  } catch (error48) {
    throw wrapError(error48, "GET /api/v1/users/me/name");
  }
});
usersRoutes.get("/info", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const profile3 = await getUserProfile(c.env, userId);
    if (!profile3) {
      throw new AppError("User not found", 404, "USER_NOT_FOUND");
    }
    return successResponse(c, {
      id: profile3.id,
      email: profile3.email,
      englishName: profile3.englishName,
      name: profile3.name,
      onboardingCompleted: profile3.onboardingCompleted
    });
  } catch (error48) {
    throw wrapError(error48, "GET /api/v1/user/info");
  }
});
usersRoutes.get("/name", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const profile3 = await getUserProfile(c.env, userId);
    if (!profile3) {
      throw new AppError("User not found", 404, "USER_NOT_FOUND");
    }
    return successResponse(c, { name: profile3.name ?? profile3.englishName });
  } catch (error48) {
    throw wrapError(error48, "GET /api/v1/user/name");
  }
});
usersRoutes.get("/me/onboarding-status", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  try {
    const profile3 = await getUserProfile(c.env, userId);
    if (!profile3) {
      throw new AppError("User not found", 404, "USER_NOT_FOUND");
    }
    return successResponse(c, { completed: profile3.onboardingCompleted });
  } catch (error48) {
    throw wrapError(error48, "GET /api/v1/users/me/onboarding-status");
  }
});
usersRoutes.get("/onboarding-status", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  const profile3 = await getUserProfile(c.env, userId);
  if (!profile3) {
    throw new AppError("User not found", 404, "USER_NOT_FOUND");
  }
  return successResponse(c, { completed: profile3.onboardingCompleted });
});
usersRoutes.post("/complete-onboarding", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  const body = await c.req.json().catch(() => ({}));
  await completeOnboarding(c.env, userId, body ?? {});
  return successResponse(c, { completed: true });
});
usersRoutes.post("/me/english-name", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  if (typeof body.englishName !== "string" || !body.englishName.trim()) {
    throw new AppError("englishName is required", 400, "INVALID_PAYLOAD");
  }
  await updateUserProfile(c.env, userId, { englishName: body.englishName.trim() });
  return successResponse(c, { englishName: body.englishName.trim() });
});
usersRoutes.post("/english-name", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  if (typeof body.englishName !== "string" || !body.englishName.trim()) {
    throw new AppError("englishName is required", 400, "INVALID_PAYLOAD");
  }
  await updateUserProfile(c.env, userId, { englishName: body.englishName.trim() });
  return successResponse(c, { englishName: body.englishName.trim() });
});
usersRoutes.post("/me/birthyear", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  if (typeof body.birthyear !== "string" || !body.birthyear.trim()) {
    throw new AppError("birthyear is required", 400, "INVALID_PAYLOAD");
  }
  await updateUserProfile(c.env, userId, { birthyear: body.birthyear.trim() });
  return successResponse(c, { birthyear: body.birthyear.trim() });
});
usersRoutes.post("/birthyear", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  if (typeof body.birthYear !== "string" && typeof body.birthyear !== "string") {
    throw new AppError("birthyear is required", 400, "INVALID_PAYLOAD");
  }
  const value = (body.birthYear ?? body.birthyear).toString().trim();
  if (!value) {
    throw new AppError("birthyear is required", 400, "INVALID_PAYLOAD");
  }
  await updateUserProfile(c.env, userId, { birthyear: value });
  return successResponse(c, { birthyear: value });
});
usersRoutes.post("/me/birthday", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  if (typeof body.birthday !== "string" || !body.birthday.trim()) {
    throw new AppError("birthday is required", 400, "INVALID_PAYLOAD");
  }
  await updateUserProfile(c.env, userId, { birthday: body.birthday.trim() });
  return successResponse(c, { birthday: body.birthday.trim() });
});
usersRoutes.post("/birthday", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  const value = typeof body.birthday === "string" ? body.birthday.trim() : "";
  if (!value) {
    throw new AppError("birthday is required", 400, "INVALID_PAYLOAD");
  }
  await updateUserProfile(c.env, userId, { birthday: value });
  return successResponse(c, { birthday: value });
});
usersRoutes.post("/me/gender", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  if (typeof body.gender !== "string" || !body.gender.trim()) {
    throw new AppError("gender is required", 400, "INVALID_PAYLOAD");
  }
  await updateUserProfile(c.env, userId, { gender: body.gender.trim() });
  return successResponse(c, { gender: body.gender.trim() });
});
usersRoutes.post("/gender", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  const gender = (body.gender ?? body.genderType)?.toString().trim();
  if (!gender) {
    throw new AppError("gender is required", 400, "INVALID_PAYLOAD");
  }
  await updateUserProfile(c.env, userId, { gender });
  return successResponse(c, { gender });
});
usersRoutes.post("/me/self-bio", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  if (typeof body.selfBio !== "string") {
    throw new AppError("selfBio is required", 400, "INVALID_PAYLOAD");
  }
  await updateUserProfile(c.env, userId, { selfBio: body.selfBio });
  return successResponse(c, { selfBio: body.selfBio });
});
usersRoutes.post("/self-bio", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  const selfBio = typeof body.selfBio === "string" ? body.selfBio : "";
  await updateUserProfile(c.env, userId, { selfBio });
  return successResponse(c, { selfBio });
});
usersRoutes.post("/me/location", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  const locationId = typeof body.locationId === "number" ? body.locationId : void 0;
  if (locationId === void 0) {
    throw new AppError("locationId is required", 400, "INVALID_PAYLOAD");
  }
  await updateUserProfile(c.env, userId, { locationId });
  return successResponse(c, { locationId });
});
usersRoutes.post("/location", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  const locationId = Number(body.locationId ?? body.location_id);
  if (!Number.isFinite(locationId)) {
    throw new AppError("locationId is required", 400, "INVALID_PAYLOAD");
  }
  await updateUserProfile(c.env, userId, { locationId });
  return successResponse(c, { locationId });
});
usersRoutes.get("/stats", async (c) => {
  return successResponse(c, {
    sessionsThisWeek: 0,
    totalSessions: 0,
    totalMinutes: 0
  });
});
usersRoutes.delete("/account", async (c) => {
  return successResponse(c, {
    success: false,
    message: "Account deletion is not supported on the Workers API yet."
  });
});
usersRoutes.get("/gender-type", async (c) => {
  return successResponse(c, [
    { id: "MALE", name: "\uB0A8\uC131" },
    { id: "FEMALE", name: "\uC5EC\uC131" },
    { id: "OTHER", name: "\uAE30\uD0C0" }
  ]);
});
usersRoutes.get("/locations", async (c) => {
  try {
    const locations = await listLocations(c.env);
    return successResponse(c, locations);
  } catch (error48) {
    throw wrapError(error48, "GET /api/v1/users/locations");
  }
});
var users_default = usersRoutes;

// src/routes/onboarding.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_errors();

// src/services/onboardingState.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var PREFIX = "onboarding";
var STEP_PREFIX = `${PREFIX}:step`;
var PROGRESS_PREFIX = `${PREFIX}:progress`;
var SESSION_PREFIX = `${PREFIX}:session`;
var DEFAULT_STEP_TTL = 60 * 60 * 24 * 7;
var SESSION_TTL = 60 * 60 * 2;
function buildStepKey(userId, stepNumber) {
  return `${STEP_PREFIX}:${userId}:${stepNumber}`;
}
__name(buildStepKey, "buildStepKey");
function buildProgressKey(userId) {
  return `${PROGRESS_PREFIX}:${userId}`;
}
__name(buildProgressKey, "buildProgressKey");
function buildSessionKey(userId) {
  return `${SESSION_PREFIX}:${userId}`;
}
__name(buildSessionKey, "buildSessionKey");
async function saveOnboardingStep(env2, userId, stepNumber, payload, totalSteps, estimatedMinutesRemaining) {
  const stepKey = buildStepKey(userId, stepNumber);
  const nowIso7 = (/* @__PURE__ */ new Date()).toISOString();
  const stepData = {
    stepNumber,
    savedAt: nowIso7,
    isCompleted: true,
    payload
  };
  await env2.CACHE.put(stepKey, JSON.stringify(stepData), { expirationTtl: DEFAULT_STEP_TTL });
  await updateOnboardingProgress(env2, userId, stepNumber, totalSteps, estimatedMinutesRemaining);
}
__name(saveOnboardingStep, "saveOnboardingStep");
async function getOnboardingStep(env2, userId, stepNumber) {
  const raw2 = await env2.CACHE.get(buildStepKey(userId, stepNumber), { type: "json" });
  return raw2 ?? null;
}
__name(getOnboardingStep, "getOnboardingStep");
async function saveOnboardingSessionDraft(env2, userId, payload) {
  const draft = {
    lastAutoSavedAt: (/* @__PURE__ */ new Date()).toISOString(),
    payload
  };
  await env2.CACHE.put(buildSessionKey(userId), JSON.stringify(draft), { expirationTtl: SESSION_TTL });
}
__name(saveOnboardingSessionDraft, "saveOnboardingSessionDraft");
async function getOnboardingSessionDraft(env2, userId) {
  const raw2 = await env2.CACHE.get(buildSessionKey(userId), { type: "json" });
  return raw2 ?? null;
}
__name(getOnboardingSessionDraft, "getOnboardingSessionDraft");
async function clearOnboardingState(env2, userId) {
  const progressKey2 = buildProgressKey(userId);
  const list = await env2.CACHE.list({ prefix: `${STEP_PREFIX}:${userId}` });
  await Promise.all([
    env2.CACHE.delete(progressKey2),
    env2.CACHE.delete(buildSessionKey(userId)),
    ...list.keys.map((key) => env2.CACHE.delete(key.name))
  ]);
}
__name(clearOnboardingState, "clearOnboardingState");
async function getOnboardingProgress(env2, userId, totalSteps) {
  const progressKey2 = buildProgressKey(userId);
  const raw2 = await env2.CACHE.get(progressKey2, { type: "json" });
  if (raw2) {
    return raw2;
  }
  return {
    completedSteps: {},
    currentStep: 1,
    progressPercentage: 0,
    totalSteps,
    lastUpdatedAt: (/* @__PURE__ */ new Date()).toISOString(),
    completed: false
  };
}
__name(getOnboardingProgress, "getOnboardingProgress");
async function updateOnboardingProgress(env2, userId, completedStep, totalSteps, estimatedMinutesRemaining) {
  const progressKey2 = buildProgressKey(userId);
  const current = await getOnboardingProgress(env2, userId, totalSteps);
  const completedSteps = { ...current.completedSteps, [`step${completedStep}`]: true };
  const completedCount = Object.values(completedSteps).filter(Boolean).length;
  const progressPercentage = Math.min(completedCount / totalSteps * 100, 100);
  const progress = {
    completedSteps,
    currentStep: Math.min(completedStep + 1, totalSteps),
    progressPercentage,
    totalSteps,
    lastUpdatedAt: (/* @__PURE__ */ new Date()).toISOString(),
    completed: completedCount >= totalSteps,
    estimatedMinutesRemaining
  };
  await env2.CACHE.put(progressKey2, JSON.stringify(progress), {
    expirationTtl: DEFAULT_STEP_TTL
  });
}
__name(updateOnboardingProgress, "updateOnboardingProgress");
async function resetOnboardingProgress(env2, userId, totalSteps) {
  const progress = {
    completedSteps: {},
    currentStep: 1,
    progressPercentage: 0,
    totalSteps,
    lastUpdatedAt: (/* @__PURE__ */ new Date()).toISOString(),
    completed: false
  };
  await env2.CACHE.put(buildProgressKey(userId), JSON.stringify(progress), {
    expirationTtl: DEFAULT_STEP_TTL
  });
}
__name(resetOnboardingProgress, "resetOnboardingProgress");

// src/routes/onboarding.ts
var onboardingRoutes = new Hono2();
var requireAuth2 = auth();
var TOTAL_ONBOARDING_STEPS = 8;
var wrapError2 = /* @__PURE__ */ __name((error48, fallback) => {
  if (error48 instanceof AppError) {
    return error48;
  }
  const message = error48 instanceof Error ? error48.message : fallback;
  return new AppError(message, 500, "ONBOARDING_ERROR");
}, "wrapError");
function normalizeStepPayload(raw2) {
  if (raw2 && typeof raw2.stepData === "object" && raw2.stepData !== null) {
    return raw2.stepData;
  }
  return raw2;
}
__name(normalizeStepPayload, "normalizeStepPayload");
async function getStepPayload(env2, userId, step) {
  const record2 = await getOnboardingStep(env2, userId, step);
  return record2?.payload ?? null;
}
__name(getStepPayload, "getStepPayload");
async function buildOnboardingData(env2, userId) {
  const [
    profile3,
    step1,
    step2,
    step3,
    step4,
    progress,
    languages,
    motivations,
    topics,
    learningStyles,
    learningExpectations
  ] = await Promise.all([
    getUserProfile(env2, userId),
    getStepPayload(env2, userId, 1),
    getStepPayload(env2, userId, 2),
    getStepPayload(env2, userId, 3),
    getStepPayload(env2, userId, 4),
    getOnboardingProgress(env2, userId, TOTAL_ONBOARDING_STEPS),
    listLanguageOptions(env2),
    listMotivationOptions(env2),
    listTopicOptions(env2),
    listLearningStyleOptions(env2),
    listLearningExpectationOptions(env2)
  ]);
  const step1Payload = step1 ?? {};
  const step2Payload = step2 ?? {};
  const step3Payload = step3 ?? {};
  const step4Payload = step4 ?? {};
  const userOnboardingData = {
    englishName: step1Payload?.englishName ?? profile3?.englishName ?? profile3?.name,
    profileImageUrl: step1Payload?.profileImage ?? profile3?.profileImage,
    residence: step1Payload?.residence ?? profile3?.location?.country ?? null,
    intro: step1Payload?.intro ?? profile3?.selfBio ?? "",
    nativeLanguageId: step2Payload?.nativeLanguageId ?? step2Payload?.languageId ?? profile3?.nativeLanguage?.id ?? null,
    targetLanguages: step2Payload?.targetLanguages ?? [],
    motivationIds: step3Payload?.motivationIds ?? step3Payload?.motivations ?? [],
    topicIds: step4Payload?.topicIds ?? step3Payload?.topicIds ?? [],
    learningStyleIds: step4Payload?.learningStyleIds ?? [],
    learningExpectationIds: step4Payload?.learningExpectationIds ?? [],
    completed: progress.completed
  };
  return {
    userOnboardingData,
    availableOptions: {
      languages,
      motivations,
      topics,
      learningStyles: learningStyles.map((item) => ({
        id: item.learning_style_id,
        name: item.learning_style_name,
        description: item.description ?? void 0
      })),
      learningExpectations: learningExpectations.map((item) => ({
        id: item.learning_expectation_id,
        name: item.learning_expectation_name,
        description: item.description ?? void 0
      }))
    }
  };
}
__name(buildOnboardingData, "buildOnboardingData");
onboardingRoutes.get("/languages", async (c) => {
  try {
    const data = await listLanguageOptions(c.env);
    return successResponse(c, data);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load language options");
  }
});
onboardingRoutes.get("/language/languages", async (c) => {
  try {
    const data = await listLanguageOptions(c.env);
    return successResponse(c, data);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load language options");
  }
});
onboardingRoutes.get("/language/level-types-language", async (c) => {
  try {
    const rows = await listLanguageLevelTypes(c.env, "LANGUAGE");
    const data = rows.map((row) => ({
      id: row.lang_level_id,
      name: row.lang_level_name,
      description: row.description ?? void 0,
      category: row.category ?? void 0,
      order: row.level_order ?? void 0
    }));
    return successResponse(c, data);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load language level types");
  }
});
onboardingRoutes.get("/language/level-types-partner", async (c) => {
  try {
    const rows = await listLanguageLevelTypes(c.env, "PARTNER");
    const data = rows.map((row) => ({
      id: row.lang_level_id,
      name: row.lang_level_name,
      description: row.description ?? void 0,
      category: row.category ?? void 0,
      order: row.level_order ?? void 0
    }));
    return successResponse(c, data);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load partner level types");
  }
});
onboardingRoutes.get("/interests", async (c) => {
  try {
    const data = await listTopicOptions(c.env);
    return successResponse(c, data);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load interests");
  }
});
onboardingRoutes.get("/interest/motivations", async (c) => {
  try {
    const data = await listMotivationOptions(c.env);
    return successResponse(c, data);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load motivation options");
  }
});
onboardingRoutes.get("/interest/topics", async (c) => {
  try {
    const data = await listTopicOptions(c.env);
    return successResponse(c, data);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load interests");
  }
});
onboardingRoutes.get("/interest/learning-styles", async (c) => {
  try {
    const rows = await listLearningStyleOptions(c.env);
    const data = rows.map((item) => ({
      learningStyleId: item.learning_style_id,
      learningStyleName: item.learning_style_name,
      description: item.description ?? void 0
    }));
    return successResponse(c, data);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load learning style options");
  }
});
onboardingRoutes.get("/interest/learning-expectations", async (c) => {
  try {
    const rows = await listLearningExpectationOptions(c.env);
    const data = rows.map((item) => ({
      learningExpectationId: item.learning_expectation_id,
      learningExpectationName: item.learning_expectation_name,
      description: item.description ?? void 0
    }));
    return successResponse(c, data);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load learning expectation options");
  }
});
onboardingRoutes.get("/partner-preferences", async (c) => {
  try {
    const data = await listPartnerOptions(c.env);
    return successResponse(c, data);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load partner preferences");
  }
});
onboardingRoutes.get("/partner/personalities", async (c) => {
  try {
    const rows = await listPartnerOptions(c.env);
    const data = rows.map((item) => ({
      partnerPersonalityId: item.partner_personality_id,
      partnerPersonality: item.partner_personality,
      description: item.description ?? void 0,
      id: item.partner_personality_id,
      name: item.partner_personality
    }));
    return successResponse(c, data);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load partner personalities");
  }
});
onboardingRoutes.get("/partner/gender-type", async (c) => {
  const genderTypes = [
    { name: "MALE", description: "\uB0A8\uC131" },
    { name: "FEMALE", description: "\uC5EC\uC131" },
    { name: "ANY", description: "\uC0C1\uAD00\uC5C6\uC74C" }
  ];
  return successResponse(c, genderTypes);
});
onboardingRoutes.get("/schedule/communication-methods", async (c) => {
  try {
    const methods = await listCommunicationMethodOptions(c.env);
    const data = methods.map((item) => ({
      communicationMethodId: item.id,
      code: item.code,
      name: item.code,
      label: item.displayName,
      displayName: item.displayName,
      description: item.description ?? void 0,
      sortOrder: item.sortOrder
    }));
    return successResponse(c, data);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load communication methods");
  }
});
onboardingRoutes.get("/schedule/daily-methods", async (c) => {
  try {
    const options = await listDailyMinuteOptions(c.env);
    const data = options.map((item, index) => ({
      id: index + 1,
      name: item.code,
      code: item.code,
      minutes: item.minutes,
      label: item.displayName,
      displayName: item.displayName,
      description: item.description ?? item.displayName,
      sortOrder: item.sortOrder
    }));
    return successResponse(c, data);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load daily minute options");
  }
});
onboardingRoutes.get("/schedule-options", async (c) => {
  try {
    const data = await listScheduleOptions(c.env);
    return successResponse(c, data);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load schedule options");
  }
});
onboardingRoutes.get("/motivation-options", async (c) => {
  try {
    const data = await listMotivationOptions(c.env);
    return successResponse(c, data);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load motivation options");
  }
});
onboardingRoutes.use("/*", requireAuth2);
onboardingRoutes.use("/steps/*", requireAuth2);
onboardingRoutes.use("/steps", requireAuth2);
onboardingRoutes.get("/schedule/group-sizes", async (c) => {
  try {
    const rows = await listGroupSizeOptions(c.env);
    const data = rows.map((item) => ({
      groupSizeId: item.group_size_id,
      groupSize: item.group_size,
      id: item.group_size_id,
      name: item.group_size,
      label: item.group_size
    }));
    return successResponse(c, data);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load group size options");
  }
});
onboardingRoutes.post("/partner/gender", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  const body = await c.req.json().catch(() => ({}));
  const raw2 = typeof body.partnerGenderType === "string" ? body.partnerGenderType : typeof body.partnerGender === "string" ? body.partnerGender : typeof body.genderType === "string" ? body.genderType : void 0;
  if (!raw2) {
    throw new AppError("partner gender is required", 400, "INVALID_PAYLOAD");
  }
  const normalized = String(raw2).trim().toUpperCase();
  const allowed = /* @__PURE__ */ new Set(["MALE", "FEMALE", "ANY", "OTHER"]);
  if (!allowed.has(normalized)) {
    throw new AppError("invalid partner gender type", 400, "INVALID_PAYLOAD");
  }
  try {
    await updateUserProfile(c.env, userId, { partnerGender: normalized });
    const summary = await loadOnboardingSummary(c.env, userId);
    return successResponse(c, {
      partnerGender: normalized,
      partnerPreferences: summary.partnerPreferences
    });
  } catch (error48) {
    throw wrapError2(error48, "Failed to save partner gender");
  }
});
onboardingRoutes.post("/schedule/communication-method", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  const body = await c.req.json().catch(() => ({}));
  const raw2 = typeof body.communicationMethodType === "string" ? body.communicationMethodType : typeof body.communicationMethod === "string" ? body.communicationMethod : typeof body.methodCode === "string" ? body.methodCode : typeof body.code === "string" ? body.code : typeof body.value === "string" ? body.value : Array.isArray(body) && body.length > 0 && typeof body[0] === "string" ? body[0] : void 0;
  if (!raw2) {
    throw new AppError("communication method is required", 400, "INVALID_PAYLOAD");
  }
  const normalized = String(raw2).trim().toUpperCase();
  if (!normalized) {
    throw new AppError("communication method is required", 400, "INVALID_PAYLOAD");
  }
  const methods = await listCommunicationMethodOptions(c.env);
  const selected = methods.find((item) => item.code.toUpperCase() === normalized);
  if (!selected) {
    throw new AppError("invalid communication method", 400, "INVALID_COMMUNICATION_METHOD");
  }
  try {
    await updateUserProfile(c.env, userId, { communicationMethod: normalized });
    await saveOnboardingStep(c.env, userId, 5, { communicationMethod: normalized }, TOTAL_ONBOARDING_STEPS);
    const progress = await getOnboardingProgress(c.env, userId, TOTAL_ONBOARDING_STEPS);
    return successResponse(c, {
      communicationMethod: normalized,
      label: selected.displayName,
      progress
    });
  } catch (error48) {
    throw wrapError2(error48, "Failed to save communication method");
  }
});
onboardingRoutes.post("/schedule/daily-minute", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  const payload = await c.req.json().catch(() => ({}));
  const candidates = [];
  const pushCandidate = /* @__PURE__ */ __name((value) => {
    if (value === void 0 || value === null) {
      return;
    }
    if (Array.isArray(value)) {
      value.forEach((nested) => pushCandidate(nested));
      return;
    }
    candidates.push(value);
  }, "pushCandidate");
  const lookupKeys = [
    "dailyMinutesType",
    "dailyMinuteType",
    "dailyMinute",
    "dailyMinutes",
    "code",
    "value",
    "selection"
  ];
  for (const key of lookupKeys) {
    pushCandidate(payload?.[key]);
  }
  pushCandidate(payload);
  const stringCandidate = candidates.find(
    (item) => typeof item === "string" && item.trim().length > 0
  );
  const numericCandidate = candidates.find((item) => typeof item === "number" && Number.isFinite(item)) ?? (() => {
    if (!stringCandidate) {
      return void 0;
    }
    const maybeNumber = Number(stringCandidate.trim());
    return Number.isFinite(maybeNumber) ? maybeNumber : void 0;
  })();
  if (!stringCandidate && numericCandidate === void 0) {
    throw new AppError("daily minute selection is required", 400, "INVALID_PAYLOAD");
  }
  const options = await listDailyMinuteOptions(c.env);
  let selectedOption = void 0;
  if (stringCandidate) {
    const normalizedCode2 = stringCandidate.trim().toUpperCase();
    selectedOption = options.find((item) => item.code.toUpperCase() === normalizedCode2);
  }
  if (!selectedOption && numericCandidate !== void 0) {
    const normalizedMinutes = Math.round(numericCandidate);
    selectedOption = options.find((item) => item.minutes === normalizedMinutes);
  }
  if (!selectedOption) {
    throw new AppError("invalid daily minute option", 400, "INVALID_DAILY_MINUTE_OPTION");
  }
  const normalizedCode = selectedOption.code.toUpperCase();
  try {
    await updateUserProfile(c.env, userId, { dailyMinute: normalizedCode });
    await saveOnboardingStep(c.env, userId, 7, { dailyMinute: normalizedCode }, TOTAL_ONBOARDING_STEPS);
    const progress = await getOnboardingProgress(c.env, userId, TOTAL_ONBOARDING_STEPS);
    return successResponse(c, {
      dailyMinute: normalizedCode,
      minutes: selectedOption.minutes,
      label: selectedOption.displayName,
      description: selectedOption.description ?? void 0,
      progress
    });
  } catch (error48) {
    throw wrapError2(error48, "Failed to save daily minute preference");
  }
});
onboardingRoutes.post("/schedule/group-size", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  }
  const body = await c.req.json().catch(() => ({}));
  const candidates = Array.isArray(body) ? body : body.groupSizeIds ?? body.group_size_ids ?? body.ids ?? [];
  const normalized = Array.from(new Set((Array.isArray(candidates) ? candidates : []).map((value) => Number(value)))).filter((value) => Number.isFinite(value));
  if (!normalized.length) {
    throw new AppError("groupSizeIds array required", 400, "INVALID_PAYLOAD");
  }
  try {
    await upsertOnboardingGroupSizes(c.env, userId, normalized);
    await saveOnboardingStep(c.env, userId, 6, { groupSizeIds: normalized }, TOTAL_ONBOARDING_STEPS);
    const progress = await getOnboardingProgress(c.env, userId, TOTAL_ONBOARDING_STEPS);
    const summary = await loadOnboardingSummary(c.env, userId);
    return successResponse(c, {
      groupSizeIds: normalized,
      groupSizes: summary.groupSizes,
      progress
    });
  } catch (error48) {
    throw wrapError2(error48, "Failed to save group sizes");
  }
});
var STATIC_STEP_NUMBERS = [1, 2, 3, 4];
for (const staticStep of STATIC_STEP_NUMBERS) {
  onboardingRoutes.post(`/steps/${staticStep}/save`, async (c) => {
    const userId = c.get("userId");
    if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
    const payload = normalizeStepPayload(await c.req.json().catch(() => ({})));
    await saveOnboardingStep(c.env, userId, staticStep, payload, TOTAL_ONBOARDING_STEPS);
    const progress = await getOnboardingProgress(c.env, userId, TOTAL_ONBOARDING_STEPS);
    return successResponse(c, { saved: true, progress });
  });
}
onboardingRoutes.post("/steps/:step/save", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const step = Number(c.req.param("step"));
  if (!Number.isInteger(step) || step < 1 || step > TOTAL_ONBOARDING_STEPS) {
    throw new AppError("Invalid onboarding step", 400, "INVALID_PATH_PARAM");
  }
  const body = await c.req.json().catch(() => ({}));
  const payload = normalizeStepPayload(body);
  await saveOnboardingStep(c.env, userId, step, payload, TOTAL_ONBOARDING_STEPS);
  const progress = await getOnboardingProgress(c.env, userId, TOTAL_ONBOARDING_STEPS);
  return successResponse(c, { saved: true, progress });
});
onboardingRoutes.post("/steps/:step/skip", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const step = Number(c.req.param("step"));
  if (!Number.isInteger(step) || step < 1 || step > TOTAL_ONBOARDING_STEPS) {
    throw new AppError("Invalid onboarding step", 400, "INVALID_PATH_PARAM");
  }
  await saveOnboardingStep(c.env, userId, step, { skipped: true }, TOTAL_ONBOARDING_STEPS);
  const progress = await getOnboardingProgress(c.env, userId, TOTAL_ONBOARDING_STEPS);
  return successResponse(c, { skipped: true, progress });
});
onboardingRoutes.post("/state/:step", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const step = Number(c.req.param("step"));
  if (!Number.isInteger(step) || step < 1 || step > TOTAL_ONBOARDING_STEPS) {
    throw new AppError("Invalid onboarding step", 400, "INVALID_PATH_PARAM");
  }
  const body = await c.req.json().catch(() => ({}));
  try {
    await saveOnboardingStep(c.env, userId, step, body, TOTAL_ONBOARDING_STEPS);
    const progress = await getOnboardingProgress(c.env, userId, TOTAL_ONBOARDING_STEPS);
    return successResponse(c, { saved: true, progress });
  } catch (error48) {
    throw wrapError2(error48, "Failed to save onboarding step");
  }
});
onboardingRoutes.get("/state/:step", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const step = Number(c.req.param("step"));
  if (!Number.isInteger(step) || step < 1 || step > TOTAL_ONBOARDING_STEPS) {
    throw new AppError("Invalid onboarding step", 400, "INVALID_PATH_PARAM");
  }
  try {
    const state = await getOnboardingStep(c.env, userId, step);
    return successResponse(c, state ?? {});
  } catch (error48) {
    throw wrapError2(error48, "Failed to load onboarding step");
  }
});
onboardingRoutes.get("/steps/current", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const progress = await getOnboardingProgress(c.env, userId, TOTAL_ONBOARDING_STEPS);
  return successResponse(c, {
    currentStep: progress.currentStep,
    progress
  });
});
onboardingRoutes.get("/progress", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const progress = await getOnboardingProgress(c.env, userId, TOTAL_ONBOARDING_STEPS);
  return successResponse(c, progress);
});
onboardingRoutes.get("/data", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  try {
    const data = await buildOnboardingData(c.env, userId);
    return successResponse(c, data);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load onboarding data");
  }
});
onboardingRoutes.get("/state/progress", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  try {
    const progress = await getOnboardingProgress(c.env, userId, TOTAL_ONBOARDING_STEPS);
    return successResponse(c, progress);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load onboarding progress");
  }
});
onboardingRoutes.post("/state/session", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  try {
    await saveOnboardingSessionDraft(c.env, userId, body);
    return successResponse(c, { saved: true });
  } catch (error48) {
    throw wrapError2(error48, "Failed to save onboarding session");
  }
});
onboardingRoutes.get("/state/session", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  try {
    const draft = await getOnboardingSessionDraft(c.env, userId);
    return successResponse(c, draft ?? {});
  } catch (error48) {
    throw wrapError2(error48, "Failed to load onboarding session");
  }
});
onboardingRoutes.post("/state/reset", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  try {
    await clearOnboardingState(c.env, userId);
    await resetOnboardingProgress(c.env, userId, TOTAL_ONBOARDING_STEPS);
    return successResponse(c, { reset: true });
  } catch (error48) {
    throw wrapError2(error48, "Failed to reset onboarding state");
  }
});
onboardingRoutes.post("/languages", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  if (!Array.isArray(body)) {
    throw new AppError("Expected array payload", 400, "INVALID_PAYLOAD");
  }
  const payload = body.map((item) => ({
    languageId: Number(item.languageId ?? item.language_id),
    currentLevelId: item.currentLevelId ?? item.current_level_id ?? void 0,
    targetLevelId: item.targetLevelId ?? item.target_level_id ?? void 0
  })).filter((item) => Number.isFinite(item.languageId));
  try {
    await upsertOnboardingLanguages(c.env, userId, payload);
    return successResponse(c, { count: payload.length });
  } catch (error48) {
    throw wrapError2(error48, "Failed to save language selections");
  }
});
onboardingRoutes.post("/language/native-language", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  const languageId = Number(body.languageId ?? body.nativeLanguageId);
  if (!Number.isFinite(languageId)) {
    throw new AppError("languageId is required", 400, "INVALID_PAYLOAD");
  }
  await updateUserProfile(c.env, userId, { nativeLanguageId: languageId });
  return successResponse(c, { languageId });
});
onboardingRoutes.post("/language/language-level", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  const languages = Array.isArray(body?.languages) ? body.languages : [];
  const payload = [];
  for (const raw2 of languages) {
    const languageId = Number(raw2.languageId ?? raw2.language_id);
    if (!Number.isFinite(languageId)) {
      continue;
    }
    payload.push({
      languageId,
      currentLevelId: raw2.currentLevelId ?? raw2.current_level_id ?? void 0,
      targetLevelId: raw2.targetLevelId ?? raw2.target_level_id ?? void 0
    });
  }
  await upsertOnboardingLanguages(c.env, userId, payload);
  return successResponse(c, { count: payload.length });
});
onboardingRoutes.post("/interests", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  const topicIds = Array.isArray(body) ? body : body?.topicIds;
  if (!Array.isArray(topicIds)) {
    throw new AppError("topicIds array required", 400, "INVALID_PAYLOAD");
  }
  const casted = topicIds.map(Number).filter((id) => Number.isFinite(id));
  try {
    await upsertOnboardingTopics(c.env, userId, casted);
    return successResponse(c, { count: casted.length });
  } catch (error48) {
    throw wrapError2(error48, "Failed to save interests");
  }
});
onboardingRoutes.post("/interest/motivation", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  const motivationIds = Array.isArray(body?.motivationIds) ? body.motivationIds : Array.isArray(body) ? body : [];
  const normalized = [];
  motivationIds.forEach((value, index) => {
    const motivationId = Number(value);
    if (!Number.isFinite(motivationId)) {
      return;
    }
    normalized.push({
      motivationId,
      priority: index + 1
    });
  });
  await upsertOnboardingMotivations(c.env, userId, normalized);
  return successResponse(c, { count: normalized.length });
});
onboardingRoutes.post("/interest/topic", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  const topicIds = Array.isArray(body?.topicIds) ? body.topicIds : Array.isArray(body) ? body : [];
  const normalized = topicIds.map((value) => Number(value)).filter((id) => Number.isFinite(id));
  await upsertOnboardingTopics(c.env, userId, normalized);
  return successResponse(c, { count: normalized.length });
});
onboardingRoutes.post("/interest/learning-style", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  const raw2 = Array.isArray(body?.learningStyleIds) ? body.learningStyleIds : Array.isArray(body) ? body : [];
  const normalized = raw2.map((value) => Number(value)).filter((value) => Number.isFinite(value));
  try {
    await upsertOnboardingLearningStyles(c.env, userId, normalized);
    return successResponse(c, { count: normalized.length });
  } catch (error48) {
    throw wrapError2(error48, "Failed to save learning styles");
  }
});
onboardingRoutes.post("/interest/learning-expectation", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  const raw2 = Array.isArray(body?.learningExpectationIds) ? body.learningExpectationIds : Array.isArray(body) ? body : [];
  const normalized = raw2.map((value) => Number(value)).filter((value) => Number.isFinite(value));
  try {
    await upsertOnboardingLearningExpectations(c.env, userId, normalized);
    return successResponse(c, { count: normalized.length });
  } catch (error48) {
    throw wrapError2(error48, "Failed to save learning expectations");
  }
});
onboardingRoutes.post("/partner-preferences", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  const preferences = Array.isArray(body) ? body : body?.partnerPreferences;
  if (!Array.isArray(preferences)) {
    throw new AppError("partner preferences array required", 400, "INVALID_PAYLOAD");
  }
  const normalized = preferences.map(
    (item) => typeof item === "number" ? { partnerPersonalityId: item } : {
      partnerPersonalityId: Number(item.partnerPersonalityId ?? item.partner_personality_id),
      partnerGender: item.partnerGender ?? item.partner_gender
    }
  ).filter((item) => Number.isFinite(item.partnerPersonalityId));
  try {
    await upsertOnboardingPartner(c.env, userId, normalized);
    return successResponse(c, { count: normalized.length });
  } catch (error48) {
    throw wrapError2(error48, "Failed to save partner preferences");
  }
});
onboardingRoutes.post("/partner/personality", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  const raw2 = Array.isArray(body.personalPartnerIds) ? body.personalPartnerIds : Array.isArray(body.partnerPersonalityIds) ? body.partnerPersonalityIds : Array.isArray(body) ? body : [];
  if (!Array.isArray(raw2) || raw2.length === 0) {
    await upsertOnboardingPartner(c.env, userId, []);
    return successResponse(c, { count: 0 });
  }
  const normalized = raw2.map(
    (item) => typeof item === "number" ? { partnerPersonalityId: item } : {
      partnerPersonalityId: Number(item.partnerPersonalityId ?? item.partner_personality_id ?? item.id),
      partnerGender: item.partnerGender ?? item.partner_gender ?? void 0
    }
  ).filter((item) => Number.isFinite(item.partnerPersonalityId));
  try {
    await upsertOnboardingPartner(c.env, userId, normalized);
    return successResponse(c, { count: normalized.length });
  } catch (error48) {
    throw wrapError2(error48, "Failed to save partner personalities");
  }
});
onboardingRoutes.post("/schedules", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  const schedules = Array.isArray(body) ? body : body?.schedules;
  if (!Array.isArray(schedules)) {
    throw new AppError("schedules array required", 400, "INVALID_PAYLOAD");
  }
  const normalized = [];
  for (const raw2 of schedules) {
    const scheduleId = Number(raw2.scheduleId ?? raw2.schedule_id);
    if (!Number.isFinite(scheduleId)) {
      continue;
    }
    normalized.push({
      scheduleId,
      dayOfWeek: raw2.dayOfWeek ?? raw2.day_of_week ?? "UNKNOWN",
      classTime: raw2.classTime ?? raw2.class_time ?? void 0
    });
  }
  try {
    await upsertOnboardingSchedules(c.env, userId, normalized);
    return successResponse(c, { count: normalized.length });
  } catch (error48) {
    throw wrapError2(error48, "Failed to save schedules");
  }
});
onboardingRoutes.post("/schedule", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  const schedules = Array.isArray(body?.schedules) ? body.schedules : [];
  const normalized = [];
  for (const raw2 of schedules) {
    const scheduleId = Number(raw2.scheduleId ?? raw2.schedule_id);
    if (!Number.isFinite(scheduleId)) {
      continue;
    }
    normalized.push({
      scheduleId,
      dayOfWeek: raw2.dayOfWeek ?? raw2.day_of_week ?? "UNKNOWN",
      classTime: raw2.classTime ?? raw2.class_time ?? void 0
    });
  }
  await upsertOnboardingSchedules(c.env, userId, normalized);
  return successResponse(c, { count: normalized.length });
});
onboardingRoutes.post("/motivations", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  const motivations = Array.isArray(body) ? body : body?.motivationIds;
  if (!Array.isArray(motivations)) {
    throw new AppError("motivationIds array required", 400, "INVALID_PAYLOAD");
  }
  const normalized = [];
  motivations.forEach((raw2, index) => {
    const motivationId = typeof raw2 === "number" ? raw2 : Number(raw2.motivationId ?? raw2.motivation_id);
    if (!Number.isFinite(motivationId)) {
      return;
    }
    normalized.push({
      motivationId,
      priority: raw2?.priority ?? index + 1
    });
  });
  try {
    await upsertOnboardingMotivations(c.env, userId, normalized);
    return successResponse(c, { count: normalized.length });
  } catch (error48) {
    throw wrapError2(error48, "Failed to save motivations");
  }
});
onboardingRoutes.get("/summary", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  try {
    const summary = await loadOnboardingSummary(c.env, userId);
    return successResponse(c, summary);
  } catch (error48) {
    throw wrapError2(error48, "Failed to load onboarding summary");
  }
});
onboardingRoutes.post("/complete", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  try {
    await completeOnboarding(c.env, userId, body ?? {});
    await clearOnboardingState(c.env, userId);
    return successResponse(c, { completed: true });
  } catch (error48) {
    throw wrapError2(error48, "Failed to complete onboarding");
  }
});
var onboarding_default = onboardingRoutes;

// src/routes/sessions.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_errors();

// src/services/session.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_db();
var SESSION_STATUS = {
  SCHEDULED: "SCHEDULED",
  IN_PROGRESS: "IN_PROGRESS",
  COMPLETED: "COMPLETED",
  CANCELLED: "CANCELLED"
};
var BOOKING_STATUS = {
  CONFIRMED: "CONFIRMED",
  CANCELLED: "CANCELLED",
  NO_SHOW: "NO_SHOW"
};
var DEFAULT_INVITE_EXPIRATION_HOURS = 24;
var NOTIFICATION_DEFAULTS = {
  reminderBefore: 30,
  enableEmailReminder: true,
  enablePushReminder: true,
  enableSmsReminder: false,
  updatedAt: (/* @__PURE__ */ new Date(0)).toISOString()
};
function intToBool(value) {
  return value === 1;
}
__name(intToBool, "intToBool");
function boolToInt(value) {
  return value ? 1 : 0;
}
__name(boolToInt, "boolToInt");
async function fetchNotificationRow(env2, sessionId, userId) {
  return queryFirst(
    env2.DB,
    `SELECT * FROM session_notifications WHERE session_id = ? AND user_id = ? LIMIT 1`,
    [sessionId, userId]
  );
}
__name(fetchNotificationRow, "fetchNotificationRow");
async function upsertNotificationRow(env2, sessionId, userId, settings) {
  await execute(
    env2.DB,
    `INSERT INTO session_notifications (
        session_id,
        user_id,
        reminder_before,
        enable_email,
        enable_push,
        enable_sms,
        updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?)
      ON CONFLICT(session_id, user_id) DO UPDATE SET
        reminder_before = excluded.reminder_before,
        enable_email = excluded.enable_email,
        enable_push = excluded.enable_push,
        enable_sms = excluded.enable_sms,
        updated_at = excluded.updated_at`,
    [
      sessionId,
      userId,
      settings.reminderBefore,
      boolToInt(settings.enableEmailReminder),
      boolToInt(settings.enablePushReminder),
      boolToInt(settings.enableSmsReminder),
      settings.updatedAt
    ]
  );
}
__name(upsertNotificationRow, "upsertNotificationRow");
async function fetchRecordingRow(env2, sessionId) {
  return queryFirst(
    env2.DB,
    "SELECT * FROM session_recordings WHERE session_id = ? LIMIT 1",
    [sessionId]
  );
}
__name(fetchRecordingRow, "fetchRecordingRow");
async function upsertRecordingRow(env2, sessionId, status) {
  await execute(
    env2.DB,
    `INSERT INTO session_recordings (
        session_id,
        status,
        record_audio,
        record_video,
        record_transcript,
        download_url,
        message,
        updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      ON CONFLICT(session_id) DO UPDATE SET
        status = excluded.status,
        record_audio = excluded.record_audio,
        record_video = excluded.record_video,
        record_transcript = excluded.record_transcript,
        download_url = excluded.download_url,
        message = excluded.message,
        updated_at = excluded.updated_at`,
    [
      sessionId,
      status.status,
      boolToInt(status.recordAudio),
      boolToInt(status.recordVideo),
      boolToInt(status.recordTranscript),
      status.downloadUrl ?? null,
      status.message ?? null,
      status.updatedAt
    ]
  );
}
__name(upsertRecordingRow, "upsertRecordingRow");
async function fetchInviteRow(env2, token) {
  return queryFirst(
    env2.DB,
    "SELECT * FROM session_invites WHERE invite_token = ? LIMIT 1",
    [token]
  );
}
__name(fetchInviteRow, "fetchInviteRow");
async function insertInviteRow(env2, record2) {
  await execute(
    env2.DB,
    `INSERT INTO session_invites (
        invite_token,
        session_id,
        inviter_user_id,
        expires_at,
        created_at,
        used_at,
        used_by
      ) VALUES (?, ?, ?, ?, ?, ?, ?)
      ON CONFLICT(invite_token) DO UPDATE SET
        session_id = excluded.session_id,
        inviter_user_id = excluded.inviter_user_id,
        expires_at = excluded.expires_at,
        created_at = excluded.created_at,
        used_at = excluded.used_at,
        used_by = excluded.used_by`,
    [
      record2.invite_token,
      record2.session_id,
      record2.inviter_user_id,
      record2.expires_at,
      record2.created_at,
      record2.used_at,
      record2.used_by
    ]
  );
}
__name(insertInviteRow, "insertInviteRow");
async function markInviteUsed(env2, token, usedBy, usedAt) {
  await execute(
    env2.DB,
    "UPDATE session_invites SET used_at = ?, used_by = ? WHERE invite_token = ?",
    [usedAt, usedBy, token]
  );
}
__name(markInviteUsed, "markInviteUsed");
async function fetchSummaryRow(env2, sessionId) {
  return queryFirst(
    env2.DB,
    "SELECT * FROM session_summaries WHERE session_id = ? LIMIT 1",
    [sessionId]
  );
}
__name(fetchSummaryRow, "fetchSummaryRow");
async function upsertSummaryRow(env2, row) {
  await execute(
    env2.DB,
    `INSERT INTO session_summaries (
        session_id,
        notes,
        duration_minutes,
        rating,
        highlights,
        action_items,
        feedback,
        updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      ON CONFLICT(session_id) DO UPDATE SET
        notes = excluded.notes,
        duration_minutes = excluded.duration_minutes,
        rating = excluded.rating,
        highlights = excluded.highlights,
        action_items = excluded.action_items,
        feedback = excluded.feedback,
        updated_at = excluded.updated_at`,
    [
      row.session_id,
      row.notes,
      row.duration_minutes,
      row.rating,
      row.highlights,
      row.action_items,
      row.feedback,
      row.updated_at
    ]
  );
}
__name(upsertSummaryRow, "upsertSummaryRow");
async function fetchTranscriptRow(env2, sessionId, language) {
  return queryFirst(
    env2.DB,
    "SELECT * FROM session_transcripts WHERE session_id = ? AND language = ? LIMIT 1",
    [sessionId, language]
  );
}
__name(fetchTranscriptRow, "fetchTranscriptRow");
async function upsertTranscriptRow(env2, row) {
  await execute(
    env2.DB,
    `INSERT INTO session_transcripts (
        session_id,
        language,
        segments,
        generated_at,
        updated_at
      ) VALUES (?, ?, ?, ?, ?)
      ON CONFLICT(session_id, language) DO UPDATE SET
        segments = excluded.segments,
        generated_at = excluded.generated_at,
        updated_at = excluded.updated_at`,
    [
      row.session_id,
      row.language,
      row.segments,
      row.generated_at,
      row.updated_at
    ]
  );
}
__name(upsertTranscriptRow, "upsertTranscriptRow");
function deserializeSummaryRow(row) {
  const highlights = row.highlights ? safeParseStringArray(row.highlights) : [];
  const actionItems = row.action_items ? safeParseStringArray(row.action_items) : [];
  const feedback = row.feedback ? safeParseObject(row.feedback) : void 0;
  return {
    sessionId: row.session_id,
    notes: row.notes ?? void 0,
    durationMinutes: row.duration_minutes ?? void 0,
    rating: row.rating ?? void 0,
    highlights,
    actionItems,
    feedback,
    updatedAt: row.updated_at
  };
}
__name(deserializeSummaryRow, "deserializeSummaryRow");
function serializeSummaryResponse(summary) {
  return {
    session_id: summary.sessionId,
    notes: summary.notes ?? null,
    duration_minutes: summary.durationMinutes ?? null,
    rating: summary.rating ?? null,
    highlights: JSON.stringify(summary.highlights ?? []),
    action_items: JSON.stringify(summary.actionItems ?? []),
    feedback: summary.feedback ? JSON.stringify(summary.feedback) : null,
    updated_at: summary.updatedAt
  };
}
__name(serializeSummaryResponse, "serializeSummaryResponse");
function deserializeTranscriptRow(row) {
  const segments = row.segments ? safeParseSegments(row.segments) : [];
  return {
    sessionId: row.session_id,
    language: row.language,
    segments,
    generatedAt: row.generated_at
  };
}
__name(deserializeTranscriptRow, "deserializeTranscriptRow");
function safeParseStringArray(payload) {
  try {
    const parsed = JSON.parse(payload);
    return Array.isArray(parsed) ? parsed.map(String) : [];
  } catch {
    return [];
  }
}
__name(safeParseStringArray, "safeParseStringArray");
function safeParseObject(payload) {
  try {
    const parsed = JSON.parse(payload);
    return typeof parsed === "object" && parsed !== null ? parsed : void 0;
  } catch {
    return void 0;
  }
}
__name(safeParseObject, "safeParseObject");
function safeParseSegments(payload) {
  try {
    const parsed = JSON.parse(payload);
    if (Array.isArray(parsed)) {
      return parsed.map((segment) => {
        if (segment && typeof segment === "object") {
          return {
            speaker: String(segment.speaker ?? ""),
            content: String(segment.content ?? ""),
            startTime: segment.startTime ?? void 0,
            endTime: segment.endTime ?? void 0
          };
        }
        return {
          speaker: "",
          content: String(segment ?? "")
        };
      });
    }
    return [];
  } catch {
    return [];
  }
}
__name(safeParseSegments, "safeParseSegments");
function nowIso() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
__name(nowIso, "nowIso");
function mapSessionRow(row, currentUserId) {
  const scheduledAt = row.scheduled_at;
  const duration3 = Number(row.duration_minutes ?? 0);
  const startDate = scheduledAt ? new Date(scheduledAt) : null;
  const startedAt = row.started_at ?? void 0;
  const endedAt = row.ended_at ?? void 0;
  let canJoin;
  let isHost;
  let isParticipant;
  if (currentUserId) {
    isHost = row.host_user_id === currentUserId;
    isParticipant = row.guest_user_id === currentUserId;
    canJoin = row.status === SESSION_STATUS.SCHEDULED && !isHost && Number(row.current_participants ?? 0) < Number(row.max_participants ?? 1);
  }
  return {
    sessionId: row.session_id,
    hostUserId: row.host_user_id,
    hostUserName: row.host_name ?? void 0,
    hostUserProfileImage: row.host_profile_image ?? void 0,
    guestUserId: row.guest_user_id ?? void 0,
    guestUserName: row.guest_name ?? void 0,
    guestUserProfileImage: row.guest_profile_image ?? void 0,
    title: row.title,
    description: row.description ?? void 0,
    sessionType: row.session_type,
    languageCode: row.language_code ?? void 0,
    skillFocus: row.skill_focus ?? void 0,
    levelRequirement: row.level_requirement ?? void 0,
    scheduledAt,
    durationMinutes: duration3,
    maxParticipants: row.max_participants !== null ? Number(row.max_participants) : void 0,
    currentParticipants: Number(row.current_participants ?? 0),
    status: row.status,
    meetingUrl: row.meeting_url ?? void 0,
    isRecurring: Boolean(row.is_recurring),
    recurrencePattern: row.recurrence_pattern ?? void 0,
    recurrenceEndDate: row.recurrence_end_date ?? void 0,
    isPublic: Boolean(row.is_public ?? 1),
    tags: row.tags ?? void 0,
    preparationNotes: row.preparation_notes ?? void 0,
    startedAt,
    endedAt,
    canJoin,
    isHost,
    isParticipant
  };
}
__name(mapSessionRow, "mapSessionRow");
function mapBookingRow(row) {
  return {
    bookingId: row.booking_id,
    sessionId: row.session_id,
    sessionTitle: row.session_title,
    sessionScheduledAt: row.session_scheduled_at,
    sessionDurationMinutes: Number(row.session_duration_minutes ?? 0),
    sessionLanguageCode: row.session_language_code ?? void 0,
    hostUserId: row.host_user_id,
    hostUserName: row.host_user_name ?? void 0,
    hostUserProfileImage: row.host_user_profile_image ?? void 0,
    status: row.status,
    bookingMessage: row.booking_message ?? void 0,
    bookedAt: row.created_at,
    cancelledAt: row.cancelled_at ?? void 0,
    cancellationReason: row.cancellation_reason ?? void 0,
    attended: Boolean(row.attended),
    feedbackRating: row.feedback_rating !== null ? Number(row.feedback_rating) : void 0,
    feedbackComment: row.feedback_comment ?? void 0,
    reminderSent: Boolean(row.reminder_sent),
    canCancel: calculateCanCancel(row.session_scheduled_at)
  };
}
__name(mapBookingRow, "mapBookingRow");
function calculateCanCancel(scheduledAt) {
  if (!scheduledAt) return false;
  const sessionTime = new Date(scheduledAt);
  const threshold = /* @__PURE__ */ new Date();
  threshold.setUTCHours(threshold.getUTCHours() + 1);
  return sessionTime > threshold;
}
__name(calculateCanCancel, "calculateCanCancel");
async function getSessionRow(env2, sessionId) {
  return queryFirst(
    env2.DB,
    `SELECT s.*, 
            host.name AS host_name,
            host.profile_image AS host_profile_image,
            guest.name AS guest_name,
            guest.profile_image AS guest_profile_image
       FROM sessions s
       LEFT JOIN users host ON host.user_id = s.host_user_id
       LEFT JOIN users guest ON guest.user_id = s.guest_user_id
      WHERE s.session_id = ?
      LIMIT 1`,
    [sessionId]
  );
}
__name(getSessionRow, "getSessionRow");
async function ensureSessionExists(env2, sessionId) {
  const row = await getSessionRow(env2, sessionId);
  if (!row) throw new Error("\uC138\uC158\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  return row;
}
__name(ensureSessionExists, "ensureSessionExists");
async function createSession2(env2, hostUserId, payload) {
  const now = nowIso();
  const title2 = payload.title ?? payload.topic ?? "Study Session";
  const sessionType = payload.sessionType ?? payload.sessionType ?? "VIDEO";
  const scheduledAt = payload.scheduledAt;
  const durationMinutes = payload.durationMinutes ?? payload.duration ?? 30;
  const maxParticipants = payload.maxParticipants ?? (payload.partnerId ? 2 : 1);
  const isPublic = payload.isPublic ?? !payload.partnerId;
  const languageCode = payload.languageCode ?? payload.language ?? null;
  const skillFocus = payload.skillFocus ?? payload.targetLanguage ?? null;
  const description = payload.description ?? payload.topic ?? null;
  const guestUserId = payload.partnerId ?? null;
  const metadata = {
    webRtcRoomId: payload.webRtcRoomId ?? null,
    webRtcRoomType: payload.webRtcRoomType ?? null,
    targetLanguage: payload.targetLanguage ?? null,
    topic: payload.topic ?? null,
    language: payload.language ?? null
  };
  const preparationNotes = payload.preparationNotes ?? JSON.stringify(metadata);
  const meetingUrl = payload.meetingUrl ?? (payload.webRtcRoomId ? `webrtc:${payload.webRtcRoomId}` : null);
  await execute(
    env2.DB,
    `INSERT INTO sessions (
        host_user_id,
        guest_user_id,
        title,
        description,
        session_type,
        language_code,
        skill_focus,
        level_requirement,
        scheduled_at,
        duration_minutes,
        max_participants,
        current_participants,
        status,
        meeting_url,
        meeting_password,
        is_recurring,
        recurrence_pattern,
        recurrence_end_date,
        is_public,
        tags,
        preparation_notes,
        created_at,
        updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 0, ?, ?, NULL, ?, ?, ?, ?, ?, ?, ?, ?)
    `,
    [
      hostUserId,
      guestUserId,
      title2,
      description,
      sessionType,
      languageCode,
      skillFocus,
      payload.levelRequirement ?? null,
      scheduledAt,
      durationMinutes,
      maxParticipants,
      SESSION_STATUS.SCHEDULED,
      meetingUrl,
      payload.isRecurring ? 1 : 0,
      payload.recurrencePattern ?? null,
      payload.recurrenceEndDate ?? null,
      isPublic ? 1 : 0,
      payload.tags ?? null,
      preparationNotes,
      now,
      now
    ]
  );
  const idRow = await queryFirst(
    env2.DB,
    "SELECT last_insert_rowid() as id"
  );
  const sessionId = Number(idRow?.id ?? 0);
  if (!sessionId) {
    throw new Error("\uC138\uC158 ID\uB97C \uD655\uC778\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  const row = await getSessionRow(env2, sessionId);
  if (!row) {
    throw new Error("\uC138\uC158 \uC0DD\uC131 \uD6C4 \uB370\uC774\uD130\uB97C \uB85C\uB4DC\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  return mapSessionRow(row, hostUserId);
}
__name(createSession2, "createSession");
async function listSessions(env2, page, size, statusFilter) {
  const offset = (page - 1) * size;
  const filters = [];
  const params = [];
  const status = statusFilter?.toLowerCase();
  const now = nowIso();
  if (status === "upcoming") {
    filters.push("status = ?");
    params.push(SESSION_STATUS.SCHEDULED);
    filters.push("scheduled_at >= ?");
    params.push(now);
  } else if (status === "completed" || status === "done") {
    filters.push("status = ?");
    params.push(SESSION_STATUS.COMPLETED);
  } else if (status === "cancelled") {
    filters.push("status = ?");
    params.push(SESSION_STATUS.CANCELLED);
  } else if (status === "in-progress") {
    filters.push("status = ?");
    params.push(SESSION_STATUS.IN_PROGRESS);
  }
  const whereClause = filters.length ? `WHERE ${filters.join(" AND ")}` : "";
  const totalRow = await queryFirst(
    env2.DB,
    `SELECT COUNT(*) as count FROM sessions ${whereClause}`,
    params
  );
  const rows = await query(
    env2.DB,
    `SELECT s.*, host.name AS host_name, host.profile_image AS host_profile_image,
            guest.name AS guest_name, guest.profile_image AS guest_profile_image
       FROM sessions s
       LEFT JOIN users host ON host.user_id = s.host_user_id
       LEFT JOIN users guest ON guest.user_id = s.guest_user_id
      ${whereClause}
      ORDER BY s.scheduled_at DESC
      LIMIT ? OFFSET ?`,
    params.concat([size, offset])
  );
  const data = rows.map((row) => mapSessionRow(row));
  return {
    data,
    page,
    size,
    total: totalRow?.count ?? 0
  };
}
__name(listSessions, "listSessions");
async function getSessionById(env2, sessionId, currentUserId) {
  const row = await getSessionRow(env2, sessionId);
  if (!row) throw new Error("\uC138\uC158\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  return mapSessionRow(row, currentUserId);
}
__name(getSessionById, "getSessionById");
async function listUserSessions(env2, userId, page, size) {
  const offset = (page - 1) * size;
  const totalRow = await queryFirst(
    env2.DB,
    `SELECT COUNT(*) as count FROM sessions
      WHERE host_user_id = ? OR guest_user_id = ?`,
    [userId, userId]
  );
  const rows = await query(
    env2.DB,
    `SELECT s.*, host.name AS host_name, host.profile_image AS host_profile_image,
            guest.name AS guest_name, guest.profile_image AS guest_profile_image
       FROM sessions s
       LEFT JOIN users host ON host.user_id = s.host_user_id
       LEFT JOIN users guest ON guest.user_id = s.guest_user_id
      WHERE s.host_user_id = ? OR s.guest_user_id = ?
      ORDER BY s.scheduled_at DESC
      LIMIT ? OFFSET ?`,
    [userId, userId, size, offset]
  );
  const data = rows.map((row) => mapSessionRow(row, userId));
  return {
    data,
    page,
    size,
    total: totalRow?.count ?? 0
  };
}
__name(listUserSessions, "listUserSessions");
async function listPublicSessions(env2, page, size) {
  const offset = (page - 1) * size;
  const now = nowIso();
  const totalRow = await queryFirst(
    env2.DB,
    `SELECT COUNT(*) as count FROM sessions
      WHERE is_public = 1 AND status = ? AND scheduled_at >= ?`,
    [SESSION_STATUS.SCHEDULED, now]
  );
  const rows = await query(
    env2.DB,
    `SELECT s.*, host.name AS host_name, host.profile_image AS host_profile_image,
            guest.name AS guest_name, guest.profile_image AS guest_profile_image
       FROM sessions s
       LEFT JOIN users host ON host.user_id = s.host_user_id
       LEFT JOIN users guest ON guest.user_id = s.guest_user_id
      WHERE s.is_public = 1 AND s.status = ? AND s.scheduled_at >= ?
      ORDER BY s.scheduled_at ASC
      LIMIT ? OFFSET ?`,
    [SESSION_STATUS.SCHEDULED, now, size, offset]
  );
  const data = rows.map((row) => mapSessionRow(row));
  return { data, page, size, total: totalRow?.count ?? 0 };
}
__name(listPublicSessions, "listPublicSessions");
async function listSessionsByLanguage(env2, languageCode, page, size) {
  const offset = (page - 1) * size;
  const totalRow = await queryFirst(
    env2.DB,
    `SELECT COUNT(*) as count FROM sessions
      WHERE status = ? AND language_code = ?`,
    [SESSION_STATUS.SCHEDULED, languageCode]
  );
  const rows = await query(
    env2.DB,
    `SELECT s.*, host.name AS host_name, host.profile_image AS host_profile_image,
            guest.name AS guest_name, guest.profile_image AS guest_profile_image
       FROM sessions s
       LEFT JOIN users host ON host.user_id = s.host_user_id
       LEFT JOIN users guest ON guest.user_id = s.guest_user_id
      WHERE s.status = ? AND s.language_code = ?
      ORDER BY s.scheduled_at ASC
      LIMIT ? OFFSET ?`,
    [SESSION_STATUS.SCHEDULED, languageCode, size, offset]
  );
  const data = rows.map((row) => mapSessionRow(row));
  return { data, page, size, total: totalRow?.count ?? 0 };
}
__name(listSessionsByLanguage, "listSessionsByLanguage");
async function listSessionsByType(env2, sessionType, page, size) {
  const offset = (page - 1) * size;
  const totalRow = await queryFirst(
    env2.DB,
    `SELECT COUNT(*) as count FROM sessions
      WHERE status = ? AND session_type = ?`,
    [SESSION_STATUS.SCHEDULED, sessionType]
  );
  const rows = await query(
    env2.DB,
    `SELECT s.*, host.name AS host_name, host.profile_image AS host_profile_image,
            guest.name AS guest_name, guest.profile_image AS guest_profile_image
       FROM sessions s
       LEFT JOIN users host ON host.user_id = s.host_user_id
       LEFT JOIN users guest ON guest.user_id = s.guest_user_id
      WHERE s.status = ? AND s.session_type = ?
      ORDER BY s.scheduled_at ASC
      LIMIT ? OFFSET ?`,
    [SESSION_STATUS.SCHEDULED, sessionType, size, offset]
  );
  const data = rows.map((row) => mapSessionRow(row));
  return { data, page, size, total: totalRow?.count ?? 0 };
}
__name(listSessionsByType, "listSessionsByType");
async function listAvailableSessions(env2, userId, page, size) {
  const offset = (page - 1) * size;
  const totalRow = await queryFirst(
    env2.DB,
    `SELECT COUNT(*) as count FROM sessions s
      WHERE s.status = ?
        AND s.is_public = 1
        AND s.host_user_id != ?
        AND (s.max_participants IS NULL OR s.current_participants < s.max_participants)`,
    [SESSION_STATUS.SCHEDULED, userId]
  );
  const rows = await query(
    env2.DB,
    `SELECT s.*, host.name AS host_name, host.profile_image AS host_profile_image,
            guest.name AS guest_name, guest.profile_image AS guest_profile_image
       FROM sessions s
       LEFT JOIN users host ON host.user_id = s.host_user_id
       LEFT JOIN users guest ON guest.user_id = s.guest_user_id
      WHERE s.status = ?
        AND s.is_public = 1
        AND s.host_user_id != ?
        AND (s.max_participants IS NULL OR s.current_participants < s.max_participants)
      ORDER BY s.scheduled_at ASC
      LIMIT ? OFFSET ?`,
    [SESSION_STATUS.SCHEDULED, userId, size, offset]
  );
  const data = rows.map((row) => mapSessionRow(row, userId));
  return { data, page, size, total: totalRow?.count ?? 0 };
}
__name(listAvailableSessions, "listAvailableSessions");
async function bookSession(env2, userId, payload) {
  const session = await ensureSessionExists(env2, payload.sessionId);
  if (session.host_user_id === userId) {
    throw new Error("\uD638\uC2A4\uD2B8\uB294 \uC790\uC2E0\uC758 \uC138\uC158\uC744 \uC608\uC57D\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  if (session.status !== SESSION_STATUS.SCHEDULED) {
    throw new Error("\uC608\uC57D\uD560 \uC218 \uC5C6\uB294 \uC138\uC158\uC785\uB2C8\uB2E4.");
  }
  const maxParticipants = session.max_participants ?? 1;
  const currentParticipants = Number(session.current_participants ?? 0);
  if (currentParticipants >= maxParticipants) {
    throw new Error("\uC138\uC158 \uC815\uC6D0\uC774 \uAC00\uB4DD \uCC3C\uC2B5\uB2C8\uB2E4.");
  }
  const existing = await queryFirst(
    env2.DB,
    `SELECT booking_id FROM session_bookings
      WHERE session_id = ? AND user_id = ? AND status = ?
      LIMIT 1`,
    [payload.sessionId, userId, BOOKING_STATUS.CONFIRMED]
  );
  if (existing) {
    throw new Error("\uC774\uBBF8 \uC608\uC57D\uB41C \uC138\uC158\uC785\uB2C8\uB2E4.");
  }
  const now = nowIso();
  await execute(
    env2.DB,
    `INSERT INTO session_bookings (
        session_id, user_id, status, booking_message,
        cancelled_at, cancellation_reason, attended, feedback_rating,
        feedback_comment, reminder_sent, reminder_sent_at, created_at, updated_at
      ) VALUES (?, ?, ?, ?, NULL, NULL, 0, NULL, NULL, 0, NULL, ?, ?)
    `,
    [payload.sessionId, userId, BOOKING_STATUS.CONFIRMED, payload.bookingMessage ?? null, now, now]
  );
  const newParticipants = currentParticipants + 1;
  await execute(
    env2.DB,
    `UPDATE sessions
        SET guest_user_id = CASE WHEN guest_user_id IS NULL THEN ? ELSE guest_user_id END,
            current_participants = ?,
            updated_at = ?
      WHERE session_id = ?`,
    [userId, newParticipants, now, payload.sessionId]
  );
  const bookingRow = await queryFirst(
    env2.DB,
    `SELECT b.*, 
            s.title AS session_title,
            s.scheduled_at AS session_scheduled_at,
            s.duration_minutes AS session_duration_minutes,
            s.language_code AS session_language_code,
            s.host_user_id,
            host.name AS host_user_name,
            host.profile_image AS host_user_profile_image
       FROM session_bookings b
       JOIN sessions s ON s.session_id = b.session_id
       LEFT JOIN users host ON host.user_id = s.host_user_id
      WHERE b.session_id = ? AND b.user_id = ?
      ORDER BY b.created_at DESC
      LIMIT 1`,
    [payload.sessionId, userId]
  );
  if (!bookingRow) throw new Error("\uC608\uC57D \uC815\uBCF4\uB97C \uBD88\uB7EC\uC62C \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  return mapBookingRow(bookingRow);
}
__name(bookSession, "bookSession");
async function joinSession(env2, userId, sessionId, bookingMessage) {
  const session = await ensureSessionExists(env2, sessionId);
  if (session.host_user_id === userId) {
    return mapSessionRow(session, userId);
  }
  await bookSession(env2, userId, { sessionId, bookingMessage });
  const updated = await getSessionRow(env2, sessionId);
  if (!updated) {
    throw new Error("\uC138\uC158 \uC815\uBCF4\uB97C \uAC31\uC2E0\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  return mapSessionRow(updated, userId);
}
__name(joinSession, "joinSession");
async function cancelBooking(env2, userId, bookingId, reason) {
  const booking = await queryFirst(
    env2.DB,
    `SELECT b.*, s.host_user_id, s.guest_user_id, s.current_participants
       FROM session_bookings b
       JOIN sessions s ON s.session_id = b.session_id
      WHERE b.booking_id = ?
      LIMIT 1`,
    [bookingId]
  );
  if (!booking) throw new Error("\uC608\uC57D\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  if (booking.user_id !== userId) throw new Error("\uC608\uC57D\uC744 \uCDE8\uC18C\uD560 \uAD8C\uD55C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
  if (booking.status !== BOOKING_STATUS.CONFIRMED) throw new Error("\uC774\uBBF8 \uCC98\uB9AC\uB41C \uC608\uC57D\uC785\uB2C8\uB2E4.");
  const now = nowIso();
  await execute(
    env2.DB,
    `UPDATE session_bookings
       SET status = ?, cancelled_at = ?, cancellation_reason = ?, updated_at = ?
     WHERE booking_id = ?`,
    [BOOKING_STATUS.CANCELLED, now, reason ?? null, now, bookingId]
  );
  const newParticipants = Math.max(Number(booking.current_participants ?? 1) - 1, 0);
  const guestUserId = booking.guest_user_id === userId ? null : booking.guest_user_id;
  await execute(
    env2.DB,
    `UPDATE sessions
        SET guest_user_id = ?,
            current_participants = ?,
            updated_at = ?
      WHERE session_id = ?`,
    [guestUserId, newParticipants, now, booking.session_id]
  );
}
__name(cancelBooking, "cancelBooking");
async function listUserBookings(env2, userId, page, size) {
  const offset = (page - 1) * size;
  const totalRow = await queryFirst(
    env2.DB,
    "SELECT COUNT(*) as count FROM session_bookings WHERE user_id = ?",
    [userId]
  );
  const rows = await query(
    env2.DB,
    `SELECT b.*, s.title AS session_title, s.scheduled_at AS session_scheduled_at,
            s.duration_minutes AS session_duration_minutes, s.language_code AS session_language_code,
            s.host_user_id, host.name AS host_user_name, host.profile_image AS host_user_profile_image
       FROM session_bookings b
       JOIN sessions s ON s.session_id = b.session_id
       LEFT JOIN users host ON host.user_id = s.host_user_id
      WHERE b.user_id = ?
      ORDER BY b.created_at DESC
      LIMIT ? OFFSET ?`,
    [userId, size, offset]
  );
  const data = rows.map((row) => mapBookingRow(row));
  return { data, page, size, total: totalRow?.count ?? 0 };
}
__name(listUserBookings, "listUserBookings");
async function getUserCalendar(env2, userId, start, end) {
  const rows = await query(
    env2.DB,
    `SELECT s.*, host.name AS host_name, guest.name AS guest_name
       FROM sessions s
       LEFT JOIN users host ON host.user_id = s.host_user_id
       LEFT JOIN users guest ON guest.user_id = s.guest_user_id
      WHERE s.scheduled_at BETWEEN ? AND ?
        AND (s.host_user_id = ? OR s.guest_user_id = ?)
      ORDER BY s.scheduled_at ASC`,
    [start, end, userId, userId]
  );
  const events = rows.map((row) => ({
    sessionId: row.session_id,
    title: row.title,
    description: row.description ?? void 0,
    startTime: row.scheduled_at,
    endTime: new Date(new Date(row.scheduled_at).getTime() + Number(row.duration_minutes ?? 0) * 6e4).toISOString(),
    eventType: "SESSION",
    status: row.status,
    isHost: row.host_user_id === userId,
    color: row.host_user_id === userId ? "#4CAF50" : "#2196F3"
  }));
  const availableSlots = [];
  const startDate = new Date(start);
  const endDate = new Date(end);
  let cursor = new Date(startDate);
  while (cursor < endDate) {
    const next = new Date(cursor.getTime() + 60 * 6e4);
    availableSlots.push({ startTime: cursor.toISOString(), endTime: next.toISOString(), isAvailable: true });
    cursor = next;
  }
  return { events, availableSlots };
}
__name(getUserCalendar, "getUserCalendar");
async function startSession(env2, userId, sessionId) {
  const session = await ensureSessionExists(env2, sessionId);
  if (session.host_user_id !== userId) {
    throw new Error("\uC138\uC158\uC744 \uC2DC\uC791\uD560 \uAD8C\uD55C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  const now = nowIso();
  await execute(
    env2.DB,
    "UPDATE sessions SET status = ?, started_at = ?, updated_at = ? WHERE session_id = ?",
    [SESSION_STATUS.IN_PROGRESS, now, now, sessionId]
  );
}
__name(startSession, "startSession");
async function endSession(env2, userId, sessionId, summary) {
  const session = await ensureSessionExists(env2, sessionId);
  if (session.host_user_id !== userId) {
    throw new Error("\uC138\uC158\uC744 \uC885\uB8CC\uD560 \uAD8C\uD55C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  const now = nowIso();
  await execute(
    env2.DB,
    "UPDATE sessions SET status = ?, ended_at = ?, updated_at = ? WHERE session_id = ?",
    [SESSION_STATUS.COMPLETED, now, now, sessionId]
  );
  if (summary) {
    await mergeSessionSummary(env2, sessionId, {
      sessionId,
      durationMinutes: summary.duration ?? void 0,
      notes: summary.notes,
      rating: summary.rating,
      updatedAt: now,
      highlights: [],
      actionItems: []
    });
  }
}
__name(endSession, "endSession");
async function cancelSession(env2, userId, sessionId, reason) {
  const session = await ensureSessionExists(env2, sessionId);
  if (session.host_user_id !== userId) {
    throw new Error("\uC138\uC158\uC744 \uCDE8\uC18C\uD560 \uAD8C\uD55C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  const now = nowIso();
  await execute(
    env2.DB,
    `UPDATE sessions
        SET status = ?, cancelled_at = ?, cancellation_reason = ?, updated_at = ?
      WHERE session_id = ?`,
    [SESSION_STATUS.CANCELLED, now, reason ?? null, now, sessionId]
  );
  await execute(
    env2.DB,
    `UPDATE session_bookings
        SET status = ?, cancelled_at = ?, cancellation_reason = ?, updated_at = ?
      WHERE session_id = ? AND status = ?`,
    [BOOKING_STATUS.CANCELLED, now, reason ?? "Session cancelled by host", now, sessionId, BOOKING_STATUS.CONFIRMED]
  );
}
__name(cancelSession, "cancelSession");
async function mergeSessionSummary(env2, sessionId, update) {
  const existingRow = await fetchSummaryRow(env2, sessionId);
  const existing = existingRow ? deserializeSummaryRow(existingRow) : null;
  const combinedFeedback = {
    ...existing?.feedback ?? {},
    ...update.feedback ?? {}
  };
  const feedback = combinedFeedback && Object.keys(combinedFeedback).length > 0 ? combinedFeedback : existing?.feedback;
  const highlights = update.highlights ?? existing?.highlights ?? [];
  const actionItems = update.actionItems ?? existing?.actionItems ?? [];
  const merged = {
    sessionId,
    notes: update.notes ?? existing?.notes,
    durationMinutes: update.durationMinutes ?? existing?.durationMinutes,
    rating: update.rating ?? existing?.rating,
    highlights,
    actionItems,
    feedback,
    updatedAt: update.updatedAt ?? nowIso()
  };
  await upsertSummaryRow(env2, serializeSummaryResponse(merged));
  return merged;
}
__name(mergeSessionSummary, "mergeSessionSummary");
async function getStoredSessionSummary(env2, sessionId) {
  const row = await fetchSummaryRow(env2, sessionId);
  return row ? deserializeSummaryRow(row) : null;
}
__name(getStoredSessionSummary, "getStoredSessionSummary");
async function buildDefaultSessionSummary(env2, sessionId) {
  const row = await getSessionRow(env2, sessionId);
  if (!row) {
    throw new Error("\uC138\uC158\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  return {
    sessionId,
    notes: void 0,
    durationMinutes: row.duration_minutes ?? void 0,
    rating: void 0,
    highlights: [],
    actionItems: [],
    feedback: void 0,
    updatedAt: row.updated_at
  };
}
__name(buildDefaultSessionSummary, "buildDefaultSessionSummary");
function parsePreparationNotes(raw2) {
  if (!raw2) return {};
  try {
    return JSON.parse(raw2);
  } catch {
    return { notes: raw2 };
  }
}
__name(parsePreparationNotes, "parsePreparationNotes");
async function rescheduleSession(env2, userId, sessionId, payload) {
  const session = await ensureSessionExists(env2, sessionId);
  if (session.host_user_id !== userId) {
    throw new Error("\uC138\uC158 \uC77C\uC815\uC744 \uBCC0\uACBD\uD560 \uAD8C\uD55C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  const now = nowIso();
  const newScheduledAt = payload.scheduledAt ?? session.scheduled_at;
  const newDuration = payload.duration ?? session.duration_minutes ?? 30;
  const notes = parsePreparationNotes(session.preparation_notes ?? null);
  const reason = payload.reason?.trim();
  if (reason) {
    const history = Array.isArray(notes.rescheduleHistory) ? notes.rescheduleHistory : [];
    history.push({ reason, updatedAt: now, userId });
    notes.rescheduleHistory = history;
  }
  notes.lastRescheduleAt = now;
  notes.lastRescheduleBy = userId;
  await execute(
    env2.DB,
    `UPDATE sessions
        SET scheduled_at = ?,
            duration_minutes = ?,
            preparation_notes = ?,
            updated_at = ?
      WHERE session_id = ?`,
    [newScheduledAt, newDuration, JSON.stringify(notes), now, sessionId]
  );
  const updated = await getSessionRow(env2, sessionId);
  if (!updated) throw new Error("\uC138\uC158\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  return mapSessionRow(updated, userId);
}
__name(rescheduleSession, "rescheduleSession");
async function submitSessionFeedback(env2, userId, sessionId, feedback) {
  const now = nowIso();
  const booking = await queryFirst(
    env2.DB,
    `SELECT * FROM session_bookings WHERE session_id = ? AND user_id = ? LIMIT 1`,
    [sessionId, userId]
  );
  if (booking) {
    const feedbackComment = JSON.stringify({
      comment: feedback.comment ?? null,
      partnerRating: feedback.partnerRating ?? null,
      partnerComment: feedback.partnerComment ?? null,
      tags: feedback.tags ?? [],
      improvementAreas: feedback.improvementAreas ?? [],
      wouldRecommend: feedback.wouldRecommend ?? false
    });
    await execute(
      env2.DB,
      `UPDATE session_bookings
          SET feedback_rating = ?,
              feedback_comment = ?,
              attended = 1,
              updated_at = ?
        WHERE booking_id = ?`,
      [feedback.rating ?? null, feedbackComment, now, booking.booking_id]
    );
  }
  return mergeSessionSummary(env2, sessionId, {
    sessionId,
    feedback: {
      rating: feedback.rating,
      comment: feedback.comment,
      partnerRating: feedback.partnerRating,
      partnerComment: feedback.partnerComment,
      tags: feedback.tags,
      improvementAreas: feedback.improvementAreas,
      wouldRecommend: feedback.wouldRecommend
    },
    updatedAt: now
  });
}
__name(submitSessionFeedback, "submitSessionFeedback");
async function listSessionHistory(env2, userId, page, size, partnerId) {
  const offset = (page - 1) * size;
  const filters = ["(s.host_user_id = ? OR s.guest_user_id = ?)"];
  const params = [userId, userId];
  if (partnerId) {
    filters.push("((s.host_user_id = ? AND s.guest_user_id = ?) OR (s.host_user_id = ? AND s.guest_user_id = ?))");
    params.push(userId, partnerId, partnerId, userId);
  }
  filters.push("s.status IN (?, ?)");
  params.push(SESSION_STATUS.COMPLETED, SESSION_STATUS.CANCELLED);
  const whereClause = `WHERE ${filters.join(" AND ")}`;
  const totalRow = await queryFirst(
    env2.DB,
    `SELECT COUNT(*) as count FROM sessions s ${whereClause}`,
    params
  );
  const rows = await query(
    env2.DB,
    `SELECT s.*, host.name AS host_name, host.profile_image AS host_profile_image,
            guest.name AS guest_name, guest.profile_image AS guest_profile_image
       FROM sessions s
       LEFT JOIN users host ON host.user_id = s.host_user_id
       LEFT JOIN users guest ON guest.user_id = s.guest_user_id
      ${whereClause}
      ORDER BY s.scheduled_at DESC
      LIMIT ? OFFSET ?`,
    params.concat([size, offset])
  );
  const data = rows.map((row) => mapSessionRow(row, userId));
  return { data, page, size, total: totalRow?.count ?? 0 };
}
__name(listSessionHistory, "listSessionHistory");
async function getSessionStats(env2, userId, period) {
  const now = /* @__PURE__ */ new Date();
  const start = new Date(now);
  if (period === "week") {
    start.setUTCDate(start.getUTCDate() - 7);
  } else if (period === "month") {
    start.setUTCMonth(start.getUTCMonth() - 1);
  } else {
    start.setUTCFullYear(start.getUTCFullYear() - 1);
  }
  const startIso = start.toISOString();
  const rows = await query(
    env2.DB,
    `SELECT s.*, host.name AS host_name, host.profile_image AS host_profile_image,
            guest.name AS guest_name, guest.profile_image AS guest_profile_image
       FROM sessions s
       LEFT JOIN users host ON host.user_id = s.host_user_id
       LEFT JOIN users guest ON guest.user_id = s.guest_user_id
      WHERE (s.host_user_id = ? OR s.guest_user_id = ?)
        AND s.scheduled_at >= ?
      ORDER BY s.scheduled_at DESC`,
    [userId, userId, startIso]
  );
  let completed = 0;
  let cancelled = 0;
  let upcoming = 0;
  let totalMinutes = 0;
  const partners = /* @__PURE__ */ new Set();
  const completedDates = /* @__PURE__ */ new Set();
  let lastSessionAt;
  for (const row of rows) {
    if (!lastSessionAt || row.scheduled_at > lastSessionAt) {
      lastSessionAt = row.scheduled_at;
    }
    const otherUser = row.host_user_id === userId ? row.guest_user_id : row.host_user_id;
    if (otherUser) partners.add(otherUser);
    if (row.status === SESSION_STATUS.COMPLETED) {
      completed += 1;
      totalMinutes += Number(row.duration_minutes ?? 0);
      completedDates.add(new Date(row.scheduled_at).toISOString().slice(0, 10));
    } else if (row.status === SESSION_STATUS.CANCELLED) {
      cancelled += 1;
    } else if (row.status === SESSION_STATUS.SCHEDULED) {
      upcoming += 1;
    }
  }
  const averageDuration = completed > 0 ? totalMinutes / completed : 0;
  const streakDays = (() => {
    if (completedDates.size === 0) return 0;
    const cursor = /* @__PURE__ */ new Date();
    let streak = 0;
    for (; ; ) {
      const key = cursor.toISOString().slice(0, 10);
      if (completedDates.has(key)) {
        streak += 1;
        cursor.setUTCDate(cursor.getUTCDate() - 1);
      } else {
        break;
      }
    }
    return streak;
  })();
  return {
    period,
    totalSessions: rows.length,
    completedSessions: completed,
    cancelledSessions: cancelled,
    upcomingSessions: upcoming,
    totalMinutes,
    averageDuration,
    partnersCount: partners.size,
    streakDays,
    lastSessionAt
  };
}
__name(getSessionStats, "getSessionStats");
async function listUpcomingSessions(env2, userId, limit) {
  const rows = await query(
    env2.DB,
    `SELECT s.*, host.name AS host_name, host.profile_image AS host_profile_image,
            guest.name AS guest_name, guest.profile_image AS guest_profile_image
       FROM sessions s
       LEFT JOIN users host ON host.user_id = s.host_user_id
       LEFT JOIN users guest ON guest.user_id = s.guest_user_id
      WHERE (s.host_user_id = ? OR s.guest_user_id = ?)
        AND s.status = ?
        AND s.scheduled_at >= ?
      ORDER BY s.scheduled_at ASC
      LIMIT ?`,
    [userId, userId, SESSION_STATUS.SCHEDULED, nowIso(), limit]
  );
  return rows.map((row) => mapSessionRow(row, userId));
}
__name(listUpcomingSessions, "listUpcomingSessions");
async function getSessionParticipants(env2, sessionId) {
  const row = await getSessionRow(env2, sessionId);
  if (!row) throw new Error("\uC138\uC158\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  const participants = [];
  participants.push({
    userId: row.host_user_id,
    name: row.host_name ?? void 0,
    profileImage: row.host_profile_image ?? void 0,
    role: "HOST",
    joinedAt: row.created_at
  });
  if (row.guest_user_id) {
    participants.push({
      userId: row.guest_user_id,
      name: row.guest_name ?? void 0,
      profileImage: row.guest_profile_image ?? void 0,
      role: "GUEST",
      joinedAt: row.created_at
    });
  }
  const bookingRows = await query(
    env2.DB,
    `SELECT b.*, u.name, u.profile_image
       FROM session_bookings b
       LEFT JOIN users u ON u.user_id = b.user_id
      WHERE b.session_id = ? AND b.status = ?`,
    [sessionId, BOOKING_STATUS.CONFIRMED]
  );
  for (const booking of bookingRows) {
    if (booking.user_id === row.host_user_id || booking.user_id === row.guest_user_id) {
      continue;
    }
    participants.push({
      userId: booking.user_id,
      name: booking.name ?? void 0,
      profileImage: booking.profile_image ?? void 0,
      role: "BOOKED",
      joinedAt: booking.created_at
    });
  }
  return participants;
}
__name(getSessionParticipants, "getSessionParticipants");
async function generateSessionInvite(env2, userId, sessionId, expiresInHours = 24) {
  const session = await ensureSessionExists(env2, sessionId);
  if (session.host_user_id !== userId) {
    throw new Error("\uCD08\uB300 \uB9C1\uD06C\uB97C \uC0DD\uC131\uD560 \uAD8C\uD55C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  const token = crypto.randomUUID();
  const hours = Number.isFinite(expiresInHours) ? Math.max(1, expiresInHours) : DEFAULT_INVITE_EXPIRATION_HOURS;
  const now = nowIso();
  const expiresAt = new Date(Date.now() + hours * 3600 * 1e3).toISOString();
  await insertInviteRow(env2, {
    invite_token: token,
    session_id: sessionId,
    inviter_user_id: userId,
    expires_at: expiresAt,
    created_at: now,
    used_at: null,
    used_by: null
  });
  const baseUrl = env2.API_BASE_URL ?? "";
  const joinUrl = baseUrl ? `${baseUrl}/sessions/join?token=${token}` : `/sessions/join?token=${token}`;
  return { sessionId, inviteToken: token, expiresAt, joinUrl };
}
__name(generateSessionInvite, "generateSessionInvite");
async function acceptSessionInvite(env2, userId, token) {
  const record2 = await fetchInviteRow(env2, token);
  if (!record2) {
    throw new Error("\uC720\uD6A8\uD558\uC9C0 \uC54A\uC740 \uCD08\uB300 \uD1A0\uD070\uC785\uB2C8\uB2E4.");
  }
  if (record2.used_at) {
    throw new Error("\uC774\uBBF8 \uC0AC\uC6A9\uB41C \uCD08\uB300 \uD1A0\uD070\uC785\uB2C8\uB2E4.");
  }
  if (new Date(record2.expires_at).getTime() < Date.now()) {
    throw new Error("\uCD08\uB300 \uD1A0\uD070\uC774 \uB9CC\uB8CC\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
  }
  const now = nowIso();
  await markInviteUsed(env2, token, userId, now);
  return joinSession(env2, userId, record2.session_id);
}
__name(acceptSessionInvite, "acceptSessionInvite");
async function getSessionNotifications(env2, sessionId, userId) {
  const row = await fetchNotificationRow(env2, sessionId, userId);
  if (row) {
    return {
      reminderBefore: row.reminder_before,
      enableEmailReminder: intToBool(row.enable_email),
      enablePushReminder: intToBool(row.enable_push),
      enableSmsReminder: intToBool(row.enable_sms),
      updatedAt: row.updated_at
    };
  }
  return { ...NOTIFICATION_DEFAULTS, updatedAt: nowIso() };
}
__name(getSessionNotifications, "getSessionNotifications");
async function updateSessionNotifications(env2, sessionId, userId, settings) {
  const current = await getSessionNotifications(env2, sessionId, userId);
  const merged = {
    reminderBefore: settings.reminderBefore ?? current.reminderBefore,
    enableEmailReminder: settings.enableEmailReminder ?? current.enableEmailReminder,
    enablePushReminder: settings.enablePushReminder ?? current.enablePushReminder,
    enableSmsReminder: settings.enableSmsReminder ?? current.enableSmsReminder,
    updatedAt: nowIso()
  };
  await upsertNotificationRow(env2, sessionId, userId, merged);
  return merged;
}
__name(updateSessionNotifications, "updateSessionNotifications");
async function requestSessionRecording(env2, userId, sessionId, options) {
  const session = await ensureSessionExists(env2, sessionId);
  if (session.host_user_id !== userId) {
    throw new Error("\uB179\uD654\uB97C \uC694\uCCAD\uD560 \uAD8C\uD55C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  const status = {
    sessionId,
    status: "scheduled",
    recordAudio: options.recordAudio ?? true,
    recordVideo: options.recordVideo ?? false,
    recordTranscript: options.recordTranscript ?? true,
    downloadUrl: void 0,
    message: options.language ? `Recording language: ${options.language}` : void 0,
    updatedAt: nowIso()
  };
  await upsertRecordingRow(env2, sessionId, status);
  return status;
}
__name(requestSessionRecording, "requestSessionRecording");
async function stopSessionRecording(env2, userId, sessionId) {
  const session = await ensureSessionExists(env2, sessionId);
  if (session.host_user_id !== userId) {
    throw new Error("\uB179\uD654\uB97C \uC911\uB2E8\uD560 \uAD8C\uD55C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  const current = await fetchRecordingRow(env2, sessionId);
  const status = {
    sessionId,
    status: "completed",
    recordAudio: current ? intToBool(current.record_audio) : true,
    recordVideo: current ? intToBool(current.record_video) : false,
    recordTranscript: current ? intToBool(current.record_transcript) : true,
    downloadUrl: current?.download_url ?? `/sessions/${sessionId}/recordings/latest`,
    updatedAt: nowIso()
  };
  await upsertRecordingRow(env2, sessionId, status);
  return status;
}
__name(stopSessionRecording, "stopSessionRecording");
async function getSessionRecording(env2, sessionId) {
  const stored = await fetchRecordingRow(env2, sessionId);
  if (stored) {
    return {
      sessionId,
      status: stored.status,
      recordAudio: intToBool(stored.record_audio),
      recordVideo: intToBool(stored.record_video),
      recordTranscript: intToBool(stored.record_transcript),
      downloadUrl: stored.download_url ?? void 0,
      message: stored.message ?? void 0,
      updatedAt: stored.updated_at
    };
  }
  return {
    sessionId,
    status: "idle",
    recordAudio: false,
    recordVideo: false,
    recordTranscript: false,
    updatedAt: nowIso()
  };
}
__name(getSessionRecording, "getSessionRecording");
async function getSessionSummary(env2, sessionId) {
  const cached2 = await getStoredSessionSummary(env2, sessionId);
  if (cached2) return cached2;
  return buildDefaultSessionSummary(env2, sessionId);
}
__name(getSessionSummary, "getSessionSummary");
async function getSessionTranscript(env2, sessionId, language = "default") {
  const row = await fetchTranscriptRow(env2, sessionId, language);
  if (row) {
    return deserializeTranscriptRow(row);
  }
  const now = nowIso();
  const transcript = {
    sessionId,
    language,
    segments: [],
    generatedAt: now
  };
  await upsertTranscriptRow(env2, {
    session_id: sessionId,
    language,
    segments: JSON.stringify(transcript.segments),
    generated_at: now,
    updated_at: now
  });
  return transcript;
}
__name(getSessionTranscript, "getSessionTranscript");

// src/routes/sessions.ts
var sessionsRoutes = new Hono2();
var requireAuth3 = auth();
function getPaginationParams(c) {
  const page = Math.max(Number(c.req.query("page") ?? "1"), 1);
  const size = Math.max(Math.min(Number(c.req.query("size") ?? "20"), 50), 1);
  return { page, size };
}
__name(getPaginationParams, "getPaginationParams");
function parseSessionId(c) {
  const sessionId = Number(c.req.param("sessionId"));
  if (!Number.isFinite(sessionId)) throw new AppError("Invalid sessionId", 400, "INVALID_PATH_PARAM");
  return sessionId;
}
__name(parseSessionId, "parseSessionId");
function normalizeCreatePayload(body) {
  if (!body || typeof body !== "object") {
    throw new AppError("Invalid payload", 400, "INVALID_PAYLOAD");
  }
  const scheduledAt = typeof body.scheduledAt === "string" ? body.scheduledAt : null;
  if (!scheduledAt) {
    throw new AppError("scheduledAt is required", 400, "INVALID_PAYLOAD");
  }
  const sessionTypeRaw = typeof body.sessionType === "string" ? body.sessionType : typeof body.type === "string" ? body.type : null;
  const sessionType = sessionTypeRaw ? String(sessionTypeRaw).toUpperCase() : "VIDEO";
  const durationMinutes = typeof body.durationMinutes === "number" ? body.durationMinutes : typeof body.duration === "number" ? body.duration : 30;
  const payload = {
    title: typeof body.title === "string" ? body.title : typeof body.topic === "string" ? body.topic : "Study Session",
    description: typeof body.description === "string" ? body.description : typeof body.topic === "string" ? body.topic : void 0,
    sessionType,
    languageCode: typeof body.languageCode === "string" ? body.languageCode : typeof body.language === "string" ? body.language : void 0,
    skillFocus: typeof body.skillFocus === "string" ? body.skillFocus : typeof body.targetLanguage === "string" ? body.targetLanguage : void 0,
    levelRequirement: typeof body.levelRequirement === "string" ? body.levelRequirement : void 0,
    scheduledAt,
    durationMinutes,
    maxParticipants: typeof body.maxParticipants === "number" ? body.maxParticipants : void 0,
    isRecurring: Boolean(body.isRecurring),
    recurrencePattern: typeof body.recurrencePattern === "string" ? body.recurrencePattern : void 0,
    recurrenceEndDate: typeof body.recurrenceEndDate === "string" ? body.recurrenceEndDate : void 0,
    isPublic: typeof body.isPublic === "boolean" ? body.isPublic : void 0,
    tags: typeof body.tags === "string" ? body.tags : void 0,
    preparationNotes: typeof body.preparationNotes === "string" ? body.preparationNotes : void 0,
    meetingUrl: typeof body.meetingUrl === "string" ? body.meetingUrl : void 0,
    partnerId: typeof body.partnerId === "string" ? body.partnerId : void 0,
    topic: typeof body.topic === "string" ? body.topic : void 0,
    language: typeof body.language === "string" ? body.language : void 0,
    targetLanguage: typeof body.targetLanguage === "string" ? body.targetLanguage : void 0,
    webRtcRoomId: typeof body.webRtcRoomId === "string" ? body.webRtcRoomId : void 0,
    webRtcRoomType: typeof body.webRtcRoomType === "string" ? body.webRtcRoomType : void 0,
    duration: typeof body.duration === "number" ? body.duration : void 0,
    metadata: typeof body.metadata === "object" && body.metadata !== null ? body.metadata : void 0
  };
  return payload;
}
__name(normalizeCreatePayload, "normalizeCreatePayload");
sessionsRoutes.use("*", requireAuth3);
sessionsRoutes.get("/", async (c) => {
  const { page, size } = getPaginationParams(c);
  const status = c.req.query("status") ?? void 0;
  const result = await listSessions(c.env, page, size, status);
  return paginatedResponse(c, result.data, {
    page: result.page,
    limit: result.size,
    total: result.total
  });
});
sessionsRoutes.post("/", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  const payload = normalizeCreatePayload(body);
  const session = await createSession2(c.env, userId, payload);
  return successResponse(c, session);
});
sessionsRoutes.post("/:sessionId/join", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const sessionId = parseSessionId(c);
  const body = await c.req.json().catch(() => ({}));
  const bookingMessage = typeof body?.bookingMessage === "string" ? body.bookingMessage : void 0;
  const session = await joinSession(c.env, userId, sessionId, bookingMessage);
  return successResponse(c, session);
});
sessionsRoutes.post("/book", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  if (typeof body.sessionId !== "number") {
    throw new AppError("sessionId is required", 400, "INVALID_PAYLOAD");
  }
  const booking = await bookSession(c.env, userId, {
    sessionId: body.sessionId,
    bookingMessage: typeof body.bookingMessage === "string" ? body.bookingMessage : void 0
  });
  return successResponse(c, booking);
});
sessionsRoutes.delete("/bookings/:bookingId", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const bookingId = Number(c.req.param("bookingId"));
  if (!Number.isFinite(bookingId)) throw new AppError("Invalid bookingId", 400, "INVALID_PATH_PARAM");
  const reason = c.req.query("reason") ?? void 0;
  await cancelBooking(c.env, userId, bookingId, reason);
  return successResponse(c, { success: true });
});
sessionsRoutes.get("/my-sessions", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const { page, size } = getPaginationParams(c);
  const result = await listUserSessions(c.env, userId, page, size);
  return paginatedResponse(c, result.data, {
    page: result.page,
    limit: result.size,
    total: result.total
  });
});
sessionsRoutes.get("/public", async (c) => {
  const { page, size } = getPaginationParams(c);
  const result = await listPublicSessions(c.env, page, size);
  return paginatedResponse(c, result.data, {
    page: result.page,
    limit: result.size,
    total: result.total
  });
});
sessionsRoutes.get("/language/:languageCode", async (c) => {
  const { page, size } = getPaginationParams(c);
  const languageCode = c.req.param("languageCode");
  const result = await listSessionsByLanguage(c.env, languageCode, page, size);
  return paginatedResponse(c, result.data, {
    page: result.page,
    limit: result.size,
    total: result.total
  });
});
sessionsRoutes.get("/type/:sessionType", async (c) => {
  const { page, size } = getPaginationParams(c);
  const sessionType = c.req.param("sessionType");
  const result = await listSessionsByType(c.env, sessionType, page, size);
  return paginatedResponse(c, result.data, {
    page: result.page,
    limit: result.size,
    total: result.total
  });
});
sessionsRoutes.get("/available", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const { page, size } = getPaginationParams(c);
  const result = await listAvailableSessions(c.env, userId, page, size);
  return paginatedResponse(c, result.data, {
    page: result.page,
    limit: result.size,
    total: result.total
  });
});
sessionsRoutes.get("/my-bookings", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const { page, size } = getPaginationParams(c);
  const result = await listUserBookings(c.env, userId, page, size);
  return paginatedResponse(c, result.data, {
    page: result.page,
    limit: result.size,
    total: result.total
  });
});
sessionsRoutes.get("/history", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const { page, size } = getPaginationParams(c);
  const partnerId = c.req.query("partnerId") ?? void 0;
  const result = await listSessionHistory(c.env, userId, page, size, typeof partnerId === "string" ? partnerId : void 0);
  return paginatedResponse(c, result.data, {
    page: result.page,
    limit: result.size,
    total: result.total
  });
});
sessionsRoutes.get("/stats", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const periodParam = (c.req.query("period") ?? "month").toString().toLowerCase();
  const period = periodParam === "week" || periodParam === "year" ? periodParam : "month";
  const stats = await getSessionStats(c.env, userId, period);
  return successResponse(c, stats);
});
sessionsRoutes.get("/upcoming", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const limitRaw = Number(c.req.query("limit") ?? "5");
  const limit = Math.max(1, Math.min(Number.isFinite(limitRaw) ? limitRaw : 5, 20));
  const sessions = await listUpcomingSessions(c.env, userId, limit);
  return successResponse(c, sessions);
});
sessionsRoutes.get("/calendar", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const start = c.req.query("startDate") ?? (/* @__PURE__ */ new Date()).toISOString();
  const end = c.req.query("endDate") ?? addDaysIso(7);
  const calendar = await getUserCalendar(c.env, userId, start, end);
  return successResponse(c, calendar);
});
sessionsRoutes.get("/:sessionId/notifications", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const sessionId = parseSessionId(c);
  const settings = await getSessionNotifications(c.env, sessionId, userId);
  return successResponse(c, settings);
});
sessionsRoutes.patch("/:sessionId/notifications", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const sessionId = parseSessionId(c);
  const body = await c.req.json().catch(() => ({}));
  const settings = await updateSessionNotifications(c.env, sessionId, userId, body);
  return successResponse(c, settings);
});
sessionsRoutes.post("/:sessionId/feedback", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const sessionId = parseSessionId(c);
  const body = await c.req.json().catch(() => ({}));
  const summary = await submitSessionFeedback(c.env, userId, sessionId, body ?? {});
  return successResponse(c, summary);
});
sessionsRoutes.patch("/:sessionId/reschedule", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const sessionId = parseSessionId(c);
  const body = await c.req.json().catch(() => ({}));
  const session = await rescheduleSession(c.env, userId, sessionId, {
    scheduledAt: typeof body?.scheduledAt === "string" ? body.scheduledAt : void 0,
    duration: typeof body?.duration === "number" ? body.duration : void 0,
    reason: typeof body?.reason === "string" ? body.reason : void 0
  });
  return successResponse(c, session);
});
sessionsRoutes.post("/:sessionId/invite", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const sessionId = parseSessionId(c);
  const body = await c.req.json().catch(() => ({}));
  const expiresInHours = Number(body?.expiresInHours ?? 24);
  const invite = await generateSessionInvite(c.env, userId, sessionId, Number.isFinite(expiresInHours) ? expiresInHours : 24);
  return successResponse(c, invite);
});
sessionsRoutes.post("/invite/accept", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  const token = typeof body?.token === "string" ? body.token : "";
  if (!token) throw new AppError("Invite token is required", 400, "INVALID_PAYLOAD");
  const session = await acceptSessionInvite(c.env, userId, token);
  return successResponse(c, session);
});
sessionsRoutes.post("/:sessionId/recording", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const sessionId = parseSessionId(c);
  const body = await c.req.json().catch(() => ({}));
  const status = await requestSessionRecording(c.env, userId, sessionId, body ?? {});
  return successResponse(c, status);
});
sessionsRoutes.post("/:sessionId/recording/stop", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const sessionId = parseSessionId(c);
  const status = await stopSessionRecording(c.env, userId, sessionId);
  return successResponse(c, status);
});
sessionsRoutes.get("/:sessionId/recording", async (c) => {
  const sessionId = parseSessionId(c);
  const status = await getSessionRecording(c.env, sessionId);
  return successResponse(c, status);
});
sessionsRoutes.get("/:sessionId/participants", async (c) => {
  const sessionId = parseSessionId(c);
  const participants = await getSessionParticipants(c.env, sessionId);
  return successResponse(c, participants);
});
sessionsRoutes.get("/:sessionId/summary", async (c) => {
  const sessionId = parseSessionId(c);
  const summary = await getSessionSummary(c.env, sessionId);
  return successResponse(c, summary);
});
sessionsRoutes.get("/:sessionId/transcript", async (c) => {
  const sessionId = parseSessionId(c);
  const language = c.req.query("language") ?? "default";
  const transcript = await getSessionTranscript(c.env, sessionId, typeof language === "string" ? language : "default");
  return successResponse(c, transcript);
});
sessionsRoutes.get("/:sessionId", async (c) => {
  const userId = c.get("userId");
  const sessionId = parseSessionId(c);
  const session = await getSessionById(c.env, sessionId, userId);
  return successResponse(c, session);
});
sessionsRoutes.post("/:sessionId/start", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const sessionId = parseSessionId(c);
  await startSession(c.env, userId, sessionId);
  return successResponse(c, { success: true });
});
sessionsRoutes.post("/:sessionId/end", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const sessionId = parseSessionId(c);
  const body = await c.req.json().catch(() => ({}));
  await endSession(c.env, userId, sessionId, {
    duration: typeof body?.duration === "number" ? body.duration : void 0,
    notes: typeof body?.notes === "string" ? body.notes : void 0,
    rating: typeof body?.rating === "number" ? body.rating : void 0
  });
  return successResponse(c, { success: true });
});
sessionsRoutes.post("/:sessionId/cancel", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const sessionId = parseSessionId(c);
  const body = await c.req.json().catch(() => ({}));
  const reason = typeof body?.reason === "string" ? body.reason : void 0;
  await cancelSession(c.env, userId, sessionId, reason);
  return successResponse(c, { success: true });
});
sessionsRoutes.delete("/:sessionId", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const sessionId = parseSessionId(c);
  const reason = c.req.query("reason") ?? void 0;
  await cancelSession(c.env, userId, sessionId, typeof reason === "string" ? reason : void 0);
  return successResponse(c, { success: true });
});
function addDaysIso(days) {
  const d = /* @__PURE__ */ new Date();
  d.setUTCDate(d.getUTCDate() + days);
  return d.toISOString();
}
__name(addDaysIso, "addDaysIso");
var sessions_default = sessionsRoutes;

// src/routes/notifications.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_errors();

// src/services/notifications.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_db();
var DEFAULT_PAGE_SIZE = 20;
var MAX_PAGE_SIZE = 100;
function nowIso2() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
__name(nowIso2, "nowIso");
function normalizePageSize(size) {
  if (!size || Number.isNaN(size)) return DEFAULT_PAGE_SIZE;
  return Math.max(1, Math.min(size, MAX_PAGE_SIZE));
}
__name(normalizePageSize, "normalizePageSize");
function normalizePage(page) {
  if (!page || Number.isNaN(page) || page < 1) return 1;
  return page;
}
__name(normalizePage, "normalizePage");
function parseJson(value) {
  if (!value) return null;
  try {
    return JSON.parse(value);
  } catch (error48) {
    return null;
  }
}
__name(parseJson, "parseJson");
function mapNotificationRow(row) {
  const expiresAt = row.expires_at ?? void 0;
  const priority = row.priority ?? 1;
  const expired = expiresAt ? new Date(expiresAt) < /* @__PURE__ */ new Date() : void 0;
  const highPriority = priority >= 3;
  const scheduleMetadata = parseJson(row.schedule_metadata);
  return {
    userId: row.user_id,
    notificationId: row.notification_id,
    type: row.type,
    title: row.title,
    content: row.content,
    actionUrl: row.action_url ?? void 0,
    actionData: parseJson(row.action_data) ?? void 0,
    imageUrl: row.image_url ?? void 0,
    iconUrl: row.icon_url ?? void 0,
    status: row.status,
    priority,
    category: row.category ?? void 0,
    scheduledAt: row.scheduled_at ?? void 0,
    sentAt: row.sent_at ?? void 0,
    readAt: row.read_at ?? void 0,
    expiresAt,
    createdAt: row.created_at,
    isPersistent: Boolean(row.is_persistent ?? 1),
    senderUserId: row.sender_user_id ?? void 0,
    templateId: row.template_id ?? void 0,
    deliveryChannels: row.delivery_channels ?? void 0,
    pushSent: Boolean(row.push_sent ?? 0),
    emailSent: Boolean(row.email_sent ?? 0),
    smsSent: Boolean(row.sms_sent ?? 0),
    expired,
    highPriority,
    scheduleMetadata
  };
}
__name(mapNotificationRow, "mapNotificationRow");
function toListItem(record2) {
  return {
    id: record2.notificationId,
    type: record2.type,
    category: record2.category,
    title: record2.title,
    message: record2.content,
    content: record2.content,
    isRead: record2.status === "READ",
    status: record2.status,
    priority: record2.priority,
    createdAt: record2.createdAt,
    readAt: record2.readAt,
    scheduledAt: record2.scheduledAt,
    expiresAt: record2.expiresAt,
    clickUrl: record2.actionUrl,
    data: record2.actionData ?? void 0,
    imageUrl: record2.imageUrl,
    iconUrl: record2.iconUrl,
    highPriority: record2.highPriority,
    expired: record2.expired
  };
}
__name(toListItem, "toListItem");
function mapPreferenceRow(row) {
  return {
    notificationsEnabled: Boolean(row.notifications_enabled),
    pushEnabled: Boolean(row.push_enabled),
    emailEnabled: Boolean(row.email_enabled),
    smsEnabled: Boolean(row.sms_enabled),
    sessionNotifications: Boolean(row.session_notifications),
    sessionReminders: Boolean(row.session_reminders),
    matchingNotifications: Boolean(row.matching_notifications),
    chatNotifications: Boolean(row.chat_notifications),
    levelTestNotifications: Boolean(row.level_test_notifications),
    systemNotifications: Boolean(row.system_notifications),
    marketingNotifications: Boolean(row.marketing_notifications),
    quietHoursEnabled: Boolean(row.quiet_hours_enabled),
    quietHoursStart: row.quiet_hours_start ?? void 0,
    quietHoursEnd: row.quiet_hours_end ?? void 0,
    timezone: row.timezone ?? void 0,
    notificationLanguage: row.notification_language ?? void 0,
    digestEnabled: Boolean(row.digest_enabled),
    digestFrequency: row.digest_frequency ?? void 0,
    digestTime: row.digest_time ?? void 0
  };
}
__name(mapPreferenceRow, "mapPreferenceRow");
function parseRecurringSchedule(raw2) {
  if (!raw2 || typeof raw2 !== "object") {
    return null;
  }
  const record2 = raw2;
  const typeValue = typeof record2.type === "string" ? record2.type.toLowerCase() : "";
  if (!["daily", "weekly", "monthly"].includes(typeValue)) {
    return null;
  }
  const intervalValue = record2.interval !== void 0 ? Number(record2.interval) : void 0;
  const interval = Number.isFinite(intervalValue) && intervalValue !== void 0 && intervalValue > 0 ? Math.floor(intervalValue) : void 0;
  const endDate = typeof record2.endDate === "string" ? record2.endDate : void 0;
  const time5 = typeof record2.time === "string" ? record2.time : void 0;
  return {
    type: typeValue,
    interval,
    endDate,
    time: time5
  };
}
__name(parseRecurringSchedule, "parseRecurringSchedule");
function addDays(date5, days) {
  const result = new Date(date5.getTime());
  result.setUTCDate(result.getUTCDate() + days);
  return result;
}
__name(addDays, "addDays");
function addMonths(date5, months) {
  const result = new Date(date5.getTime());
  const currentDate = result.getUTCDate();
  result.setUTCMonth(result.getUTCMonth() + months);
  while (result.getUTCDate() < currentDate) {
    result.setUTCDate(result.getUTCDate() - 1);
  }
  return result;
}
__name(addMonths, "addMonths");
function applyTimeComponent(date5, metadata, fallback) {
  const timeString = metadata.time;
  if (!timeString) {
    date5.setUTCHours(
      fallback.getUTCHours(),
      fallback.getUTCMinutes(),
      fallback.getUTCSeconds(),
      fallback.getUTCMilliseconds()
    );
    return;
  }
  const match = timeString.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
  if (!match) {
    date5.setUTCHours(
      fallback.getUTCHours(),
      fallback.getUTCMinutes(),
      fallback.getUTCSeconds(),
      fallback.getUTCMilliseconds()
    );
    return;
  }
  const hours = Number(match[1]);
  const minutes = Number(match[2]);
  const seconds = match[3] ? Number(match[3]) : 0;
  date5.setUTCHours(hours, minutes, seconds, 0);
}
__name(applyTimeComponent, "applyTimeComponent");
function computeNextScheduledAt(currentIso, metadata, reference) {
  if (!currentIso) {
    return null;
  }
  const base = new Date(currentIso);
  if (Number.isNaN(base.getTime())) {
    return null;
  }
  const interval = Math.max(1, metadata.interval ?? 1);
  let next = new Date(base.getTime());
  const advance = /* @__PURE__ */ __name(() => {
    switch (metadata.type) {
      case "daily":
        next = addDays(next, interval);
        break;
      case "weekly":
        next = addDays(next, interval * 7);
        break;
      case "monthly":
        next = addMonths(next, interval);
        break;
      default:
        next = addDays(next, interval);
        break;
    }
  }, "advance");
  advance();
  applyTimeComponent(next, metadata, base);
  const endDate = metadata.endDate ? new Date(metadata.endDate) : null;
  while (next <= reference) {
    advance();
    applyTimeComponent(next, metadata, base);
    if (endDate && next > endDate) {
      return null;
    }
  }
  if (endDate && next > endDate) {
    return null;
  }
  return next.toISOString();
}
__name(computeNextScheduledAt, "computeNextScheduledAt");
async function ensurePreference(env2, userId) {
  const existing = await queryFirst(
    env2.DB,
    "SELECT * FROM notification_preferences WHERE user_id = ? LIMIT 1",
    [userId]
  );
  if (existing) {
    return existing;
  }
  const now = nowIso2();
  await execute(
    env2.DB,
    `INSERT INTO notification_preferences (
        user_id,
        notifications_enabled,
        push_enabled,
        email_enabled,
        sms_enabled,
        session_notifications,
        session_reminders,
        matching_notifications,
        chat_notifications,
        level_test_notifications,
        system_notifications,
        marketing_notifications,
        quiet_hours_enabled,
        timezone,
        notification_language,
        digest_enabled,
        digest_frequency,
        digest_time,
        created_at,
        updated_at
      ) VALUES (?, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, NULL, 'ko', 0, 'DAILY', '09:00', ?, ?)
    `,
    [userId, now, now]
  );
  const inserted = await queryFirst(
    env2.DB,
    "SELECT * FROM notification_preferences WHERE user_id = ? LIMIT 1",
    [userId]
  );
  if (!inserted) {
    throw new Error("\uC54C\uB9BC \uC124\uC815\uC744 \uCD08\uAE30\uD654\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  return inserted;
}
__name(ensurePreference, "ensurePreference");
async function listSubscriptionTopics(env2, userId) {
  const rows = await query(
    env2.DB,
    "SELECT topic FROM notification_topic_subscription WHERE user_id = ? ORDER BY topic",
    [userId]
  );
  return rows.map((row) => row.topic);
}
__name(listSubscriptionTopics, "listSubscriptionTopics");
async function createNotification(env2, payload) {
  const now = nowIso2();
  const actionData = payload.actionData ? JSON.stringify(payload.actionData) : null;
  const templateVariables = payload.templateVariables ? JSON.stringify(payload.templateVariables) : null;
  const scheduleMetadata = payload.scheduleMetadata ? JSON.stringify(payload.scheduleMetadata) : null;
  const status = payload.status ?? (payload.scheduledAt ? "SCHEDULED" : "UNREAD");
  await execute(
    env2.DB,
    `INSERT INTO notifications (
        user_id,
        type,
        title,
        content,
        action_url,
        action_data,
        image_url,
        icon_url,
        status,
        priority,
        category,
        scheduled_at,
        sent_at,
        read_at,
        expires_at,
        is_persistent,
        sender_user_id,
        template_id,
        template_variables,
        schedule_metadata,
        delivery_channels,
        push_sent,
        email_sent,
        sms_sent,
        created_at,
        updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NULL, NULL, ?, ?, ?, ?, ?, ?, ?, 0, 0, 0, ?, ?)
    `,
    [
      payload.userId,
      payload.type,
      payload.title,
      payload.content,
      payload.actionUrl ?? null,
      actionData,
      payload.imageUrl ?? null,
      payload.iconUrl ?? null,
      status,
      payload.priority ?? 1,
      payload.category ?? null,
      payload.scheduledAt ?? null,
      payload.expiresAt ?? null,
      payload.isPersistent === false ? 0 : 1,
      payload.senderUserId ?? null,
      payload.templateId ?? null,
      templateVariables,
      scheduleMetadata,
      payload.deliveryChannels ?? null,
      now,
      now
    ]
  );
  const row = await queryFirst(
    env2.DB,
    "SELECT last_insert_rowid() as id"
  );
  const notificationId = Number(row?.id ?? 0);
  if (!notificationId) {
    throw new Error("\uC54C\uB9BC \uC0DD\uC131 \uACB0\uACFC\uB97C \uD655\uC778\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  return getNotificationById(env2, notificationId);
}
__name(createNotification, "createNotification");
async function getNotificationById(env2, notificationId) {
  const row = await queryFirst(
    env2.DB,
    "SELECT * FROM notifications WHERE notification_id = ? LIMIT 1",
    [notificationId]
  );
  if (!row) {
    throw new Error("\uC54C\uB9BC\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  return mapNotificationRow(row);
}
__name(getNotificationById, "getNotificationById");
async function listNotifications(env2, userId, options = {}) {
  const page = normalizePage(options.page);
  const size = normalizePageSize(options.size);
  const offset = (page - 1) * size;
  const where = ["user_id = ?"];
  const params = [userId];
  if (options.category) {
    where.push("UPPER(category) = UPPER(?)");
    params.push(options.category);
  }
  if (options.unreadOnly) {
    where.push("status = 'UNREAD'");
  } else if (options.status) {
    where.push("status = ?");
    params.push(options.status);
  }
  const whereClause = `WHERE ${where.join(" AND ")}`;
  const totalRow = await queryFirst(
    env2.DB,
    `SELECT COUNT(*) as count FROM notifications ${whereClause}`,
    params
  );
  const rows = await query(
    env2.DB,
    `SELECT * FROM notifications
      ${whereClause}
      ORDER BY created_at DESC
      LIMIT ? OFFSET ?`,
    [...params, size, offset]
  );
  const records = rows.map(mapNotificationRow);
  const unreadCount = await getUnreadCount(env2, userId);
  return {
    data: records.map(toListItem),
    page,
    size,
    total: totalRow?.count ?? 0,
    unreadCount
  };
}
__name(listNotifications, "listNotifications");
async function getUnreadCount(env2, userId) {
  const row = await queryFirst(
    env2.DB,
    "SELECT COUNT(*) as count FROM notifications WHERE user_id = ? AND status = 'UNREAD'",
    [userId]
  );
  return row?.count ?? 0;
}
__name(getUnreadCount, "getUnreadCount");
async function markAsRead(env2, userId, notificationId) {
  const record2 = await getNotificationById(env2, notificationId);
  if (record2.userId !== userId) {
    throw new Error("\uC54C\uB9BC\uC744 \uC77D\uC74C\uC73C\uB85C \uD45C\uC2DC\uD560 \uAD8C\uD55C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  const now = nowIso2();
  await execute(
    env2.DB,
    `UPDATE notifications
        SET status = 'READ', read_at = ?, updated_at = ?
      WHERE notification_id = ?`,
    [now, now, notificationId]
  );
}
__name(markAsRead, "markAsRead");
async function markAllAsRead(env2, userId) {
  const now = nowIso2();
  await execute(
    env2.DB,
    `UPDATE notifications SET status = 'READ', read_at = ?, updated_at = ?
      WHERE user_id = ? AND status = 'UNREAD'`,
    [now, now, userId]
  );
}
__name(markAllAsRead, "markAllAsRead");
async function deleteNotification(env2, userId, notificationId) {
  await execute(
    env2.DB,
    "DELETE FROM notifications WHERE notification_id = ? AND user_id = ?",
    [notificationId, userId]
  );
}
__name(deleteNotification, "deleteNotification");
async function deleteAllNotifications(env2, userId) {
  await execute(env2.DB, "DELETE FROM notifications WHERE user_id = ?", [userId]);
}
__name(deleteAllNotifications, "deleteAllNotifications");
async function deleteNotificationsBatch(env2, userId, notificationIds) {
  const ids = notificationIds.filter((id) => Number.isFinite(id));
  if (!ids.length) {
    return;
  }
  const placeholders = ids.map(() => "?").join(", ");
  await execute(
    env2.DB,
    `DELETE FROM notifications WHERE user_id = ? AND notification_id IN (${placeholders})`,
    [userId, ...ids]
  );
}
__name(deleteNotificationsBatch, "deleteNotificationsBatch");
async function cancelScheduledNotification(env2, userId, notificationId) {
  const row = await queryFirst(
    env2.DB,
    "SELECT * FROM notifications WHERE notification_id = ? AND user_id = ? LIMIT 1",
    [notificationId, userId]
  );
  if (!row) {
    return false;
  }
  if (row.status !== "SCHEDULED") {
    await deleteNotification(env2, userId, notificationId);
    return true;
  }
  await execute(
    env2.DB,
    "UPDATE notifications SET status = 'CANCELLED', updated_at = ?, schedule_metadata = NULL WHERE notification_id = ?",
    [nowIso2(), notificationId]
  );
  return true;
}
__name(cancelScheduledNotification, "cancelScheduledNotification");
async function listNotificationCategories(env2, userId) {
  const rows = await query(
    env2.DB,
    `SELECT
        COALESCE(category, 'general') AS category,
        COUNT(*) AS total,
        SUM(CASE WHEN status = 'UNREAD' THEN 1 ELSE 0 END) AS unread
      FROM notifications
      WHERE user_id = ?
      GROUP BY COALESCE(category, 'general')
      ORDER BY category`,
    [userId]
  );
  return rows.map((row) => ({
    category: row.category ?? "general",
    total: Number(row.total ?? 0),
    unread: Number(row.unread ?? 0)
  }));
}
__name(listNotificationCategories, "listNotificationCategories");
async function listScheduledNotifications(env2, userId, page, size) {
  const normalizedPage = normalizePage(page);
  const normalizedSize = normalizePageSize(size);
  const offset = (normalizedPage - 1) * normalizedSize;
  const whereClause = `WHERE user_id = ? AND (status = 'SCHEDULED' OR (scheduled_at IS NOT NULL AND datetime(scheduled_at) >= datetime('now'))) `;
  const totalRow = await queryFirst(
    env2.DB,
    `SELECT COUNT(*) AS count FROM notifications ${whereClause}`,
    [userId]
  );
  const rows = await query(
    env2.DB,
    `SELECT * FROM notifications
      ${whereClause}
      ORDER BY scheduled_at ASC, created_at DESC
      LIMIT ? OFFSET ?`,
    [userId, normalizedSize, offset]
  );
  return {
    data: rows.map(mapNotificationRow),
    page: normalizedPage,
    size: normalizedSize,
    total: totalRow ? Number(totalRow.count ?? 0) : 0
  };
}
__name(listScheduledNotifications, "listScheduledNotifications");
async function subscribeToNotificationTopics(env2, userId, topics) {
  const normalized = topics.map((topic) => String(topic).trim().toLowerCase()).filter((topic) => topic.length > 0);
  if (!normalized.length) {
    return listSubscriptionTopics(env2, userId);
  }
  const now = nowIso2();
  for (const topic of new Set(normalized)) {
    await execute(
      env2.DB,
      `INSERT INTO notification_topic_subscription (user_id, topic, created_at, updated_at)
        VALUES (?, ?, ?, ?)
        ON CONFLICT(user_id, topic) DO UPDATE SET updated_at = excluded.updated_at`,
      [userId, topic, now, now]
    );
  }
  return listSubscriptionTopics(env2, userId);
}
__name(subscribeToNotificationTopics, "subscribeToNotificationTopics");
async function unsubscribeFromNotificationTopics(env2, userId, topics) {
  const normalized = topics.map((topic) => String(topic).trim().toLowerCase()).filter((topic) => topic.length > 0);
  if (!normalized.length) {
    return listSubscriptionTopics(env2, userId);
  }
  const placeholders = normalized.map(() => "?").join(", ");
  await execute(
    env2.DB,
    `DELETE FROM notification_topic_subscription WHERE user_id = ? AND topic IN (${placeholders})`,
    [userId, ...normalized]
  );
  return listSubscriptionTopics(env2, userId);
}
__name(unsubscribeFromNotificationTopics, "unsubscribeFromNotificationTopics");
async function scheduleNotification(env2, userId, payload) {
  return createNotification(env2, {
    userId,
    type: payload.type ?? "SCHEDULED",
    title: payload.title,
    content: payload.message,
    actionData: payload.data ?? null,
    scheduledAt: payload.scheduledAt,
    status: "SCHEDULED",
    scheduleMetadata: payload.recurring ?? null,
    priority: payload.priority ?? 2,
    category: payload.category ?? "scheduled",
    deliveryChannels: payload.deliveryChannels ?? void 0
  });
}
__name(scheduleNotification, "scheduleNotification");
async function sendTestNotification(env2, userId, type) {
  return createNotification(env2, {
    userId,
    type: type ?? "TEST",
    title: "\uD14C\uC2A4\uD2B8 \uC54C\uB9BC",
    content: "\uD14C\uC2A4\uD2B8 \uC54C\uB9BC\uC785\uB2C8\uB2E4.",
    category: "test",
    priority: 1
  });
}
__name(sendTestNotification, "sendTestNotification");
async function sendUrgentNotifications(env2, initiatorUserId, recipients, payload) {
  const normalized = recipients.map((id) => String(id).trim()).filter((id) => id.length > 0);
  let targetIds = [];
  const hasAll = normalized.some((id) => id.toLowerCase() === "all");
  if (hasAll) {
    const rows = await query(
      env2.DB,
      "SELECT user_id FROM users ORDER BY created_at DESC LIMIT 200"
    );
    targetIds = rows.map((row) => row.user_id);
  } else {
    targetIds = Array.from(new Set(normalized.filter((id) => id.toLowerCase() !== "all")));
  }
  if (!targetIds.length) {
    return { delivered: 0 };
  }
  const jobs = targetIds.map(
    (targetId) => createNotification(env2, {
      userId: targetId,
      type: payload.type ?? "URGENT",
      title: payload.title,
      content: payload.message,
      actionData: payload.data ?? null,
      expiresAt: payload.expiresAt ?? void 0,
      priority: payload.priority ?? 3,
      category: payload.category ?? "urgent",
      senderUserId: initiatorUserId
    }).catch((error48) => {
      console.error("[notifications] failed to send urgent notification", error48);
      return null;
    })
  );
  const results = await Promise.all(jobs);
  const delivered = results.filter((record2) => record2 !== null).length;
  return { delivered };
}
__name(sendUrgentNotifications, "sendUrgentNotifications");
async function processScheduledNotifications(env2, limit = 100) {
  const nowIsoStr = nowIso2();
  const reference = new Date(nowIsoStr);
  const rows = await query(
    env2.DB,
    "SELECT * FROM notifications WHERE status = 'SCHEDULED' AND scheduled_at IS NOT NULL AND datetime(scheduled_at) <= datetime(?) LIMIT ?",
    [nowIsoStr, limit]
  );
  let processed = 0;
  for (const row of rows) {
    try {
      await execute(
        env2.DB,
        "UPDATE notifications SET status = 'UNREAD', sent_at = ?, updated_at = ?, schedule_metadata = NULL WHERE notification_id = ?",
        [nowIsoStr, nowIsoStr, row.notification_id]
      );
      processed += 1;
      const metadata = parseRecurringSchedule(parseJson(row.schedule_metadata));
      if (metadata) {
        const nextScheduledAt = computeNextScheduledAt(row.scheduled_at ?? row.created_at, metadata, reference);
        if (nextScheduledAt) {
          const actionData = parseJson(row.action_data);
          const templateVariables = parseJson(row.template_variables);
          await createNotification(env2, {
            userId: row.user_id,
            type: row.type,
            title: row.title,
            content: row.content,
            actionUrl: row.action_url ?? void 0,
            actionData: actionData ?? null,
            imageUrl: row.image_url ?? void 0,
            iconUrl: row.icon_url ?? void 0,
            priority: row.priority ?? void 0,
            category: row.category ?? void 0,
            scheduledAt: nextScheduledAt,
            status: "SCHEDULED",
            scheduleMetadata: metadata,
            isPersistent: row.is_persistent !== null ? Boolean(row.is_persistent) : void 0,
            senderUserId: row.sender_user_id ?? void 0,
            templateId: row.template_id ?? void 0,
            templateVariables: templateVariables ?? null,
            deliveryChannels: row.delivery_channels ?? void 0
          });
        }
      }
    } catch (error48) {
      console.error("[notifications] failed to process scheduled notification", error48);
    }
  }
  return processed;
}
__name(processScheduledNotifications, "processScheduledNotifications");
async function getNotificationPreferences(env2, userId) {
  const row = await ensurePreference(env2, userId);
  const base = mapPreferenceRow(row);
  const subscriptionTopics = await listSubscriptionTopics(env2, userId);
  return {
    ...base,
    subscriptionTopics
  };
}
__name(getNotificationPreferences, "getNotificationPreferences");
async function updateNotificationPreferences(env2, userId, settings) {
  await ensurePreference(env2, userId);
  const now = nowIso2();
  const setClauses = [];
  const params = [];
  const booleanFields = [
    "notificationsEnabled",
    "pushEnabled",
    "emailEnabled",
    "smsEnabled",
    "sessionNotifications",
    "sessionReminders",
    "matchingNotifications",
    "chatNotifications",
    "levelTestNotifications",
    "systemNotifications",
    "marketingNotifications",
    "quietHoursEnabled",
    "digestEnabled"
  ];
  for (const field of booleanFields) {
    if (settings[field] !== void 0) {
      const column = field.replace(/[A-Z]/g, (m) => `_${m.toLowerCase()}`);
      setClauses.push(`${column} = ?`);
      params.push(settings[field] ? 1 : 0);
    }
  }
  if (settings.quietHoursStart !== void 0) {
    setClauses.push("quiet_hours_start = ?");
    params.push(settings.quietHoursStart ?? null);
  }
  if (settings.quietHoursEnd !== void 0) {
    setClauses.push("quiet_hours_end = ?");
    params.push(settings.quietHoursEnd ?? null);
  }
  if (settings.timezone !== void 0) {
    setClauses.push("timezone = ?");
    params.push(settings.timezone ?? null);
  }
  if (settings.notificationLanguage !== void 0) {
    setClauses.push("notification_language = ?");
    params.push(settings.notificationLanguage ?? null);
  }
  if (settings.digestFrequency !== void 0) {
    setClauses.push("digest_frequency = ?");
    params.push(settings.digestFrequency ?? null);
  }
  if (settings.digestTime !== void 0) {
    setClauses.push("digest_time = ?");
    params.push(settings.digestTime ?? null);
  }
  if (setClauses.length > 0) {
    setClauses.push("updated_at = ?");
    params.push(now, userId);
    await execute(
      env2.DB,
      `UPDATE notification_preferences SET ${setClauses.join(", ")} WHERE user_id = ?`,
      params
    );
  }
  return getNotificationPreferences(env2, userId);
}
__name(updateNotificationPreferences, "updateNotificationPreferences");
async function getNotificationStats(env2, userId) {
  const totals = await queryFirst(
    env2.DB,
    `SELECT COUNT(*) AS total,
            SUM(CASE WHEN status = 'UNREAD' THEN 1 ELSE 0 END) AS unread,
            SUM(CASE WHEN status = 'READ' THEN 1 ELSE 0 END) AS read
       FROM notifications
      WHERE user_id = ?`,
    [userId]
  );
  const todayKey = (/* @__PURE__ */ new Date()).toISOString().slice(0, 10);
  const todayRow = await queryFirst(
    env2.DB,
    `SELECT COUNT(*) as count FROM notifications
      WHERE user_id = ? AND substr(created_at, 1, 10) = ?`,
    [userId, todayKey]
  );
  const categoryRows = await query(
    env2.DB,
    `SELECT COALESCE(category, 'UNCATEGORIZED') as category, COUNT(*) as cnt
       FROM notifications
      WHERE user_id = ?
      GROUP BY COALESCE(category, 'UNCATEGORIZED')`,
    [userId]
  );
  const categories = {};
  for (const row of categoryRows) {
    categories[row.category ?? "UNCATEGORIZED"] = row.cnt;
  }
  return {
    total: totals?.total ?? 0,
    unread: totals?.unread ?? 0,
    read: totals?.read ?? 0,
    today: todayRow?.count ?? 0,
    categories
  };
}
__name(getNotificationStats, "getNotificationStats");
async function registerPushToken(env2, userId, token, deviceType) {
  const now = nowIso2();
  await execute(
    env2.DB,
    `INSERT INTO notification_push_tokens (user_id, token, device_type, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?)
      ON CONFLICT(token) DO UPDATE SET updated_at = excluded.updated_at, user_id = excluded.user_id, device_type = excluded.device_type`,
    [userId, token, deviceType ?? "web", now, now]
  );
}
__name(registerPushToken, "registerPushToken");
async function unregisterPushToken(env2, userId, token) {
  await execute(
    env2.DB,
    "DELETE FROM notification_push_tokens WHERE token = ? AND user_id = ?",
    [token, userId]
  );
}
__name(unregisterPushToken, "unregisterPushToken");
async function createNotificationFromTemplate(env2, userId, templateId, variables, options = {}) {
  const title2 = options.title ?? `Template ${templateId}`;
  const content = options.content ?? "\uC54C\uB9BC\uC774 \uB3C4\uCC29\uD588\uC2B5\uB2C8\uB2E4.";
  return createNotification(env2, {
    userId,
    type: options.type ?? "SYSTEM",
    title: title2,
    content,
    templateId,
    templateVariables: variables ?? null,
    ...options
  });
}
__name(createNotificationFromTemplate, "createNotificationFromTemplate");
async function createStudyReminderNotifications(env2) {
  try {
    const users = await query(
      env2.DB,
      `SELECT u.user_id, u.name, u.english_name
       FROM users u
       WHERE u.is_active = 1
         AND u.user_id NOT IN (
           SELECT DISTINCT gsp.user_id
           FROM group_session_participants gsp
           JOIN group_sessions gs ON gs.session_id = gsp.session_id
           WHERE DATE(gs.started_at) = DATE('now')
             AND gsp.status = 'JOINED'
         )
       LIMIT 1000`
    );
    let count3 = 0;
    for (const user of users) {
      const userName = user.english_name || user.name || "\uC0AC\uC6A9\uC790";
      try {
        await createNotification(env2, {
          userId: user.user_id,
          type: "STUDY_REMINDER",
          title: "\u{1F4DA} \uD559\uC2B5 \uB9AC\uB9C8\uC778\uB354",
          content: `${userName}\uB2D8, \uC624\uB298 \uC544\uC9C1 \uD559\uC2B5\uD558\uC9C0 \uC54A\uC73C\uC168\uC5B4\uC694! \uC9C0\uAE08 \uC2DC\uC791\uD574\uBCF4\uB294 \uAC74 \uC5B4\uB5A8\uAE4C\uC694?`,
          category: "reminder",
          priority: 1,
          actionUrl: "/group-sessions",
          actionData: {
            reminderType: "daily_study"
          }
        });
        count3++;
      } catch (error48) {
        console.error(`Failed to create STUDY_REMINDER for user ${user.user_id}:`, error48);
      }
    }
    return count3;
  } catch (error48) {
    console.error("Failed to create study reminder notifications:", error48);
    return 0;
  }
}
__name(createStudyReminderNotifications, "createStudyReminderNotifications");
async function createGoalProgressNotifications(env2) {
  try {
    const userProgress = await query(
      env2.DB,
      `SELECT u.user_id, u.name, u.english_name, COUNT(gsp.participant_id) as session_count
       FROM users u
       LEFT JOIN group_session_participants gsp ON gsp.user_id = u.user_id
       LEFT JOIN group_sessions gs ON gs.session_id = gsp.session_id
       WHERE u.is_active = 1
         AND (gs.started_at IS NULL OR DATE(gs.started_at) >= DATE('now', '-7 days'))
         AND (gsp.status IS NULL OR gsp.status = 'JOINED')
       GROUP BY u.user_id, u.name, u.english_name
       HAVING session_count > 0 AND session_count < 10
       LIMIT 1000`
    );
    let count3 = 0;
    const weeklyGoal = 5;
    for (const progress of userProgress) {
      const userName = progress.english_name || progress.name || "\uC0AC\uC6A9\uC790";
      const sessionsCompleted = Number(progress.session_count);
      const progressPercent = Math.round(sessionsCompleted / weeklyGoal * 100);
      let message = "";
      let priority = 1;
      if (progressPercent >= 80) {
        message = `${userName}\uB2D8, \uC774\uBC88 \uC8FC \uBAA9\uD45C\uB97C \uAC70\uC758 \uB2EC\uC131\uD588\uC5B4\uC694! \u{1F389} (${sessionsCompleted}/${weeklyGoal} \uC644\uB8CC)`;
        priority = 2;
      } else if (progressPercent >= 50) {
        message = `${userName}\uB2D8, \uC774\uBC88 \uC8FC \uBAA9\uD45C\uC758 \uC808\uBC18\uC744 \uB2EC\uC131\uD588\uC5B4\uC694! \u{1F4AA} (${sessionsCompleted}/${weeklyGoal} \uC644\uB8CC)`;
      } else {
        message = `${userName}\uB2D8, \uC774\uBC88 \uC8FC \uBAA9\uD45C \uB2EC\uC131\uC744 \uC704\uD574 \uC870\uAE08\uB9CC \uB354 \uB178\uB825\uD574\uBCFC\uAE4C\uC694? \u{1F4C8} (${sessionsCompleted}/${weeklyGoal} \uC644\uB8CC)`;
      }
      try {
        await createNotification(env2, {
          userId: progress.user_id,
          type: "GOAL_PROGRESS",
          title: "\u{1F3AF} \uC8FC\uAC04 \uBAA9\uD45C \uC9C4\uD589\uB960",
          content: message,
          category: "goal",
          priority,
          actionUrl: "/achievements",
          actionData: {
            goalType: "weekly",
            currentProgress: sessionsCompleted,
            targetGoal: weeklyGoal,
            progressPercent
          }
        });
        count3++;
      } catch (error48) {
        console.error(`Failed to create GOAL_PROGRESS for user ${progress.user_id}:`, error48);
      }
    }
    return count3;
  } catch (error48) {
    console.error("Failed to create goal progress notifications:", error48);
    return 0;
  }
}
__name(createGoalProgressNotifications, "createGoalProgressNotifications");

// src/routes/notifications.ts
var notificationsRoutes = new Hono2();
var requireAuth4 = auth();
function parseBoolean(value) {
  if (value === void 0) return void 0;
  const lowered = value.toLowerCase();
  if (["true", "1", "yes", "y"].includes(lowered)) return true;
  if (["false", "0", "no", "n"].includes(lowered)) return false;
  return void 0;
}
__name(parseBoolean, "parseBoolean");
notificationsRoutes.use("*", requireAuth4);
notificationsRoutes.get("/", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const page = Number(c.req.query("page")) || 1;
  const size = Number(c.req.query("size")) || 20;
  const unreadOnly = parseBoolean(c.req.query("unreadOnly")) ?? void 0;
  const isRead = parseBoolean(c.req.query("isRead"));
  let status;
  if (isRead === true) status = "READ";
  else if (isRead === false) status = "UNREAD";
  const result = await listNotifications(c.env, userId, {
    page,
    size,
    category: c.req.query("category") ?? c.req.query("type") ?? void 0,
    status,
    unreadOnly
  });
  return successResponse(c, {
    notifications: result.data,
    unreadCount: result.unreadCount,
    pagination: {
      page: result.page,
      size: result.size,
      total: result.total,
      totalPages: Math.ceil(result.total / result.size)
    }
  });
});
notificationsRoutes.get("/unread", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const result = await listNotifications(c.env, userId, { page: 1, size: 50, unreadOnly: true });
  return successResponse(c, { notifications: result.data, unreadCount: result.unreadCount });
});
notificationsRoutes.get("/unread-count", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const count3 = await getUnreadCount(c.env, userId);
  return successResponse(c, { unreadCount: count3 });
});
notificationsRoutes.get("/categories", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const categories = await listNotificationCategories(c.env, userId);
  return successResponse(c, categories);
});
notificationsRoutes.get("/history", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const page = Math.max(Number(c.req.query("page") ?? "1"), 1);
  const size = Math.max(Math.min(Number(c.req.query("size") ?? "20"), 100), 1);
  const category = c.req.query("category") ?? void 0;
  const status = c.req.query("status") ?? void 0;
  const unreadOnlyParam = c.req.query("unreadOnly");
  const unreadOnly = typeof unreadOnlyParam === "string" ? ["true", "1"].includes(unreadOnlyParam.toLowerCase()) : false;
  const result = await listNotifications(c.env, userId, {
    page,
    size,
    category,
    status,
    unreadOnly
  });
  return successResponse(c, result);
});
notificationsRoutes.get("/scheduled", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const page = Math.max(Number(c.req.query("page") ?? "1"), 1);
  const size = Math.max(Math.min(Number(c.req.query("size") ?? "20"), 100), 1);
  const result = await listScheduledNotifications(c.env, userId, page, size);
  return successResponse(c, result);
});
notificationsRoutes.get("/category/:category", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const category = c.req.param("category");
  const page = Number(c.req.query("page")) || 1;
  const size = Number(c.req.query("size")) || 20;
  const result = await listNotifications(c.env, userId, { page, size, category });
  return successResponse(c, {
    notifications: result.data,
    pagination: {
      page: result.page,
      size: result.size,
      total: result.total,
      totalPages: Math.ceil(result.total / result.size)
    }
  });
});
notificationsRoutes.get("/:notificationId", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const notificationId = Number(c.req.param("notificationId"));
  if (!Number.isFinite(notificationId)) throw new AppError("Invalid notificationId", 400, "INVALID_PATH_PARAM");
  const record2 = await getNotificationById(c.env, notificationId);
  if (record2 && record2.notificationId && record2.notificationId !== notificationId) {
    throw new AppError("\uC54C\uB9BC\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.", 404, "NOTIFICATION_NOT_FOUND");
  }
  if (record2 && record2.userId !== userId) {
    throw new AppError("\uC811\uADFC \uAD8C\uD55C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.", 403, "NOTIFICATION_FORBIDDEN");
  }
  return successResponse(c, record2);
});
notificationsRoutes.post("/", async (c) => {
  const body = await c.req.json();
  const userId = typeof body.userId === "string" ? body.userId : c.get("userId");
  if (!userId) throw new AppError("userId is required", 400, "INVALID_PAYLOAD");
  if (!body.title || !body.content || !body.type) {
    throw new AppError("type, title, content are required", 400, "INVALID_PAYLOAD");
  }
  const record2 = await createNotification(c.env, {
    userId,
    type: body.type,
    title: body.title,
    content: body.content,
    actionUrl: body.actionUrl,
    actionData: body.actionData,
    imageUrl: body.imageUrl,
    iconUrl: body.iconUrl,
    priority: body.priority,
    category: body.category,
    scheduledAt: body.scheduledAt,
    expiresAt: body.expiresAt,
    isPersistent: body.isPersistent,
    senderUserId: body.senderUserId,
    templateId: body.templateId,
    templateVariables: body.templateVariables,
    deliveryChannels: body.deliveryChannels
  });
  return successResponse(c, record2);
});
notificationsRoutes.post("/schedule", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  const notification = body.notification ?? body;
  const scheduledAt = typeof body.scheduledAt === "string" ? body.scheduledAt : typeof notification?.scheduledAt === "string" ? notification.scheduledAt : void 0;
  if (!scheduledAt) {
    throw new AppError("scheduledAt is required", 400, "INVALID_PAYLOAD");
  }
  const record2 = await scheduleNotification(c.env, userId, {
    title: notification?.title ?? "Scheduled Notification",
    message: notification?.message ?? notification?.content ?? "\uC54C\uB9BC \uB0B4\uC6A9\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.",
    type: notification?.type ?? "SCHEDULED",
    data: notification?.data ?? notification?.actionData ?? null,
    scheduledAt,
    recurring: notification?.recurring ?? body.recurring ?? null,
    priority: notification?.priority,
    category: notification?.category ?? "scheduled",
    deliveryChannels: notification?.deliveryChannels ?? void 0
  });
  return successResponse(c, record2);
});
notificationsRoutes.post("/subscribe", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  const topics = Array.isArray(body.topics) ? body.topics : [];
  const updated = await subscribeToNotificationTopics(c.env, userId, topics);
  return successResponse(c, { topics: updated });
});
notificationsRoutes.post("/unsubscribe", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  const topics = Array.isArray(body.topics) ? body.topics : [];
  const updated = await unsubscribeFromNotificationTopics(c.env, userId, topics);
  return successResponse(c, { topics: updated });
});
notificationsRoutes.post("/template/:templateId", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const templateId = c.req.param("templateId");
  const body = await c.req.json().catch(() => ({}));
  const record2 = await createNotificationFromTemplate(c.env, userId, templateId, body.variables, {
    type: body.type,
    title: body.title,
    content: body.content,
    actionUrl: body.actionUrl,
    actionData: body.actionData
  });
  return successResponse(c, record2);
});
notificationsRoutes.post("/test", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  const record2 = await sendTestNotification(c.env, userId, typeof body.type === "string" ? body.type : null);
  return successResponse(c, record2);
});
notificationsRoutes.post("/urgent", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  const notification = body.notification ?? body;
  const recipients = Array.isArray(body.recipients) ? body.recipients : [];
  const result = await sendUrgentNotifications(c.env, userId, recipients, {
    title: notification?.title ?? "\uAE34\uAE09 \uC54C\uB9BC",
    message: notification?.message ?? notification?.content ?? "",
    type: notification?.type ?? "URGENT",
    expiresAt: notification?.expiresAt ?? void 0,
    priority: notification?.priority ?? 4,
    category: notification?.category ?? "urgent",
    data: notification?.data ?? notification?.actionData ?? null
  });
  return successResponse(c, result);
});
notificationsRoutes.patch("/:notificationId/read", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const notificationId = Number(c.req.param("notificationId"));
  if (!Number.isFinite(notificationId)) throw new AppError("Invalid notificationId", 400, "INVALID_PATH_PARAM");
  await markAsRead(c.env, userId, notificationId);
  return successResponse(c, { success: true });
});
notificationsRoutes.patch("/read-all", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  await markAllAsRead(c.env, userId);
  return successResponse(c, { success: true });
});
notificationsRoutes.delete("/batch", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  const rawIds = Array.isArray(body.notificationIds) ? body.notificationIds : Array.isArray(body.ids) ? body.ids : Array.isArray(body) ? body : [];
  const ids = rawIds.map((value) => Number(value)).filter((id) => Number.isFinite(id));
  await deleteNotificationsBatch(c.env, userId, ids);
  return successResponse(c, { success: true });
});
notificationsRoutes.delete("/scheduled/:notificationId", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const notificationId = Number(c.req.param("notificationId"));
  if (!Number.isFinite(notificationId)) {
    throw new AppError("Invalid notificationId", 400, "INVALID_PATH_PARAM");
  }
  const cancelled = await cancelScheduledNotification(c.env, userId, notificationId);
  if (!cancelled) {
    throw new AppError("\uC608\uC57D \uC54C\uB9BC\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.", 404, "SCHEDULED_NOTIFICATION_NOT_FOUND");
  }
  return successResponse(c, { success: true });
});
notificationsRoutes.delete("/:notificationId", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const notificationId = Number(c.req.param("notificationId"));
  if (!Number.isFinite(notificationId)) throw new AppError("Invalid notificationId", 400, "INVALID_PATH_PARAM");
  await deleteNotification(c.env, userId, notificationId);
  return successResponse(c, { success: true });
});
notificationsRoutes.delete("/all", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  await deleteAllNotifications(c.env, userId);
  return successResponse(c, { success: true });
});
notificationsRoutes.get("/settings", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const prefs = await getNotificationPreferences(c.env, userId);
  return successResponse(c, prefs);
});
function mapNotificationSettingsPayload(body) {
  const payload = {};
  const booleanMap = [
    ["notificationsEnabled", "notificationsEnabled"],
    ["notificationsEnabled", "notifications"],
    ["pushEnabled", "pushEnabled"],
    ["pushEnabled", "pushNotifications"],
    ["emailEnabled", "emailEnabled"],
    ["emailEnabled", "emailNotifications"],
    ["smsEnabled", "smsEnabled"],
    ["smsEnabled", "smsNotifications"],
    ["sessionNotifications", "sessionNotifications"],
    ["sessionReminders", "sessionReminderNotifications"],
    ["matchingNotifications", "matchRequestNotifications"],
    ["chatNotifications", "chatMessageNotifications"],
    ["systemNotifications", "systemNotifications"],
    ["marketingNotifications", "marketingNotifications"],
    ["quietHoursEnabled", "quietHoursEnabled"],
    ["digestEnabled", "digestEnabled"]
  ];
  for (const [targetKey, sourceKey] of booleanMap) {
    if (Object.prototype.hasOwnProperty.call(body, sourceKey)) {
      payload[targetKey] = Boolean(body[sourceKey]);
    }
  }
  if (typeof body.quietHours === "object" && body.quietHours !== null) {
    const quiet = body.quietHours;
    if (quiet.start !== void 0) payload.quietHoursStart = quiet.start ?? null;
    if (quiet.end !== void 0) payload.quietHoursEnd = quiet.end ?? null;
  }
  if (body.quietHoursStart !== void 0) payload.quietHoursStart = body.quietHoursStart ?? null;
  if (body.quietHoursEnd !== void 0) payload.quietHoursEnd = body.quietHoursEnd ?? null;
  if (body.notificationSound !== void 0) payload.notificationSound = body.notificationSound ?? null;
  if (body.timezone !== void 0) payload.timezone = body.timezone ?? null;
  if (body.notificationLanguage !== void 0) payload.notificationLanguage = body.notificationLanguage ?? null;
  if (body.digestFrequency !== void 0) payload.digestFrequency = body.digestFrequency ?? null;
  if (body.digestTime !== void 0) payload.digestTime = body.digestTime ?? null;
  return payload;
}
__name(mapNotificationSettingsPayload, "mapNotificationSettingsPayload");
notificationsRoutes.patch("/settings", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  const payload = mapNotificationSettingsPayload(body);
  const prefs = await updateNotificationPreferences(c.env, userId, payload);
  return successResponse(c, prefs);
});
notificationsRoutes.get("/stats", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const stats = await getNotificationStats(c.env, userId);
  return successResponse(c, stats);
});
notificationsRoutes.post("/push-token", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  const token = c.req.query("token") ?? body.token;
  if (!token || typeof token !== "string") {
    throw new AppError("token is required", 400, "INVALID_PAYLOAD");
  }
  const deviceType = c.req.query("deviceType") ?? body.deviceType ?? "web";
  await registerPushToken(c.env, userId, token, deviceType);
  return successResponse(c, { success: true });
});
notificationsRoutes.delete("/push-token", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  const token = c.req.query("token") ?? body.token;
  if (!token || typeof token !== "string") {
    throw new AppError("token is required", 400, "INVALID_PAYLOAD");
  }
  await unregisterPushToken(c.env, userId, token);
  return successResponse(c, { success: true });
});
var notifications_default = notificationsRoutes;

// src/routes/groupSessions.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_errors();

// src/services/groupSessions.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_db();

// src/services/groupSessionsCache.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var CACHE_PREFIX = "group-session";
var DEFAULT_TTL_SECONDS2 = 60 * 5;
function getCache(env2) {
  return new CacheService(env2.CACHE, CACHE_PREFIX, DEFAULT_TTL_SECONDS2);
}
__name(getCache, "getCache");
function cloneParticipants(participants) {
  return participants ? participants.map((participant) => ({ ...participant })) : void 0;
}
__name(cloneParticipants, "cloneParticipants");
function sanitizeRecord(record2) {
  return {
    ...record2,
    canJoin: false,
    participants: cloneParticipants(record2.participants)
  };
}
__name(sanitizeRecord, "sanitizeRecord");
async function setCachedGroupSession(env2, record2) {
  const cache = getCache(env2);
  await cache.set(record2.id, sanitizeRecord(record2), {
    ttl: DEFAULT_TTL_SECONDS2,
    tags: [`session:${record2.id}`]
  });
}
__name(setCachedGroupSession, "setCachedGroupSession");
async function getCachedGroupSession(env2, sessionId) {
  const cache = getCache(env2);
  const cached2 = await cache.get(sessionId);
  if (!cached2) {
    return null;
  }
  return {
    ...cached2,
    participants: cloneParticipants(cached2.participants)
  };
}
__name(getCachedGroupSession, "getCachedGroupSession");
async function invalidateGroupSessionCache(env2, sessionId) {
  const cache = getCache(env2);
  await cache.delete(sessionId);
}
__name(invalidateGroupSessionCache, "invalidateGroupSessionCache");

// src/services/groupSessionsState.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var INVITATION_PREFIX = "group-session:invitation";
var ACTIVE_PREFIX = "group-session:user-active";
var RECENT_PREFIX = "group-session:recent";
var INVITATION_TTL_SECONDS = 60 * 60 * 24 * 3;
var ACTIVE_TTL_SECONDS = 60 * 60 * 24;
var RECENT_MAX = 10;
function invitationKey(sessionId, userId) {
  return `${INVITATION_PREFIX}:${sessionId}:${userId}`;
}
__name(invitationKey, "invitationKey");
function activeKey(userId) {
  return `${ACTIVE_PREFIX}:${userId}`;
}
__name(activeKey, "activeKey");
function recentKey(userId) {
  return `${RECENT_PREFIX}:${userId}`;
}
__name(recentKey, "recentKey");
async function saveInvitation(env2, sessionId, userId, hostUserId) {
  const record2 = {
    sessionId,
    userId,
    hostUserId,
    createdAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  await env2.CACHE.put(invitationKey(sessionId, userId), JSON.stringify(record2), {
    expirationTtl: INVITATION_TTL_SECONDS
  });
}
__name(saveInvitation, "saveInvitation");
async function getInvitation(env2, sessionId, userId) {
  const raw2 = await env2.CACHE.get(invitationKey(sessionId, userId), { type: "json" });
  return raw2 ?? null;
}
__name(getInvitation, "getInvitation");
async function deleteInvitation(env2, sessionId, userId) {
  await env2.CACHE.delete(invitationKey(sessionId, userId));
}
__name(deleteInvitation, "deleteInvitation");
async function addActiveSession(env2, userId, sessionId) {
  const key = activeKey(userId);
  const existing = await env2.CACHE.get(key, { type: "json" });
  const set2 = new Set(existing?.sessions ?? []);
  set2.add(sessionId);
  const record2 = {
    userId,
    sessions: Array.from(set2),
    updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  await env2.CACHE.put(key, JSON.stringify(record2), { expirationTtl: ACTIVE_TTL_SECONDS });
}
__name(addActiveSession, "addActiveSession");
async function removeActiveSession(env2, userId, sessionId) {
  const key = activeKey(userId);
  const existing = await env2.CACHE.get(key, { type: "json" });
  if (!existing) {
    return;
  }
  const set2 = new Set(existing.sessions);
  set2.delete(sessionId);
  const record2 = {
    userId,
    sessions: Array.from(set2),
    updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  if (record2.sessions.length === 0) {
    await env2.CACHE.delete(key);
  } else {
    await env2.CACHE.put(key, JSON.stringify(record2), { expirationTtl: ACTIVE_TTL_SECONDS });
  }
}
__name(removeActiveSession, "removeActiveSession");
async function addRecentSession(env2, userId, sessionId) {
  const key = recentKey(userId);
  const existing = await env2.CACHE.get(key, { type: "json" });
  const recent = (existing ?? []).filter((id) => id !== sessionId);
  recent.unshift(sessionId);
  const trimmed = recent.slice(0, RECENT_MAX);
  await env2.CACHE.put(key, JSON.stringify(trimmed), { expirationTtl: ACTIVE_TTL_SECONDS });
}
__name(addRecentSession, "addRecentSession");

// src/services/groupSessions.ts
var GROUP_STATUS = {
  SCHEDULED: "SCHEDULED",
  WAITING: "WAITING",
  ACTIVE: "ACTIVE",
  COMPLETED: "COMPLETED",
  CANCELLED: "CANCELLED"
};
var PARTICIPANT_STATUS = {
  INVITED: "INVITED",
  JOINED: "JOINED",
  LEFT: "LEFT",
  KICKED: "KICKED",
  BANNED: "BANNED"
};
function nowIso3() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
__name(nowIso3, "nowIso");
function newJoinCode() {
  return Math.random().toString(36).substring(2, 8).toUpperCase();
}
__name(newJoinCode, "newJoinCode");
function mapGroupSession(row, participants = [], currentUserId) {
  const isPublic = row.is_public === null ? void 0 : Number(row.is_public) !== 0;
  const currentParticipants = Number(row.current_participants ?? 0);
  const maxParticipants = row.max_participants !== null ? Number(row.max_participants) : void 0;
  const status = row.status ?? GROUP_STATUS.SCHEDULED;
  const tags = row.session_tags ? row.session_tags.split(",").map((t) => t.trim()).filter(Boolean) : void 0;
  return {
    id: row.session_id,
    title: row.title,
    description: row.description ?? void 0,
    hostUserId: row.host_user_id,
    hostUserName: row.host_user_name ?? void 0,
    hostProfileImage: row.host_profile_image ?? void 0,
    topicCategory: row.topic_category ?? void 0,
    targetLanguage: row.target_language ?? void 0,
    languageLevel: row.language_level ?? void 0,
    maxParticipants,
    currentParticipants,
    scheduledAt: row.scheduled_at ?? void 0,
    sessionDuration: row.session_duration !== null ? Number(row.session_duration) : void 0,
    status,
    roomId: row.room_id ?? void 0,
    sessionTags: tags && tags.length > 0 ? tags : void 0,
    isPublic,
    joinCode: row.join_code ?? void 0,
    startedAt: row.started_at ?? void 0,
    endedAt: row.ended_at ?? void 0,
    ratingAverage: row.rating_average !== null ? Number(row.rating_average) : void 0,
    ratingCount: row.rating_count !== null ? Number(row.rating_count) : void 0,
    participants,
    canJoin: currentUserId !== void 0 && row.host_user_id !== currentUserId && (isPublic ?? false) && status === GROUP_STATUS.SCHEDULED && currentParticipants < (maxParticipants ?? 10),
    joinMessage: void 0
  };
}
__name(mapGroupSession, "mapGroupSession");
function cloneParticipants2(participants) {
  return participants ? participants.map((participant) => ({ ...participant })) : void 0;
}
__name(cloneParticipants2, "cloneParticipants");
function applyJoinMetadata(record2, currentUserId) {
  const cloned = {
    ...record2,
    participants: cloneParticipants2(record2.participants)
  };
  const isPublic = record2.isPublic ?? false;
  const status = record2.status ?? GROUP_STATUS.SCHEDULED;
  const maxParticipants = record2.maxParticipants ?? 10;
  cloned.canJoin = currentUserId !== void 0 && record2.hostUserId !== currentUserId && isPublic && status === GROUP_STATUS.SCHEDULED && record2.currentParticipants < maxParticipants;
  return cloned;
}
__name(applyJoinMetadata, "applyJoinMetadata");
function mapGroupList(row, currentUserId) {
  const scheduledAt = row.scheduled_at ?? void 0;
  const status = row.status ?? GROUP_STATUS.SCHEDULED;
  let timeUntilStart;
  if (scheduledAt) {
    const diffMs = new Date(scheduledAt).getTime() - Date.now();
    if (diffMs > 0) {
      const hours = Math.floor(diffMs / 36e5);
      const minutes = Math.floor(diffMs % 36e5 / 6e4);
      timeUntilStart = `${hours}h ${minutes}m`;
    }
  }
  const tags = row.session_tags ? row.session_tags.split(",").map((t) => t.trim()).filter(Boolean) : void 0;
  return {
    id: row.session_id,
    title: row.title,
    description: row.description ?? void 0,
    hostUserName: row.host_user_name ?? void 0,
    hostProfileImage: row.host_profile_image ?? void 0,
    topicCategory: row.topic_category ?? void 0,
    targetLanguage: row.target_language ?? void 0,
    languageLevel: row.language_level ?? void 0,
    maxParticipants: row.max_participants !== null ? Number(row.max_participants) : void 0,
    currentParticipants: Number(row.current_participants ?? 0),
    scheduledAt,
    sessionDuration: row.session_duration !== null ? Number(row.session_duration) : void 0,
    status,
    sessionTags: tags && tags.length > 0 ? tags : void 0,
    ratingAverage: row.rating_average !== null ? Number(row.rating_average) : void 0,
    ratingCount: row.rating_count !== null ? Number(row.rating_count) : void 0,
    canJoin: currentUserId !== void 0 && row.host_user_id !== currentUserId && status === GROUP_STATUS.SCHEDULED && Number(row.current_participants ?? 0) < Number(row.max_participants ?? 10),
    timeUntilStart
  };
}
__name(mapGroupList, "mapGroupList");
async function fetchParticipants(env2, sessionId) {
  const rows = await query(
    env2.DB,
    `SELECT gsp.*, u.name AS user_name, u.profile_image AS profile_image
       FROM group_session_participants gsp
       LEFT JOIN users u ON u.user_id = gsp.user_id
      WHERE gsp.session_id = ?
      ORDER BY gsp.joined_at ASC`,
    [sessionId]
  );
  return rows.map((row) => ({
    userId: row.user_id,
    userName: row.user_name ?? void 0,
    profileImage: row.profile_image ?? void 0,
    status: row.status ?? void 0,
    joinedAt: row.joined_at ?? void 0,
    isMuted: row.is_muted === null ? void 0 : Boolean(row.is_muted),
    isVideoEnabled: row.is_video_enabled === null ? void 0 : Boolean(row.is_video_enabled)
  }));
}
__name(fetchParticipants, "fetchParticipants");
async function createGroupSession(env2, hostUserId, payload) {
  const now = nowIso3();
  const sessionId = crypto.randomUUID();
  const joinCode = newJoinCode();
  await execute(
    env2.DB,
    `INSERT INTO group_sessions (
        session_id,
        title,
        description,
        host_user_id,
        topic_category,
        target_language,
        language_level,
        max_participants,
        current_participants,
        scheduled_at,
        session_duration,
        status,
        room_id,
        session_tags,
        is_public,
        join_code,
        started_at,
        ended_at,
        rating_average,
        rating_count,
        created_at,
        updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, 1, ?, ?, ?, NULL, ?, ?, ?, NULL, NULL, 0, 0, ?, ?)
    `,
    [
      sessionId,
      payload.title,
      payload.description ?? null,
      hostUserId,
      payload.topicCategory,
      payload.targetLanguage,
      payload.languageLevel,
      payload.maxParticipants,
      payload.scheduledAt,
      payload.sessionDuration,
      GROUP_STATUS.SCHEDULED,
      payload.sessionTags ? payload.sessionTags.join(",") : null,
      payload.isPublic ? 1 : 0,
      joinCode,
      now,
      now
    ]
  );
  await execute(
    env2.DB,
    `INSERT INTO group_session_participants (
        participant_id,
        session_id,
        user_id,
        status,
        joined_at,
        left_at,
        participation_duration,
        rating,
        feedback,
        connection_quality,
        is_muted,
        is_video_enabled,
        created_at,
        updated_at
      ) VALUES (?, ?, ?, ?, ?, NULL, NULL, NULL, NULL, NULL, 0, 1, ?, ?)
    `,
    [crypto.randomUUID(), sessionId, hostUserId, PARTICIPANT_STATUS.JOINED, now, now, now]
  );
  const row = await queryFirst(
    env2.DB,
    `SELECT gs.*, host.name AS host_user_name, host.profile_image AS host_profile_image
       FROM group_sessions gs
       LEFT JOIN users host ON host.user_id = gs.host_user_id
      WHERE gs.session_id = ?
      LIMIT 1`,
    [sessionId]
  );
  if (!row) {
    throw new Error("\uADF8\uB8F9 \uC138\uC158\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  const participants = await fetchParticipants(env2, sessionId);
  const baseRecord = mapGroupSession(row, participants);
  await setCachedGroupSession(env2, baseRecord);
  await addActiveSession(env2, hostUserId, sessionId);
  await addRecentSession(env2, hostUserId, sessionId);
  return applyJoinMetadata(baseRecord, hostUserId);
}
__name(createGroupSession, "createGroupSession");
async function getGroupSessionById(env2, sessionId, currentUserId) {
  const cached2 = await getCachedGroupSession(env2, sessionId);
  if (cached2) {
    if (currentUserId) {
      await addRecentSession(env2, currentUserId, sessionId);
    }
    return applyJoinMetadata(cached2, currentUserId);
  }
  const row = await queryFirst(
    env2.DB,
    `SELECT gs.*, host.name AS host_user_name, host.profile_image AS host_profile_image
       FROM group_sessions gs
       LEFT JOIN users host ON host.user_id = gs.host_user_id
      WHERE gs.session_id = ?
      LIMIT 1`,
    [sessionId]
  );
  if (!row) throw new Error("\uADF8\uB8F9 \uC138\uC158\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  const participants = await fetchParticipants(env2, sessionId);
  const baseRecord = mapGroupSession(row, participants);
  await setCachedGroupSession(env2, baseRecord);
  return applyJoinMetadata(baseRecord, currentUserId);
}
__name(getGroupSessionById, "getGroupSessionById");
async function ensureParticipant(env2, sessionId, userId) {
  return queryFirst(
    env2.DB,
    `SELECT * FROM group_session_participants WHERE session_id = ? AND user_id = ? LIMIT 1`,
    [sessionId, userId]
  );
}
__name(ensureParticipant, "ensureParticipant");
async function joinGroupSession(env2, userId, sessionId, payload = {}) {
  const session = await getGroupSessionById(env2, sessionId);
  if (session.hostUserId === userId) {
    return session;
  }
  if (session.status !== GROUP_STATUS.SCHEDULED) {
    throw new Error("\uC774\uBBF8 \uC9C4\uD589 \uC911\uC774\uAC70\uB098 \uC885\uB8CC\uB41C \uC138\uC158\uC785\uB2C8\uB2E4.");
  }
  if (session.currentParticipants >= (session.maxParticipants ?? 10)) {
    throw new Error("\uC138\uC158 \uC815\uC6D0\uC774 \uAC00\uB4DD \uCC3C\uC2B5\uB2C8\uB2E4.");
  }
  const existing = await ensureParticipant(env2, sessionId, userId);
  if (existing && existing.status === PARTICIPANT_STATUS.JOINED) {
    return session;
  }
  const userInfo = await queryFirst(env2.DB, "SELECT english_name, name FROM users WHERE user_id = ? LIMIT 1", [userId]);
  const userName = userInfo?.english_name || userInfo?.name || "\uC0AC\uC6A9\uC790";
  const now = nowIso3();
  if (existing) {
    await execute(
      env2.DB,
      `UPDATE group_session_participants
         SET status = ?, joined_at = ?, left_at = NULL, updated_at = ?
       WHERE session_id = ? AND user_id = ?`,
      [PARTICIPANT_STATUS.JOINED, now, now, sessionId, userId]
    );
  } else {
    await execute(
      env2.DB,
      `INSERT INTO group_session_participants (
          participant_id, session_id, user_id, status, joined_at, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [crypto.randomUUID(), sessionId, userId, PARTICIPANT_STATUS.JOINED, now, now, now]
    );
  }
  await execute(
    env2.DB,
    `UPDATE group_sessions
        SET current_participants = current_participants + 1,
            updated_at = ?
      WHERE session_id = ?`,
    [now, sessionId]
  );
  try {
    await createNotification(env2, {
      userId: session.hostUserId,
      type: "GROUP_SESSION_JOINED",
      title: "\uC0C8\uB85C\uC6B4 \uCC38\uAC00\uC790",
      content: `${userName}\uB2D8\uC774 "${session.title}" \uADF8\uB8F9 \uC138\uC158\uC5D0 \uCC38\uAC00\uD588\uC2B5\uB2C8\uB2E4.`,
      category: "group_session",
      priority: 1,
      actionUrl: `/group-sessions/${sessionId}`,
      actionData: {
        sessionId,
        sessionTitle: session.title,
        participantId: userId,
        participantName: userName
      },
      senderUserId: userId
    });
  } catch (error48) {
    console.error("Failed to send GROUP_SESSION_JOINED notification:", error48);
  }
  await invalidateGroupSessionCache(env2, sessionId);
  await addActiveSession(env2, userId, sessionId);
  await addRecentSession(env2, userId, sessionId);
  return getGroupSessionById(env2, sessionId, userId);
}
__name(joinGroupSession, "joinGroupSession");
async function joinGroupSessionByCode(env2, userId, joinCode, payload = {}) {
  const row = await queryFirst(
    env2.DB,
    "SELECT session_id FROM group_sessions WHERE join_code = ? LIMIT 1",
    [joinCode]
  );
  if (!row) throw new Error("\uCC38\uAC00 \uCF54\uB4DC\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  return joinGroupSession(env2, userId, row.session_id, payload);
}
__name(joinGroupSessionByCode, "joinGroupSessionByCode");
async function leaveGroupSession(env2, userId, sessionId) {
  const participant = await ensureParticipant(env2, sessionId, userId);
  if (!participant || participant.status !== PARTICIPANT_STATUS.JOINED) {
    return;
  }
  const now = nowIso3();
  await execute(
    env2.DB,
    `UPDATE group_session_participants
        SET status = ?, left_at = ?, updated_at = ?
      WHERE session_id = ? AND user_id = ?`,
    [PARTICIPANT_STATUS.LEFT, now, now, sessionId, userId]
  );
  await execute(
    env2.DB,
    `UPDATE group_sessions
        SET current_participants = CASE WHEN current_participants > 0 THEN current_participants - 1 ELSE 0 END,
            updated_at = ?
      WHERE session_id = ?`,
    [now, sessionId]
  );
  await invalidateGroupSessionCache(env2, sessionId);
  await removeActiveSession(env2, userId, sessionId);
}
__name(leaveGroupSession, "leaveGroupSession");
async function startGroupSession(env2, userId, sessionId) {
  const session = await getGroupSessionById(env2, sessionId);
  if (session.hostUserId !== userId) throw new Error("\uC138\uC158\uC744 \uC2DC\uC791\uD560 \uAD8C\uD55C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
  const now = nowIso3();
  await execute(
    env2.DB,
    "UPDATE group_sessions SET status = ?, started_at = ?, updated_at = ? WHERE session_id = ?",
    [GROUP_STATUS.ACTIVE, now, now, sessionId]
  );
  const participants = await query(
    env2.DB,
    "SELECT user_id FROM group_session_participants WHERE session_id = ? AND status = ? AND user_id != ?",
    [sessionId, PARTICIPANT_STATUS.JOINED, userId]
  );
  for (const participant of participants) {
    try {
      await createNotification(env2, {
        userId: participant.user_id,
        type: "GROUP_SESSION_STARTED",
        title: "\uADF8\uB8F9 \uC138\uC158 \uC2DC\uC791",
        content: `"${session.title}" \uADF8\uB8F9 \uC138\uC158\uC774 \uC2DC\uC791\uB418\uC5C8\uC2B5\uB2C8\uB2E4. \uC9C0\uAE08 \uCC38\uC5EC\uD558\uC138\uC694!`,
        category: "group_session",
        priority: 3,
        //  (    )
        actionUrl: `/group-sessions/${sessionId}`,
        actionData: {
          sessionId,
          sessionTitle: session.title,
          hostUserId: userId
        },
        senderUserId: userId
      });
    } catch (error48) {
      console.error(`Failed to send GROUP_SESSION_STARTED notification to ${participant.user_id}:`, error48);
    }
  }
  await invalidateGroupSessionCache(env2, sessionId);
  return getGroupSessionById(env2, sessionId, userId);
}
__name(startGroupSession, "startGroupSession");
async function endGroupSession(env2, userId, sessionId) {
  const session = await getGroupSessionById(env2, sessionId);
  if (session.hostUserId !== userId) throw new Error("\uC138\uC158\uC744 \uC885\uB8CC\uD560 \uAD8C\uD55C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
  const now = nowIso3();
  await execute(
    env2.DB,
    "UPDATE group_sessions SET status = ?, ended_at = ?, updated_at = ? WHERE session_id = ?",
    [GROUP_STATUS.COMPLETED, now, now, sessionId]
  );
  await invalidateGroupSessionCache(env2, sessionId);
  return getGroupSessionById(env2, sessionId, userId);
}
__name(endGroupSession, "endGroupSession");
async function cancelGroupSession(env2, userId, sessionId, reason) {
  const session = await getGroupSessionById(env2, sessionId);
  if (session.hostUserId !== userId) throw new Error("\uC138\uC158\uC744 \uCDE8\uC18C\uD560 \uAD8C\uD55C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
  const participants = await query(
    env2.DB,
    "SELECT user_id FROM group_session_participants WHERE session_id = ? AND status = ? AND user_id != ?",
    [sessionId, PARTICIPANT_STATUS.JOINED, userId]
  );
  const now = nowIso3();
  await execute(
    env2.DB,
    `UPDATE group_sessions
        SET status = ?, ended_at = ?, updated_at = ?
      WHERE session_id = ?`,
    [GROUP_STATUS.CANCELLED, now, now, sessionId]
  );
  await execute(
    env2.DB,
    `UPDATE group_session_participants
        SET status = ?, updated_at = ?
      WHERE session_id = ? AND status = ?`,
    [PARTICIPANT_STATUS.LEFT, now, sessionId, PARTICIPANT_STATUS.JOINED]
  );
  const reasonText = reason ? ` (\uC0AC\uC720: ${reason})` : "";
  for (const participant of participants) {
    try {
      await createNotification(env2, {
        userId: participant.user_id,
        type: "GROUP_SESSION_CANCELLED",
        title: "\uADF8\uB8F9 \uC138\uC158 \uCDE8\uC18C",
        content: `"${session.title}" \uADF8\uB8F9 \uC138\uC158\uC774 \uCDE8\uC18C\uB418\uC5C8\uC2B5\uB2C8\uB2E4${reasonText}.`,
        category: "group_session",
        priority: 2,
        actionUrl: `/group-sessions`,
        actionData: {
          sessionId,
          sessionTitle: session.title,
          hostUserId: userId,
          reason
        },
        senderUserId: userId
      });
    } catch (error48) {
      console.error(`Failed to send GROUP_SESSION_CANCELLED notification to ${participant.user_id}:`, error48);
    }
  }
  await invalidateGroupSessionCache(env2, sessionId);
}
__name(cancelGroupSession, "cancelGroupSession");
async function listAvailableGroupSessions(env2, page, size, filters = {}, currentUserId) {
  const offset = (page - 1) * size;
  const where = ["status = ?", "is_public = 1"];
  const params = [GROUP_STATUS.SCHEDULED];
  if (filters.language) {
    where.push("UPPER(target_language) = UPPER(?)");
    params.push(filters.language);
  }
  if (filters.level) {
    where.push("UPPER(language_level) = UPPER(?)");
    params.push(filters.level);
  }
  if (filters.category) {
    where.push("UPPER(topic_category) = UPPER(?)");
    params.push(filters.category);
  }
  if (filters.tags && filters.tags.length > 0) {
    where.push(filters.tags.map(() => "session_tags LIKE '%' || ? || '%' ").join(" AND "));
    params.push(...filters.tags);
  }
  const whereClause = where.length ? `WHERE ${where.join(" AND ")}` : "";
  const totalRow = await queryFirst(
    env2.DB,
    `SELECT COUNT(*) as count FROM group_sessions ${whereClause}`,
    params
  );
  const rows = await query(
    env2.DB,
    `SELECT gs.*, host.name AS host_user_name, host.profile_image AS host_profile_image
       FROM group_sessions gs
       LEFT JOIN users host ON host.user_id = gs.host_user_id
      ${whereClause}
      ORDER BY gs.scheduled_at ASC
      LIMIT ? OFFSET ?`,
    [...params, size, offset]
  );
  const data = rows.map((row) => mapGroupList(row, currentUserId));
  return {
    data,
    page,
    size,
    total: totalRow?.count ?? 0
  };
}
__name(listAvailableGroupSessions, "listAvailableGroupSessions");
async function listUserGroupSessions(env2, userId, status) {
  const rows = await query(
    env2.DB,
    `SELECT gs.*, host.name AS host_user_name, host.profile_image AS host_profile_image
       FROM group_session_participants gsp
       JOIN group_sessions gs ON gs.session_id = gsp.session_id
       LEFT JOIN users host ON host.user_id = gs.host_user_id
      WHERE gsp.user_id = ? ${status ? "AND gs.status = ?" : ""}
      ORDER BY gs.scheduled_at DESC`,
    status ? [userId, status] : [userId]
  );
  const result = [];
  for (const row of rows) {
    const participants = await fetchParticipants(env2, row.session_id);
    result.push(mapGroupSession(row, participants, userId));
  }
  return result;
}
__name(listUserGroupSessions, "listUserGroupSessions");
async function listHostedGroupSessions(env2, userId) {
  const rows = await query(
    env2.DB,
    `SELECT gs.*, host.name AS host_user_name, host.profile_image AS host_profile_image
       FROM group_sessions gs
       LEFT JOIN users host ON host.user_id = gs.host_user_id
      WHERE gs.host_user_id = ?
      ORDER BY gs.scheduled_at DESC`,
    [userId]
  );
  const result = [];
  for (const row of rows) {
    const participants = await fetchParticipants(env2, row.session_id);
    result.push(mapGroupSession(row, participants, userId));
  }
  return result;
}
__name(listHostedGroupSessions, "listHostedGroupSessions");
async function kickGroupParticipant(env2, hostUserId, sessionId, participantId) {
  const session = await getGroupSessionById(env2, sessionId, hostUserId);
  if (session.hostUserId !== hostUserId) throw new Error("\uCC38\uAC00\uC790\uB97C \uCD94\uBC29\uD560 \uAD8C\uD55C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
  const participant = await ensureParticipant(env2, sessionId, participantId);
  if (!participant) throw new Error("\uCC38\uAC00\uC790\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  const now = nowIso3();
  await execute(
    env2.DB,
    `UPDATE group_session_participants
        SET status = ?, left_at = ?, updated_at = ?
      WHERE session_id = ? AND user_id = ?`,
    [PARTICIPANT_STATUS.KICKED, now, now, sessionId, participantId]
  );
  await execute(
    env2.DB,
    `UPDATE group_sessions
        SET current_participants = CASE WHEN current_participants > 0 THEN current_participants - 1 ELSE 0 END,
            updated_at = ?
      WHERE session_id = ?`,
    [now, sessionId]
  );
  await invalidateGroupSessionCache(env2, sessionId);
  await removeActiveSession(env2, participantId, sessionId);
}
__name(kickGroupParticipant, "kickGroupParticipant");
async function rateGroupSession(env2, userId, sessionId, rating, feedback) {
  const participant = await ensureParticipant(env2, sessionId, userId);
  if (!participant || participant.status !== PARTICIPANT_STATUS.JOINED) {
    throw new Error("\uC138\uC158\uC5D0 \uCC38\uAC00\uD558\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
  }
  const now = nowIso3();
  await execute(
    env2.DB,
    `UPDATE group_session_participants
        SET rating = ?, feedback = ?, updated_at = ?
      WHERE session_id = ? AND user_id = ?`,
    [rating, feedback ?? null, now, sessionId, userId]
  );
  await execute(
    env2.DB,
    `UPDATE group_sessions
        SET rating_average = (
          SELECT AVG(rating) FROM group_session_participants
            WHERE session_id = ? AND rating IS NOT NULL
        ),
            rating_count = (
          SELECT COUNT(*) FROM group_session_participants
            WHERE session_id = ? AND rating IS NOT NULL
        ),
            updated_at = ?
      WHERE session_id = ?`,
    [sessionId, sessionId, now, sessionId]
  );
  await invalidateGroupSessionCache(env2, sessionId);
}
__name(rateGroupSession, "rateGroupSession");
async function updateGroupSession(env2, hostUserId, sessionId, payload) {
  const session = await getGroupSessionById(env2, sessionId);
  if (session.hostUserId !== hostUserId) throw new Error("\uC138\uC158\uC744 \uC218\uC815\uD560 \uAD8C\uD55C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
  const participants = await query(
    env2.DB,
    "SELECT user_id FROM group_session_participants WHERE session_id = ? AND status = ? AND user_id != ?",
    [sessionId, PARTICIPANT_STATUS.JOINED, hostUserId]
  );
  const now = nowIso3();
  await execute(
    env2.DB,
    `UPDATE group_sessions
        SET title = ?,
            description = ?,
            topic_category = ?,
            target_language = ?,
            language_level = ?,
            max_participants = ?,
            scheduled_at = ?,
            session_duration = ?,
            session_tags = ?,
            is_public = ?,
            updated_at = ?
      WHERE session_id = ?`,
    [
      payload.title,
      payload.description ?? null,
      payload.topicCategory,
      payload.targetLanguage,
      payload.languageLevel,
      payload.maxParticipants,
      payload.scheduledAt,
      payload.sessionDuration,
      payload.sessionTags ? payload.sessionTags.join(",") : null,
      payload.isPublic ? 1 : 0,
      now,
      sessionId
    ]
  );
  let changeDetails = "";
  if (session.title !== payload.title) {
    changeDetails = "\uC138\uC158 \uC81C\uBAA9\uC774 \uBCC0\uACBD\uB418\uC5C8\uC2B5\uB2C8\uB2E4.";
  } else if (session.scheduledAt !== payload.scheduledAt) {
    changeDetails = "\uC138\uC158 \uC77C\uC815\uC774 \uBCC0\uACBD\uB418\uC5C8\uC2B5\uB2C8\uB2E4.";
  } else {
    changeDetails = "\uC138\uC158 \uC815\uBCF4\uAC00 \uC5C5\uB370\uC774\uD2B8\uB418\uC5C8\uC2B5\uB2C8\uB2E4.";
  }
  for (const participant of participants) {
    try {
      await createNotification(env2, {
        userId: participant.user_id,
        type: "GROUP_SESSION_UPDATED",
        title: "\uADF8\uB8F9 \uC138\uC158 \uBCC0\uACBD",
        content: `"${payload.title}" \uADF8\uB8F9 \uC138\uC158 \uC815\uBCF4\uAC00 \uC5C5\uB370\uC774\uD2B8\uB418\uC5C8\uC2B5\uB2C8\uB2E4. ${changeDetails}`,
        category: "group_session",
        priority: 2,
        actionUrl: `/group-sessions/${sessionId}`,
        actionData: {
          sessionId,
          sessionTitle: payload.title,
          hostUserId,
          scheduledAt: payload.scheduledAt,
          changes: changeDetails
        },
        senderUserId: hostUserId
      });
    } catch (error48) {
      console.error(`Failed to send GROUP_SESSION_UPDATED notification to ${participant.user_id}:`, error48);
    }
  }
  await invalidateGroupSessionCache(env2, sessionId);
}
__name(updateGroupSession, "updateGroupSession");
async function inviteToGroupSession(env2, hostUserId, sessionId, invitedUserIds) {
  const session = await getGroupSessionById(env2, sessionId);
  if (session.hostUserId !== hostUserId) throw new Error("\uC138\uC158\uC744 \uCD08\uB300\uD560 \uAD8C\uD55C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
  const hostInfo = await queryFirst(env2.DB, "SELECT english_name, name FROM users WHERE user_id = ? LIMIT 1", [hostUserId]);
  const hostName = hostInfo?.english_name || hostInfo?.name || "\uC0AC\uC6A9\uC790";
  const now = nowIso3();
  for (const userId of invitedUserIds) {
    await execute(
      env2.DB,
      `INSERT INTO group_session_participants (
          participant_id, session_id, user_id, status, joined_at, created_at, updated_at
        ) VALUES (?, ?, ?, ?, NULL, ?, ?)
        ON CONFLICT(session_id, user_id) DO UPDATE SET status = excluded.status, updated_at = excluded.updated_at`,
      [crypto.randomUUID(), sessionId, userId, PARTICIPANT_STATUS.INVITED, now, now]
    );
    await saveInvitation(env2, sessionId, userId, hostUserId);
    try {
      await createNotification(env2, {
        userId,
        type: "GROUP_SESSION_INVITE",
        title: "\uADF8\uB8F9 \uC138\uC158 \uCD08\uB300",
        content: `${hostName}\uB2D8\uC774 "${session.title}" \uADF8\uB8F9 \uC138\uC158\uC5D0 \uCD08\uB300\uD588\uC2B5\uB2C8\uB2E4.`,
        category: "group_session",
        priority: 2,
        actionUrl: `/group-sessions/${sessionId}`,
        actionData: {
          sessionId,
          sessionTitle: session.title,
          hostUserId,
          hostName,
          scheduledAt: session.scheduledAt
        },
        senderUserId: hostUserId
      });
    } catch (error48) {
      console.error("Failed to send GROUP_SESSION_INVITE notification:", error48);
    }
  }
  await invalidateGroupSessionCache(env2, sessionId);
  return getGroupSessionById(env2, sessionId, hostUserId);
}
__name(inviteToGroupSession, "inviteToGroupSession");
async function respondToInvitation(env2, userId, sessionId, accept) {
  const invitation = await getInvitation(env2, sessionId, userId);
  if (!invitation) throw new Error("\uCD08\uB300 \uAE30\uB85D\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
  const participant = await ensureParticipant(env2, sessionId, userId);
  if (!participant) throw new Error("\uCD08\uB300 \uAE30\uB85D\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
  const now = nowIso3();
  if (accept) {
    await execute(
      env2.DB,
      `UPDATE group_session_participants
          SET status = ?, joined_at = COALESCE(joined_at, ?), updated_at = ?
        WHERE session_id = ? AND user_id = ?`,
      [PARTICIPANT_STATUS.JOINED, now, now, sessionId, userId]
    );
    await execute(
      env2.DB,
      `UPDATE group_sessions
          SET current_participants = current_participants + 1,
              updated_at = ?
        WHERE session_id = ?`,
      [now, sessionId]
    );
    await addActiveSession(env2, userId, sessionId);
  } else {
    await execute(
      env2.DB,
      `UPDATE group_session_participants
          SET status = ?, updated_at = ?, left_at = COALESCE(left_at, ?)
        WHERE session_id = ? AND user_id = ?`,
      [PARTICIPANT_STATUS.BANNED, now, now, sessionId, userId]
    );
  }
  await invalidateGroupSessionCache(env2, sessionId);
  await deleteInvitation(env2, sessionId, userId);
}
__name(respondToInvitation, "respondToInvitation");
async function getRecommendedGroupSessions(env2, userId) {
  const rows = await query(
    env2.DB,
    `SELECT gs.*, host.name AS host_user_name, host.profile_image AS host_profile_image
       FROM group_sessions gs
       LEFT JOIN users host ON host.user_id = gs.host_user_id
      WHERE gs.is_public = 1 AND gs.status = ?
      ORDER BY gs.scheduled_at ASC
      LIMIT 5`,
    [GROUP_STATUS.SCHEDULED]
  );
  const items = [];
  for (const row of rows) {
    const participants = await fetchParticipants(env2, row.session_id);
    items.push(mapGroupSession(row, participants, userId));
  }
  return items;
}
__name(getRecommendedGroupSessions, "getRecommendedGroupSessions");
async function searchGroupSessions(env2, keyword, language, level) {
  const where = ["is_public = 1"];
  const params = [];
  if (keyword) {
    where.push("(title LIKE ? OR description LIKE ? OR topic_category LIKE ?)");
    params.push(`%${keyword}%`, `%${keyword}%`, `%${keyword}%`);
  }
  if (language) {
    where.push("target_language = ?");
    params.push(language);
  }
  if (level) {
    where.push("language_level = ?");
    params.push(level);
  }
  const rows = await query(
    env2.DB,
    `SELECT gs.*, host.name AS host_user_name, host.profile_image AS host_profile_image
       FROM group_sessions gs
       LEFT JOIN users host ON host.user_id = gs.host_user_id
      ${where.length ? "WHERE " + where.join(" AND ") : ""}
      ORDER BY gs.scheduled_at ASC
      LIMIT 50`,
    params
  );
  return rows.map((row) => mapGroupList(row));
}
__name(searchGroupSessions, "searchGroupSessions");

// src/services/groupSessionsAI.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var PROGRESS_TTL_SECONDS = 60 * 60 * 24 * 90;
var PROGRESS_HISTORY_LIMIT = 50;
function parseJsonWithFallback(text, fallback) {
  try {
    return JSON.parse(text);
  } catch (error48) {
    log3.warn("Failed to parse AI JSON response", error48, {
      component: "GROUP_SESSION_AI",
      preview: text.slice(0, 240)
    });
    return fallback;
  }
}
__name(parseJsonWithFallback, "parseJsonWithFallback");
async function callStructuredChat(env2, systemPrompt, userPrompt, fallback, options = {}) {
  const messages = [
    { role: "system", content: systemPrompt },
    { role: "user", content: userPrompt }
  ];
  const response = await generateChatCompletion(env2.AI, messages, {
    temperature: options.temperature ?? 0.6,
    max_tokens: options.maxTokens ?? 900,
    response_format: { type: "json_object" }
  });
  const sanitized = sanitizeJsonResponse(response.text);
  if (!sanitized) {
    return fallback;
  }
  return parseJsonWithFallback(sanitized, fallback);
}
__name(callStructuredChat, "callStructuredChat");
async function recommendSessionTopics(env2, userId, input) {
  const fallback = {
    topics: [
      {
        title: "Daily Highlights",
        description: "Share the most interesting part of your day and ask follow-up questions to others.",
        difficulty: input.level || "INTERMEDIATE",
        culturalTips: [],
        followUpQuestions: [
          "What made that moment special?",
          "Would you do anything differently next time?"
        ]
      }
    ]
  };
  const interestsText = (input.interests || []).join(", ") || "general interests";
  const userPrompt = `Recommend three engaging conversation topics for a small group session.

Context:
- Participants' primary learning language: ${input.language || "English"}
- Average proficiency level: ${input.level || "Intermediate"}
- Shared interests or focus areas: ${interestsText || "general conversation"}
- Group size: ${input.participantCount || 4}

Return JSON in the format:
{
  "topics": [
    {
      "title": string,
      "description": string,
      "difficulty": "BEGINNER" | "INTERMEDIATE" | "ADVANCED",
      "estimatedDurationMinutes": number,
      "culturalTips": string[],
      "followUpQuestions": string[]
    }
  ]
}`;
  return callStructuredChat(
    env2,
    "You are an expert language tutor who designs conversation prompts that encourage balanced participation and vocabulary growth.",
    userPrompt,
    fallback,
    { temperature: 0.7, maxTokens: 800 }
  );
}
__name(recommendSessionTopics, "recommendSessionTopics");
async function analyzeConversationTranscript(env2, userId, input) {
  const fallback = {
    overallScore: 70,
    strengths: ["Clear structure"],
    improvements: ["Use more varied vocabulary"],
    suggestedTopics: ["Cultural experiences"],
    keyPhrases: [],
    summary: "Participants engaged in a structured conversation.",
    sentiment: "neutral"
  };
  const userPrompt = `Analyze this group session transcript for language learning insights.
Provide:
- overallScore (0-100)
- strengths (array of strings)
- improvements (array of strings)
- suggestedTopics (array)
- keyPhrases (array of strings)
- summary (string)
- sentiment (positive/neutral/negative)

Transcript:
${input.transcript}
`;
  return callStructuredChat(
    env2,
    "You are an experienced ESL coach. Focus on constructive, encouraging feedback.",
    userPrompt,
    fallback,
    { temperature: 0.4, maxTokens: 800 }
  );
}
__name(analyzeConversationTranscript, "analyzeConversationTranscript");
async function generateSessionSummary(env2, userId, input) {
  const participantsLine = (input.participants || []).map((p) => `${p.name || p.id || "Participant"}${p.role ? ` (${p.role})` : ""}`).join(", ");
  const fallback = {
    summary: "Participants discussed the main topic and shared personal experiences.",
    highlights: ["Active participation from all members"],
    actionItems: ["Prepare vocabulary list for next session"],
    followUpQuestions: ["What vocabulary felt challenging?"],
    vocabulary: []
  };
  const userPrompt = `Summarize the group session for language learners.
Include summary, 2-3 highlights, actionItems, followUpQuestions, and vocabulary array with phrase/meaning.

Language: ${input.language || "English"}
Duration (minutes): ${input.duration ?? "unknown"}
Participants: ${participantsLine || "Not specified"}
Transcript:
${input.transcript}
`;
  return callStructuredChat(
    env2,
    "You are a language coach who produces concise post-session reports for learners.",
    userPrompt,
    fallback,
    { temperature: 0.5, maxTokens: 900 }
  );
}
__name(generateSessionSummary, "generateSessionSummary");
async function generateIcebreakers(env2, userId, input) {
  const fallback = {
    icebreakers: [
      "Share one surprising fact about your hometown and ask others to react to it."
    ]
  };
  const userPrompt = `Provide five creative icebreaker prompts for a group session.
Language: ${input.language || "English"}
Learner level: ${input.level || "Intermediate"}
Topic focus: ${input.topic || "General conversation"}
Return JSON: { "icebreakers": string[] }
`;
  return callStructuredChat(
    env2,
    "You are a facilitator who creates inclusive, culturally sensitive warm-up questions.",
    userPrompt,
    fallback,
    { temperature: 0.8, maxTokens: 500 }
  );
}
__name(generateIcebreakers, "generateIcebreakers");
async function generateRoleplayScenario(env2, userId, input) {
  const fallback = {
    scenarioTitle: "Business Meeting Kick-off",
    setting: "Virtual conference call with international teammates",
    roles: ["Project lead", "Marketing specialist", "Engineer"],
    goals: ["Align on project scope", "Assign next steps"],
    scriptOutline: [
      "Introduction and greetings",
      "Discuss project objectives",
      "Clarify deliverables"
    ],
    vocabulary: []
  };
  const rolesText = (input.participantRoles || []).join(", ") || "Flexible roles for 3-4 participants";
  const userPrompt = `Create a roleplay scenario for language learners.
Include scenarioTitle, setting, roles, goals, scriptOutline (array of steps), vocabulary (array of { phrase, meaning }).

Language: ${input.language || "English"}
Level: ${input.level || "Intermediate"}
Situation: ${input.situation || "Business discussion"}
Participant roles: ${rolesText}
`;
  return callStructuredChat(
    env2,
    "You design practical roleplay activities that build speaking confidence.",
    userPrompt,
    fallback,
    { temperature: 0.75, maxTokens: 850 }
  );
}
__name(generateRoleplayScenario, "generateRoleplayScenario");
async function translateExpression(env2, userId, input) {
  const fallback = {
    translation: input.text,
    pronunciation: null,
    usageNotes: [],
    examples: []
  };
  const userPrompt = `Translate the following text for language learners.
Return JSON with fields: translation (string), pronunciation (string|null), usageNotes (string[]),
examples (array of { original, translated }).

Source language: ${input.fromLanguage || "auto"}
Target language: ${input.toLanguage}
Text:
${input.text}
`;
  return callStructuredChat(
    env2,
    "You are a bilingual language coach who provides nuanced translations with context.",
    userPrompt,
    fallback,
    { temperature: 0.4, maxTokens: 700 }
  );
}
__name(translateExpression, "translateExpression");
async function recommendSessionMatches(env2, userId, input) {
  const fallback = {
    matches: [],
    strategy: "Recommend sessions by topic relevance and speaking level proximity."
  };
  const profileSummary = JSON.stringify(input.userProfile ?? {});
  const sessionsInfo = JSON.stringify(input.availableSessions ?? []);
  const userPrompt = `Recommend up to five group sessions for the learner.
Return JSON with fields:
{
  "matches": [
    {
      "sessionId": string | null,
      "title": string,
      "fitScore": number (0-100),
      "reason": string
    }
  ],
  "strategy": string
}

Learner profile:
${profileSummary}

Available sessions:
${sessionsInfo}
`;
  return callStructuredChat(
    env2,
    "You are an AI assistant matching language learners to the most suitable group discussions.",
    userPrompt,
    fallback,
    { temperature: 0.6, maxTokens: 900 }
  );
}
__name(recommendSessionMatches, "recommendSessionMatches");
function progressKey(userId) {
  return `group-session:progress:${userId}`;
}
__name(progressKey, "progressKey");
async function saveLearningProgress(env2, record2) {
  const existingRaw = await env2.CACHE.get(progressKey(record2.userId));
  let history = [];
  if (existingRaw) {
    try {
      history = JSON.parse(existingRaw);
    } catch (error48) {
      log3.warn("Failed to parse existing learning progress history", error48, {
        component: "GROUP_SESSION_AI"
      });
      history = [];
    }
  }
  const entry = {
    ...record2,
    savedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  history.unshift(entry);
  if (history.length > PROGRESS_HISTORY_LIMIT) {
    history = history.slice(0, PROGRESS_HISTORY_LIMIT);
  }
  await env2.CACHE.put(progressKey(record2.userId), JSON.stringify(history), {
    expirationTtl: PROGRESS_TTL_SECONDS
  });
  return entry;
}
__name(saveLearningProgress, "saveLearningProgress");

// src/routes/groupSessions.ts
var groupSessionsRoutes = new Hono2();
var requireAuth5 = auth();
function getPaginationParams2(c) {
  const page = Math.max(Number(c.req.query("page") ?? "1"), 1);
  const size = Math.max(Math.min(Number(c.req.query("size") ?? "20"), 50), 1);
  return { page, size };
}
__name(getPaginationParams2, "getPaginationParams");
function requirePathParam(value, field) {
  if (!value) {
    throw new AppError(`Invalid ${field}`, 400, "INVALID_PATH_PARAM");
  }
  return value;
}
__name(requirePathParam, "requirePathParam");
function requireUserId(c) {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  }
  return userId;
}
__name(requireUserId, "requireUserId");
groupSessionsRoutes.use("*", requireAuth5);
groupSessionsRoutes.post("/", async (c) => {
  const hostUserId = c.get("userId");
  if (!hostUserId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  const required2 = ["title", "topicCategory", "targetLanguage", "languageLevel", "maxParticipants", "scheduledAt", "sessionDuration", "isPublic"];
  const missing = required2.filter((key) => body[key] === void 0 || body[key] === null || body[key] === "");
  if (missing.length) {
    throw new AppError(`Missing fields: ${missing.join(", ")}`, 400, "INVALID_PAYLOAD");
  }
  const session = await createGroupSession(c.env, hostUserId, body);
  return successResponse(c, session);
});
groupSessionsRoutes.get("/:sessionId", async (c) => {
  const userId = requireUserId(c);
  const sessionId = requirePathParam(c.req.param("sessionId"), "sessionId");
  const session = await getGroupSessionById(c.env, sessionId, userId);
  return successResponse(c, session);
});
groupSessionsRoutes.post("/:sessionId/join", async (c) => {
  const userId = requireUserId(c);
  const sessionId = requirePathParam(c.req.param("sessionId"), "sessionId");
  const body = await c.req.json().catch(() => ({}));
  const session = await joinGroupSession(c.env, userId, sessionId, body);
  return successResponse(c, session);
});
groupSessionsRoutes.post("/join/:joinCode", async (c) => {
  const userId = requireUserId(c);
  const joinCode = requirePathParam(c.req.param("joinCode"), "joinCode");
  const body = await c.req.json().catch(() => ({}));
  const session = await joinGroupSessionByCode(c.env, userId, joinCode, body);
  return successResponse(c, session);
});
groupSessionsRoutes.post("/:sessionId/leave", async (c) => {
  const userId = requireUserId(c);
  const sessionId = requirePathParam(c.req.param("sessionId"), "sessionId");
  await leaveGroupSession(c.env, userId, sessionId);
  return successResponse(c, { success: true });
});
groupSessionsRoutes.post("/:sessionId/start", async (c) => {
  const userId = requireUserId(c);
  const sessionId = requirePathParam(c.req.param("sessionId"), "sessionId");
  const session = await startGroupSession(c.env, userId, sessionId);
  return successResponse(c, session);
});
groupSessionsRoutes.post("/:sessionId/end", async (c) => {
  const userId = requireUserId(c);
  const sessionId = requirePathParam(c.req.param("sessionId"), "sessionId");
  const session = await endGroupSession(c.env, userId, sessionId);
  return successResponse(c, session);
});
groupSessionsRoutes.post("/:sessionId/cancel", async (c) => {
  const userId = requireUserId(c);
  const sessionId = requirePathParam(c.req.param("sessionId"), "sessionId");
  const reason = c.req.query("reason") ?? void 0;
  await cancelGroupSession(c.env, userId, sessionId, reason);
  return successResponse(c, { success: true });
});
groupSessionsRoutes.get("/", async (c) => {
  const userId = c.get("userId");
  const { page, size } = getPaginationParams2(c);
  const filters = {
    language: c.req.query("language"),
    level: c.req.query("level"),
    category: c.req.query("category"),
    tags: c.req.query("tags") ? c.req.query("tags").split(",").map((t) => t.trim()).filter(Boolean) : void 0
  };
  const result = await listAvailableGroupSessions(c.env, page, size, filters, userId ?? void 0);
  return paginatedResponse(c, result.data, {
    page: result.page,
    limit: result.size,
    total: result.total
  });
});
groupSessionsRoutes.get("/available", async (c) => {
  const userId = c.get("userId");
  const { page, size } = getPaginationParams2(c);
  const filters = {
    language: c.req.query("language"),
    level: c.req.query("level"),
    category: c.req.query("category"),
    tags: c.req.query("tags") ? c.req.query("tags").split(",").map((t) => t.trim()).filter(Boolean) : void 0
  };
  const result = await listAvailableGroupSessions(c.env, page, size, filters, userId ?? void 0);
  return paginatedResponse(c, result.data, {
    page: result.page,
    limit: result.size,
    total: result.total
  });
});
groupSessionsRoutes.get("/my", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const status = c.req.query("status") ?? void 0;
  const sessions = await listUserGroupSessions(c.env, userId, status ?? void 0);
  return successResponse(c, sessions);
});
groupSessionsRoutes.get("/my-sessions", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const status = c.req.query("status") ?? void 0;
  const sessions = await listUserGroupSessions(c.env, userId, status ?? void 0);
  return successResponse(c, sessions);
});
groupSessionsRoutes.get("/hosted", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const sessions = await listHostedGroupSessions(c.env, userId);
  return successResponse(c, sessions);
});
groupSessionsRoutes.post("/:sessionId/kick/:participantId", async (c) => {
  const userId = requireUserId(c);
  const sessionId = requirePathParam(c.req.param("sessionId"), "sessionId");
  const participantId = requirePathParam(c.req.param("participantId"), "participantId");
  await kickGroupParticipant(c.env, userId, sessionId, participantId);
  return successResponse(c, { success: true });
});
groupSessionsRoutes.post("/:sessionId/rate", async (c) => {
  const userId = requireUserId(c);
  const sessionId = requirePathParam(c.req.param("sessionId"), "sessionId");
  const rating = Number(c.req.query("rating") ?? c.req.query("score") ?? 0);
  if (!rating || rating < 1 || rating > 5) {
    throw new AppError("rating must be between 1 and 5", 400, "INVALID_QUERY_PARAM");
  }
  const feedback = c.req.query("feedback") ?? void 0;
  await rateGroupSession(c.env, userId, sessionId, rating, feedback);
  return successResponse(c, { success: true });
});
groupSessionsRoutes.put("/:sessionId", async (c) => {
  const userId = requireUserId(c);
  const sessionId = requirePathParam(c.req.param("sessionId"), "sessionId");
  const body = await c.req.json();
  await updateGroupSession(c.env, userId, sessionId, body);
  return successResponse(c, { success: true });
});
groupSessionsRoutes.get("/recommended/list", async (c) => {
  const userId = requireUserId(c);
  const sessions = await getRecommendedGroupSessions(c.env, userId);
  return successResponse(c, sessions);
});
groupSessionsRoutes.post("/progress/track", async (c) => {
  const userId = requireUserId(c);
  const body = await c.req.json().catch(() => ({}));
  const sessionId = typeof body.sessionId === "string" ? body.sessionId : void 0;
  const metrics = typeof body.metrics === "object" && body.metrics !== null ? body.metrics : void 0;
  const notes = typeof body.notes === "string" ? body.notes : void 0;
  const completedAt = typeof body.completedAt === "string" ? body.completedAt : void 0;
  let durationMinutes;
  if (typeof body.durationMinutes === "number" && Number.isFinite(body.durationMinutes)) {
    durationMinutes = body.durationMinutes;
  } else if (typeof body.duration === "number" && Number.isFinite(body.duration)) {
    durationMinutes = body.duration;
  }
  const record2 = await saveLearningProgress(c.env, {
    userId,
    sessionId,
    metrics,
    notes,
    completedAt,
    durationMinutes
  });
  return successResponse(c, { saved: true, progress: record2 });
});
groupSessionsRoutes.post("/:sessionId/invite", async (c) => {
  const userId = requireUserId(c);
  const sessionId = requirePathParam(c.req.param("sessionId"), "sessionId");
  const body = await c.req.json();
  if (!Array.isArray(body)) {
    throw new AppError("Expected an array of userIds", 400, "INVALID_PAYLOAD");
  }
  const session = await inviteToGroupSession(c.env, userId, sessionId, body);
  return successResponse(c, session);
});
groupSessionsRoutes.post("/:sessionId/invitation/respond", async (c) => {
  const userId = requireUserId(c);
  const sessionId = requirePathParam(c.req.param("sessionId"), "sessionId");
  const accept = c.req.query("accept");
  const accepted = accept ? accept.toLowerCase() === "true" : true;
  await respondToInvitation(c.env, userId, sessionId, accepted);
  return successResponse(c, { success: true, accepted });
});
groupSessionsRoutes.get("/search", async (c) => {
  const keyword = c.req.query("keyword") ?? "";
  const language = c.req.query("language") ?? void 0;
  const level = c.req.query("level") ?? void 0;
  const sessions = await searchGroupSessions(c.env, keyword, language, level);
  return successResponse(c, sessions);
});
var groupSessions_default = groupSessionsRoutes;

// src/routes/groupSessionsAI.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_errors();
var aiRoutes = new Hono2();
var requireAuth6 = auth();
aiRoutes.use("*", requireAuth6);
var recommendSchema = external_exports.object({
  language: external_exports.string().min(1).default("English"),
  level: external_exports.string().min(1).optional(),
  interests: external_exports.array(external_exports.string().min(1)).optional(),
  participantCount: external_exports.number().int().positive().optional()
});
aiRoutes.post("/recommend-topics", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  }
  const payload = await c.req.json().catch(() => ({}));
  const input = recommendSchema.parse(payload);
  const result = await recommendSessionTopics(c.env, userId, input);
  return successResponse(c, result);
});
var analysisSchema = external_exports.object({
  transcript: external_exports.string().min(5),
  language: external_exports.string().min(1).optional(),
  participantId: external_exports.string().min(1).optional()
});
aiRoutes.post("/analyze-conversation", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  }
  const payload = await c.req.json().catch(() => ({}));
  const input = analysisSchema.parse(payload);
  const result = await analyzeConversationTranscript(c.env, userId, input);
  return successResponse(c, result);
});
var summarySchema = external_exports.object({
  sessionId: external_exports.string().optional(),
  transcript: external_exports.string().min(5),
  duration: external_exports.number().int().positive().optional(),
  language: external_exports.string().min(1).optional(),
  participants: external_exports.array(
    external_exports.object({
      id: external_exports.string().optional(),
      name: external_exports.string().optional(),
      role: external_exports.string().optional()
    })
  ).optional()
});
aiRoutes.post("/generate-summary", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  }
  const payload = await c.req.json().catch(() => ({}));
  const input = summarySchema.parse(payload);
  const result = await generateSessionSummary(c.env, userId, input);
  return successResponse(c, result);
});
var icebreakerSchema = external_exports.object({
  language: external_exports.string().optional(),
  level: external_exports.string().optional(),
  topic: external_exports.string().optional()
});
aiRoutes.post("/icebreakers", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  }
  const payload = await c.req.json().catch(() => ({}));
  const input = icebreakerSchema.parse(payload);
  const result = await generateIcebreakers(c.env, userId, input);
  return successResponse(c, result);
});
var roleplaySchema = external_exports.object({
  language: external_exports.string().optional(),
  level: external_exports.string().optional(),
  situation: external_exports.string().optional(),
  participantRoles: external_exports.array(external_exports.string()).optional()
});
aiRoutes.post("/roleplay", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  }
  const payload = await c.req.json().catch(() => ({}));
  const input = roleplaySchema.parse(payload);
  const result = await generateRoleplayScenario(c.env, userId, input);
  return successResponse(c, result);
});
var translateSchema = external_exports.object({
  text: external_exports.string().min(1),
  fromLanguage: external_exports.string().optional(),
  toLanguage: external_exports.string().min(1)
});
aiRoutes.post("/translate", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  }
  const payload = await c.req.json().catch(() => ({}));
  const input = translateSchema.parse(payload);
  const result = await translateExpression(c.env, userId, input);
  return successResponse(c, result);
});
var matchSchema = external_exports.object({
  userId: external_exports.string().min(1),
  userProfile: external_exports.record(external_exports.unknown()).optional(),
  availableSessions: external_exports.array(external_exports.record(external_exports.unknown())).optional()
});
aiRoutes.post("/match-recommendation", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  }
  const payload = await c.req.json().catch(() => ({}));
  const input = matchSchema.parse(payload);
  const result = await recommendSessionMatches(c.env, userId, input);
  return successResponse(c, result);
});
var groupSessionsAI_default = aiRoutes;

// src/routes/presence.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_errors();
var presenceRoutes = new Hono2();
var requireAuth7 = auth();
async function fetchPresence(env2, userId, path, init) {
  const id = env2.USER_PRESENCE.idFromString(userId);
  const stub = env2.USER_PRESENCE.get(id);
  const url2 = `https://user-presence/${path}`;
  return stub.fetch(new Request(url2, init));
}
__name(fetchPresence, "fetchPresence");
presenceRoutes.use("/internal/*", internalAuth());
presenceRoutes.post("/internal/presence/set", async (c) => {
  const body = await c.req.json();
  const userId = body.userId;
  if (!userId) throw new AppError("userId is required", 400, "INVALID_PAYLOAD");
  const response = await fetchPresence(c.env, userId, "set", {
    method: "POST",
    body: JSON.stringify({
      ...body,
      userId,
      lastSeenAt: (/* @__PURE__ */ new Date()).toISOString()
    }),
    headers: { "Content-Type": "application/json" }
  });
  const data = await response.json().catch(() => ({}));
  return c.json(data, response.status);
});
presenceRoutes.post("/internal/presence/touch", async (c) => {
  const body = await c.req.json().catch(() => ({}));
  const userId = body.userId;
  if (!userId) throw new AppError("userId is required", 400, "INVALID_PAYLOAD");
  const response = await fetchPresence(c.env, userId, "touch", { method: "POST" });
  const data = await response.json().catch(() => ({}));
  return c.json(data, response.status);
});
presenceRoutes.post("/internal/presence/offline", async (c) => {
  const body = await c.req.json().catch(() => ({}));
  const userId = body.userId;
  if (!userId) throw new AppError("userId is required", 400, "INVALID_PAYLOAD");
  const response = await fetchPresence(c.env, userId, "offline", { method: "POST" });
  const data = await response.json().catch(() => ({}));
  return c.json(data, response.status);
});
presenceRoutes.get("/internal/presence/status/:userId", async (c) => {
  const userId = c.req.param("userId");
  if (!userId) throw new AppError("userId is required", 400, "INVALID_PATH_PARAM");
  const response = await fetchPresence(c.env, userId, "status");
  const data = await response.json().catch(() => ({}));
  return c.json(data, response.status);
});
presenceRoutes.use("/*", requireAuth7);
presenceRoutes.post("/presence/status", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  const payload = {
    ...body,
    userId,
    status: body.status ?? "ONLINE"
  };
  const response = await fetchPresence(c.env, userId, "set", {
    method: "POST",
    body: JSON.stringify({ ...payload, lastSeenAt: (/* @__PURE__ */ new Date()).toISOString() }),
    headers: { "Content-Type": "application/json" }
  });
  const data = await response.json().catch(() => ({}));
  return c.json(data, response.status);
});
presenceRoutes.post("/presence/touch", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const response = await fetchPresence(c.env, userId, "touch", { method: "POST" });
  const data = await response.json().catch(() => ({}));
  return c.json(data, response.status);
});
presenceRoutes.post("/presence/offline", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const response = await fetchPresence(c.env, userId, "offline", { method: "POST" });
  const data = await response.json().catch(() => ({}));
  return c.json(data, response.status);
});
presenceRoutes.get("/presence/status", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User context missing", 500, "CONTEXT_MISSING_USER");
  const response = await fetchPresence(c.env, userId, "status");
  const data = await response.json().catch(() => ({}));
  return c.json(data, response.status);
});
var presence_default = presenceRoutes;

// src/routes/matching.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_errors();

// src/services/matching.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_db();
init_errors();
var MATCHING_DEFAULT_EXPIRE_DAYS = 7;
var MATCHING_STATUS = {
  PENDING: "PENDING",
  ACCEPTED: "ACCEPTED",
  REJECTED: "REJECTED",
  CANCELLED: "CANCELLED"
};
async function recommendPartners(env2, userId, options) {
  const whereClauses = ["u.user_id != ?", "IFNULL(u.user_disable, 0) = 0"];
  const params = [userId];
  if (options.nativeLanguage) {
    whereClauses.push("EXISTS (SELECT 1 FROM languages nl WHERE nl.language_id = u.native_lang_id AND (nl.language_code = ? OR nl.language_name = ?))");
    params.push(options.nativeLanguage, options.nativeLanguage);
  }
  if (options.targetLanguage) {
    whereClauses.push(
      `EXISTS (
        SELECT 1 FROM onboarding_lang_level oll
        JOIN languages tl ON tl.language_id = oll.language_id
        WHERE oll.user_id = u.user_id AND (tl.language_code = ? OR tl.language_name = ?)
      )`
    );
    params.push(options.targetLanguage, options.targetLanguage);
  }
  if (options.languageLevel) {
    whereClauses.push(
      `EXISTS (
        SELECT 1 FROM onboarding_lang_level oll
        JOIN lang_level_type lt ON lt.lang_level_id = oll.target_level_id
        WHERE oll.user_id = u.user_id AND (lt.lang_level_name = ? OR lt.category = ?)
      )`
    );
    params.push(options.languageLevel, options.languageLevel);
  }
  const where = whereClauses.length ? `WHERE ${whereClauses.join(" AND ")}` : "";
  const candidateLimit = Math.min(options.size * 5, 100);
  const candidateRows = await query(
    env2.DB,
    `SELECT
        u.user_id,
        u.name,
        u.english_name,
        u.profile_image,
        u.self_bio,
        u.birthyear,
        u.gender,
        loc.country AS location_country,
        loc.city AS location_city,
        u.native_lang_id,
        nl.language_name AS native_language_name,
        nl.language_code AS native_language_code,
        u.communication_method,
        u.daily_minute,
        u.partner_gender,
        u.learning_expectation,
        us.status,
        us.last_seen_at
      FROM users u
      LEFT JOIN user_status us ON us.user_id = u.user_id
      LEFT JOIN locations loc ON loc.location_id = u.location_id
      LEFT JOIN languages nl ON nl.language_id = u.native_lang_id
      ${where}
      ORDER BY u.updated_at DESC, u.created_at DESC
      LIMIT ?
    `,
    [...params, candidateLimit]
  );
  if (candidateRows.length === 0) {
    return {
      data: [],
      page: options.page,
      size: options.size,
      total: 0
    };
  }
  const currentUserProfile = await loadCompatibilityProfile(env2, userId);
  const userIds = candidateRows.map((row) => row.user_id);
  const targetLanguagesMap = await loadTargetLanguages(env2, userIds);
  const interestsMap = await loadInterests(env2, userIds);
  const personalitiesMap = await loadPartnerPersonalities(env2, userIds);
  const partnersWithScores = await Promise.all(
    candidateRows.map(async (row) => {
      const birthyearNum = row.birthyear ? Number(row.birthyear) : void 0;
      let age;
      if (birthyearNum && Number.isFinite(birthyearNum)) {
        const currentYear = (/* @__PURE__ */ new Date()).getUTCFullYear();
        age = currentYear - birthyearNum;
      }
      const profileImageUrl = row.profile_image ? `/api/v1/upload/file/${row.profile_image}` : void 0;
      const cacheKey = `compatibility:${userId}:${row.user_id}`;
      let compatibilityScore = 50;
      let compatibilityLevel = "MEDIUM";
      try {
        const cached2 = await env2.CACHE.get(cacheKey, { type: "json" });
        if (cached2) {
          compatibilityScore = cached2.score;
          compatibilityLevel = cached2.level;
        } else {
          const partnerProfile = {
            userId: row.user_id,
            nativeLanguageId: row.native_lang_id ?? void 0,
            nativeLanguageCode: row.native_language_code ?? void 0,
            nativeLanguageName: row.native_language_name ?? void 0,
            targetLanguages: (targetLanguagesMap.get(row.user_id) ?? []).map((lang) => ({
              languageName: lang.languageName,
              currentLevel: lang.currentLevel,
              targetLevel: lang.targetLevel
            })),
            personalities: personalitiesMap.get(row.user_id) ?? [],
            studyGoals: [],
            interests: interestsMap.get(row.user_id) ?? []
          };
          const compatibility = calculateCompatibility(currentUserProfile, partnerProfile);
          compatibilityScore = compatibility.overallScore;
          compatibilityLevel = compatibility.compatibilityLevel;
          await env2.CACHE.put(
            cacheKey,
            JSON.stringify({ score: compatibilityScore, level: compatibilityLevel }),
            { expirationTtl: 86400 }
          ).catch(() => {
          });
        }
      } catch (error48) {
        console.error("Compatibility calculation error:", error48);
      }
      return {
        userId: row.user_id,
        englishName: row.english_name ?? row.name ?? void 0,
        profileImageUrl,
        selfBio: row.self_bio ?? void 0,
        age,
        gender: row.gender ?? void 0,
        location: row.location_country ? row.location_city ? `${row.location_country}, ${row.location_city}` : row.location_country : void 0,
        nativeLanguage: row.native_language_name ?? void 0,
        targetLanguages: targetLanguagesMap.get(row.user_id) ?? [],
        interests: interestsMap.get(row.user_id) ?? [],
        partnerPersonalities: personalitiesMap.get(row.user_id) ?? [],
        compatibilityScore,
        compatibilityLevel,
        onlineStatus: row.status ?? "OFFLINE",
        lastActiveTime: row.last_seen_at ?? void 0
      };
    })
  );
  const sortedPartners = partnersWithScores.sort((a, b) => {
    if (a.onlineStatus === "ONLINE" && b.onlineStatus !== "ONLINE") return -1;
    if (a.onlineStatus !== "ONLINE" && b.onlineStatus === "ONLINE") return 1;
    return b.compatibilityScore - a.compatibilityScore;
  });
  const offset = (options.page - 1) * options.size;
  const paginatedData = sortedPartners.slice(offset, offset + options.size);
  return {
    data: paginatedData,
    page: options.page,
    size: options.size,
    total: sortedPartners.length
  };
}
__name(recommendPartners, "recommendPartners");
function calculateCompatibility(current, partner) {
  const language = computeLanguageCompatibility(current, partner);
  const personality = computePersonalityCompatibility(current, partner);
  const goals = computeGoalCompatibility(current, partner);
  const interests = computeInterestCompatibility(current, partner);
  const overallScore = Math.round(
    (language.score * 0.3 + personality.score * 0.25 + goals.score * 0.25 + interests.score * 0.2) * 10
  ) / 10;
  const compatibilityLevel = determineCompatibilityLevel(overallScore);
  return {
    overallScore,
    compatibilityLevel
  };
}
__name(calculateCompatibility, "calculateCompatibility");
async function loadTargetLanguages(env2, userIds) {
  const map2 = /* @__PURE__ */ new Map();
  if (userIds.length === 0) return map2;
  const placeholders = userIds.map(() => "?").join(",");
  const rows = await query(
    env2.DB,
    `SELECT
        oll.user_id,
        lang.language_name,
        curr.lang_level_name AS current_level_name,
        target.lang_level_name AS target_level_name
      FROM onboarding_lang_level oll
      LEFT JOIN languages lang ON lang.language_id = oll.language_id
      LEFT JOIN lang_level_type curr ON curr.lang_level_id = oll.current_level_id
      LEFT JOIN lang_level_type target ON target.lang_level_id = oll.target_level_id
      WHERE oll.user_id IN (${placeholders})
    `,
    userIds
  );
  for (const row of rows) {
    const list = map2.get(row.user_id) ?? [];
    list.push({
      languageName: row.language_name ?? "Unknown",
      currentLevel: row.current_level_name ?? void 0,
      targetLevel: row.target_level_name ?? void 0
    });
    map2.set(row.user_id, list);
  }
  return map2;
}
__name(loadTargetLanguages, "loadTargetLanguages");
async function loadInterests(env2, userIds) {
  const map2 = /* @__PURE__ */ new Map();
  if (userIds.length === 0) return map2;
  const placeholders = userIds.map(() => "?").join(",");
  const rows = await query(
    env2.DB,
    `SELECT ot.user_id, t.topic_name
       FROM onboarding_topic ot
       JOIN topic t ON t.topic_id = ot.topic_id
       WHERE ot.user_id IN (${placeholders})
    `,
    userIds
  );
  for (const row of rows) {
    const list = map2.get(row.user_id) ?? [];
    if (row.topic_name) list.push(row.topic_name);
    map2.set(row.user_id, list);
  }
  return map2;
}
__name(loadInterests, "loadInterests");
async function loadPartnerPersonalities(env2, userIds) {
  const map2 = /* @__PURE__ */ new Map();
  if (userIds.length === 0) return map2;
  const placeholders = userIds.map(() => "?").join(",");
  const rows = await query(
    env2.DB,
    `SELECT op.user_id, pp.partner_personality
       FROM onboarding_partner op
       JOIN partner_personality pp ON pp.partner_personality_id = op.partner_personality_id
       WHERE op.user_id IN (${placeholders})
    `,
    userIds
  );
  for (const row of rows) {
    const list = map2.get(row.user_id) ?? [];
    if (row.partner_personality) list.push(row.partner_personality);
    map2.set(row.user_id, list);
  }
  return map2;
}
__name(loadPartnerPersonalities, "loadPartnerPersonalities");
function nowIso4() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
__name(nowIso4, "nowIso");
function addDays2(days) {
  const date5 = /* @__PURE__ */ new Date();
  date5.setUTCDate(date5.getUTCDate() + days);
  return date5.toISOString();
}
__name(addDays2, "addDays");
function normalizePair(a, b) {
  return [a, b].sort((x, y) => x < y ? -1 : x > y ? 1 : 0);
}
__name(normalizePair, "normalizePair");
async function createMatchingRequest(env2, payload) {
  try {
    console.log("[createMatchingRequest] Starting with payload:", JSON.stringify({
      senderId: payload.senderId,
      receiverId: payload.receiverId,
      hasMessage: !!payload.message
    }));
    if (!payload.senderId || !payload.receiverId) {
      throw new AppError("senderId\uC640 receiverId\uAC00 \uD544\uC694\uD569\uB2C8\uB2E4.", 400, "MATCHING_INVALID_INPUT");
    }
    if (payload.senderId === payload.receiverId) {
      throw new AppError("\uC790\uAE30 \uC790\uC2E0\uC5D0\uAC8C\uB294 \uB9E4\uCE6D\uC744 \uBCF4\uB0BC \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.", 400, "MATCHING_SELF_REQUEST");
    }
    console.log("[createMatchingRequest] Checking if receiver exists");
    const receiverExists = await queryFirst(
      env2.DB,
      "SELECT user_id FROM users WHERE user_id = ? LIMIT 1",
      [payload.receiverId]
    );
    if (!receiverExists) {
      throw new AppError("\uC874\uC7AC\uD558\uC9C0 \uC54A\uB294 \uC0AC\uC6A9\uC790\uC785\uB2C8\uB2E4.", 404, "MATCHING_USER_NOT_FOUND");
    }
    console.log("[createMatchingRequest] Checking for duplicate requests");
    const duplicate = await queryFirst(
      env2.DB,
      `SELECT request_id FROM matching_requests
         WHERE sender_id = ? AND receiver_id = ? AND status = ?
         LIMIT 1`,
      [payload.senderId, payload.receiverId, MATCHING_STATUS.PENDING]
    );
    if (duplicate) {
      console.log("[createMatchingRequest] Duplicate request found:", duplicate.request_id);
      throw new AppError("\uC774\uBBF8 \uB300\uAE30 \uC911\uC778 \uB9E4\uCE6D \uC694\uCCAD\uC774 \uC788\uC2B5\uB2C8\uB2E4.", 400, "MATCHING_DUPLICATE_REQUEST");
    }
    console.log("[createMatchingRequest] Checking for existing matches");
    const [user1, user2] = normalizePair(payload.senderId, payload.receiverId);
    const existingMatch = await queryFirst(
      env2.DB,
      `SELECT match_id, is_active FROM user_matches
         WHERE (user1_id = ? AND user2_id = ?) OR (user1_id = ? AND user2_id = ?)
         LIMIT 1`,
      [user1, user2, user1, user2]
    );
    if (existingMatch?.is_active) {
      console.log("[createMatchingRequest] Active match found:", existingMatch.match_id);
      throw new AppError("\uC774\uBBF8 \uB9E4\uCE6D\uB41C \uC0AC\uC6A9\uC790\uC785\uB2C8\uB2E4.", 400, "MATCHING_ALREADY_MATCHED");
    }
    const requestId2 = crypto.randomUUID();
    const now = nowIso4();
    const expiresAt = addDays2(MATCHING_DEFAULT_EXPIRE_DAYS);
    console.log("[createMatchingRequest] Inserting new request:", {
      requestId: requestId2,
      senderId: payload.senderId,
      receiverId: payload.receiverId
    });
    try {
      await execute(
        env2.DB,
        `INSERT INTO matching_requests (
            request_id, sender_id, receiver_id, message, status, response_message,
            responded_at, expires_at, created_at, updated_at
          ) VALUES (?, ?, ?, ?, ?, NULL, NULL, ?, ?, ?)
        `,
        [
          requestId2,
          payload.senderId,
          payload.receiverId,
          payload.message ?? null,
          MATCHING_STATUS.PENDING,
          expiresAt,
          now,
          now
        ]
      );
    } catch (dbError) {
      console.error("[createMatchingRequest] Database insert failed:", {
        error: dbError instanceof Error ? dbError.message : String(dbError),
        stack: dbError instanceof Error ? dbError.stack : void 0
      });
      throw new AppError(
        "\uB9E4\uCE6D \uC694\uCCAD \uC0DD\uC131\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4. \uC7A0\uC2DC \uD6C4 \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694.",
        500,
        "MATCHING_DB_INSERT_FAILED"
      );
    }
    console.log("[createMatchingRequest] Successfully created request:", requestId2);
    try {
      console.log("[createMatchingRequest] Sending notification to receiver:", payload.receiverId);
      const senderInfo = await queryFirst(
        env2.DB,
        "SELECT english_name, name, profile_image FROM users WHERE user_id = ? LIMIT 1",
        [payload.senderId]
      );
      const senderName = senderInfo?.english_name || senderInfo?.name || "\uC775\uBA85\uC758 \uC0AC\uC6A9\uC790";
      await createNotification(env2, {
        userId: payload.receiverId,
        type: "MATCHING_REQUEST",
        title: "\uC0C8\uB85C\uC6B4 \uB9E4\uCE6D \uC694\uCCAD",
        content: `${senderName}\uB2D8\uC774 \uB9E4\uCE6D\uC744 \uC694\uCCAD\uD588\uC2B5\uB2C8\uB2E4.`,
        category: "matching",
        priority: 2,
        actionUrl: `/matching/requests/received`,
        actionData: {
          requestId: requestId2,
          senderId: payload.senderId,
          senderName
        },
        senderUserId: payload.senderId
      });
      console.log("[createMatchingRequest] Notification sent successfully");
    } catch (notificationError) {
      console.error("[createMatchingRequest] Failed to send notification:", {
        error: notificationError instanceof Error ? notificationError.message : String(notificationError),
        stack: notificationError instanceof Error ? notificationError.stack : void 0,
        receiverId: payload.receiverId
      });
    }
    return { requestId: requestId2 };
  } catch (error48) {
    console.error("[createMatchingRequest] Error occurred:", {
      error: error48 instanceof Error ? error48.message : String(error48),
      stack: error48 instanceof Error ? error48.stack : void 0,
      name: error48 instanceof Error ? error48.constructor.name : typeof error48,
      payload: {
        senderId: payload.senderId,
        receiverId: payload.receiverId
      }
    });
    if (error48 instanceof AppError) {
      throw error48;
    }
    throw new AppError(
      error48 instanceof Error ? error48.message : "\uB9E4\uCE6D \uC694\uCCAD \uC0DD\uC131 \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.",
      500,
      "MATCHING_REQUEST_CREATE_FAILED"
    );
  }
}
__name(createMatchingRequest, "createMatchingRequest");
async function listSentRequests(env2, userId, page, size) {
  return listRequests(env2, { userId, page, size, mode: "sent" });
}
__name(listSentRequests, "listSentRequests");
async function listReceivedRequests(env2, userId, page, size) {
  return listRequests(env2, { userId, page, size, mode: "received" });
}
__name(listReceivedRequests, "listReceivedRequests");
async function listRequests(env2, options) {
  const column = options.mode === "sent" ? "sender_id" : "receiver_id";
  const partnerColumn = options.mode === "sent" ? "receiver_id" : "sender_id";
  const totalRow = await queryFirst(
    env2.DB,
    `SELECT COUNT(*) as count FROM matching_requests WHERE ${column} = ?`,
    [options.userId]
  );
  const total = totalRow?.count ?? 0;
  const offset = (options.page - 1) * options.size;
  const rows = await query(
    env2.DB,
    `SELECT
        mr.request_id,
        mr.sender_id,
        mr.receiver_id,
        mr.message,
        mr.status,
        mr.response_message,
        mr.responded_at,
        mr.expires_at,
        mr.created_at,
        partner.user_id AS partner_id,
        partner.name AS partner_name,
        partner.profile_image AS partner_profile_image
      FROM matching_requests mr
      JOIN users partner ON partner.user_id = mr.${partnerColumn}
      WHERE mr.${column} = ?
      ORDER BY mr.created_at DESC
      LIMIT ? OFFSET ?
    `,
    [options.userId, options.size, offset]
  );
  const data = rows.map((row) => ({
    requestId: row.request_id,
    senderId: row.sender_id,
    receiverId: row.receiver_id,
    message: row.message ?? void 0,
    status: row.status,
    responseMessage: row.response_message ?? void 0,
    respondedAt: row.responded_at ?? void 0,
    expiresAt: row.expires_at ?? void 0,
    createdAt: row.created_at,
    partner: {
      userId: row.partner_id,
      name: row.partner_name ?? void 0,
      profileImageUrl: row.partner_profile_image ? `/api/v1/upload/file/${row.partner_profile_image}` : void 0
    }
  }));
  return {
    data,
    page: options.page,
    size: options.size,
    total
  };
}
__name(listRequests, "listRequests");
async function acceptMatchingRequest(env2, options) {
  const request = await queryFirst(
    env2.DB,
    "SELECT request_id, sender_id, receiver_id, status FROM matching_requests WHERE request_id = ? LIMIT 1",
    [options.requestId]
  );
  if (!request) {
    throw new Error("\uB9E4\uCE6D \uC694\uCCAD\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  if (request.receiver_id !== options.receiverId) {
    throw new Error("\uB2E4\uB978 \uC0AC\uC6A9\uC790\uC758 \uC694\uCCAD\uC785\uB2C8\uB2E4.");
  }
  if (request.status !== MATCHING_STATUS.PENDING) {
    throw new Error("\uC774\uBBF8 \uCC98\uB9AC\uB41C \uC694\uCCAD\uC785\uB2C8\uB2E4.");
  }
  const now = nowIso4();
  const [user1, user2] = normalizePair(request.sender_id, request.receiver_id);
  await transaction(env2.DB, [
    {
      sql: `UPDATE matching_requests
              SET status = ?, response_message = ?, responded_at = ?, updated_at = ?
            WHERE request_id = ?`,
      params: [
        MATCHING_STATUS.ACCEPTED,
        options.responseMessage ?? null,
        now,
        now,
        options.requestId
      ]
    },
    {
      sql: `INSERT INTO user_matches (
                match_id, user1_id, user2_id, matched_at, is_active, created_at, updated_at
            ) VALUES (?, ?, ?, ?, 1, ?, ?)
            ON CONFLICT(user1_id, user2_id) DO UPDATE SET
              is_active = 1,
              matched_at = excluded.matched_at,
              deactivated_at = NULL,
              deactivated_by = NULL,
              updated_at = excluded.updated_at`,
      params: [crypto.randomUUID(), user1, user2, now, now, now]
    }
  ]);
  try {
    console.log("[acceptMatchingRequest] Sending acceptance notification to sender:", request.sender_id);
    const receiverInfo = await queryFirst(
      env2.DB,
      "SELECT english_name, name FROM users WHERE user_id = ? LIMIT 1",
      [request.receiver_id]
    );
    const receiverName = receiverInfo?.english_name || receiverInfo?.name || "\uC775\uBA85\uC758 \uC0AC\uC6A9\uC790";
    await createNotification(env2, {
      userId: request.sender_id,
      type: "MATCHING_ACCEPTED",
      title: "\uB9E4\uCE6D \uC218\uB77D",
      content: `${receiverName}\uB2D8\uC774 \uB9E4\uCE6D\uC744 \uC218\uB77D\uD588\uC2B5\uB2C8\uB2E4. \uC774\uC81C \uCC44\uD305\uC744 \uC2DC\uC791\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4!`,
      category: "matching",
      priority: 2,
      actionUrl: `/chat`,
      actionData: {
        requestId: options.requestId,
        partnerId: request.receiver_id,
        partnerName: receiverName
      },
      senderUserId: request.receiver_id
    });
    console.log("[acceptMatchingRequest] Acceptance notification sent successfully");
  } catch (notificationError) {
    console.error("[acceptMatchingRequest] Failed to send acceptance notification:", {
      error: notificationError instanceof Error ? notificationError.message : String(notificationError),
      senderId: request.sender_id
    });
  }
}
__name(acceptMatchingRequest, "acceptMatchingRequest");
async function rejectMatchingRequest(env2, options) {
  const request = await queryFirst(
    env2.DB,
    "SELECT sender_id, receiver_id, status FROM matching_requests WHERE request_id = ? LIMIT 1",
    [options.requestId]
  );
  if (!request) {
    throw new Error("\uB9E4\uCE6D \uC694\uCCAD\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  if (request.receiver_id !== options.receiverId) {
    throw new Error("\uB2E4\uB978 \uC0AC\uC6A9\uC790\uC758 \uC694\uCCAD\uC785\uB2C8\uB2E4.");
  }
  if (request.status !== MATCHING_STATUS.PENDING) {
    throw new Error("\uC774\uBBF8 \uCC98\uB9AC\uB41C \uC694\uCCAD\uC785\uB2C8\uB2E4.");
  }
  const now = nowIso4();
  await execute(
    env2.DB,
    `UPDATE matching_requests
       SET status = ?, response_message = ?, responded_at = ?, updated_at = ?
       WHERE request_id = ?`,
    [MATCHING_STATUS.REJECTED, options.responseMessage ?? null, now, now, options.requestId]
  );
  try {
    console.log("[rejectMatchingRequest] Sending rejection notification to sender:", request.sender_id);
    const receiverInfo = await queryFirst(
      env2.DB,
      "SELECT english_name, name FROM users WHERE user_id = ? LIMIT 1",
      [request.receiver_id]
    );
    const receiverName = receiverInfo?.english_name || receiverInfo?.name || "\uC775\uBA85\uC758 \uC0AC\uC6A9\uC790";
    await createNotification(env2, {
      userId: request.sender_id,
      type: "MATCHING_REJECTED",
      title: "\uB9E4\uCE6D \uAC70\uC808",
      content: `${receiverName}\uB2D8\uC774 \uB9E4\uCE6D\uC744 \uAC70\uC808\uD588\uC2B5\uB2C8\uB2E4.`,
      category: "matching",
      priority: 1,
      actionUrl: `/matching`,
      actionData: {
        requestId: options.requestId,
        partnerId: request.receiver_id,
        partnerName: receiverName
      },
      senderUserId: request.receiver_id
    });
    console.log("[rejectMatchingRequest] Rejection notification sent successfully");
  } catch (notificationError) {
    console.error("[rejectMatchingRequest] Failed to send rejection notification:", {
      error: notificationError instanceof Error ? notificationError.message : String(notificationError),
      senderId: request.sender_id
    });
  }
}
__name(rejectMatchingRequest, "rejectMatchingRequest");
async function listMatches(env2, userId, page, size) {
  const totalRow = await queryFirst(
    env2.DB,
    "SELECT COUNT(*) as count FROM user_matches WHERE is_active = 1 AND (user1_id = ? OR user2_id = ?)",
    [userId, userId]
  );
  const total = totalRow?.count ?? 0;
  const offset = (page - 1) * size;
  const rows = await query(
    env2.DB,
    `SELECT
        um.match_id,
        um.user1_id,
        um.user2_id,
        um.matched_at,
        CASE WHEN um.user1_id = ? THEN um.user2_id ELSE um.user1_id END AS partner_id,
        p.name AS partner_name,
        p.profile_image AS partner_profile_image
      FROM user_matches um
      JOIN users p ON p.user_id = CASE WHEN um.user1_id = ? THEN um.user2_id ELSE um.user1_id END
      WHERE um.is_active = 1 AND (um.user1_id = ? OR um.user2_id = ?)
      ORDER BY um.matched_at DESC
      LIMIT ? OFFSET ?
    `,
    [userId, userId, userId, userId, size, offset]
  );
  const data = rows.map((row) => ({
    matchId: row.match_id,
    partnerId: row.partner_id,
    partnerName: row.partner_name ?? void 0,
    partnerProfileImageUrl: row.partner_profile_image ? `/api/v1/upload/file/${row.partner_profile_image}` : void 0,
    matchedAt: row.matched_at
  }));
  return {
    data,
    page,
    size,
    total
  };
}
__name(listMatches, "listMatches");
async function removeMatch(env2, options) {
  const match = await queryFirst(
    env2.DB,
    "SELECT match_id, user1_id, user2_id, is_active FROM user_matches WHERE match_id = ? LIMIT 1",
    [options.matchId]
  );
  if (!match) {
    throw new Error("\uB9E4\uCE6D \uC815\uBCF4\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  if (match.is_active !== 1) {
    return;
  }
  if (match.user1_id !== options.userId && match.user2_id !== options.userId) {
    throw new Error("\uD574\uB2F9 \uB9E4\uCE6D\uC5D0 \uB300\uD55C \uAD8C\uD55C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.");
  }
  const now = nowIso4();
  await execute(
    env2.DB,
    `UPDATE user_matches
       SET is_active = 0,
           deactivated_at = ?,
           deactivated_by = ?,
           updated_at = ?
       WHERE match_id = ?`,
    [now, options.userId, now, options.matchId]
  );
}
__name(removeMatch, "removeMatch");
async function getMatchingQueueStatus(env2, userId) {
  return queryFirst(
    env2.DB,
    "SELECT queue_id, session_type, queue_status, priority_score, joined_at, estimated_wait_minutes FROM matching_queue WHERE user_id = ? ORDER BY created_at DESC LIMIT 1",
    [userId]
  );
}
__name(getMatchingQueueStatus, "getMatchingQueueStatus");
async function addToMatchingQueue(env2, userId, sessionType) {
  const now = nowIso4();
  await transaction(env2.DB, [
    { sql: "DELETE FROM matching_queue WHERE user_id = ?", params: [userId] },
    {
      sql: `INSERT INTO matching_queue (
              user_id, session_type, queue_status, priority_score,
              joined_at, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
      params: [userId, sessionType, "WAITING", 0, now, now, now]
    }
  ]);
}
__name(addToMatchingQueue, "addToMatchingQueue");
async function removeFromMatchingQueue(env2, userId) {
  await execute(env2.DB, "DELETE FROM matching_queue WHERE user_id = ?", [userId]);
}
__name(removeFromMatchingQueue, "removeFromMatchingQueue");
async function recordFeedback(env2, options) {
  const now = nowIso4();
  await execute(
    env2.DB,
    `INSERT INTO matching_feedback (
        reviewer_id, partner_id, match_id, overall_rating,
        written_feedback, would_match_again, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
    [
      options.reviewerId,
      options.partnerId,
      options.matchId,
      options.overallRating,
      options.writtenFeedback ?? null,
      options.wouldMatchAgain ? 1 : 0,
      now,
      now
    ]
  );
}
__name(recordFeedback, "recordFeedback");
async function loadCompatibilityProfile(env2, userId) {
  const userRow = await queryFirst(
    env2.DB,
    `SELECT u.user_id,
            u.native_lang_id,
            lang.language_code,
            lang.language_name
       FROM users u
       LEFT JOIN languages lang ON lang.language_id = u.native_lang_id
      WHERE u.user_id = ?
      LIMIT 1`,
    [userId]
  );
  if (!userRow) {
    throw new AppError("\uC0AC\uC6A9\uC790\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.", 404, "MATCHING_USER_NOT_FOUND");
  }
  const languageRows = await query(
    env2.DB,
    `SELECT
        oll.language_id,
        lang.language_code,
        lang.language_name,
        curr.level_order AS current_level_order,
        target.level_order AS target_level_order
      FROM onboarding_lang_level oll
      LEFT JOIN languages lang ON lang.language_id = oll.language_id
      LEFT JOIN lang_level_type curr ON curr.lang_level_id = oll.current_level_id
      LEFT JOIN lang_level_type target ON target.lang_level_id = oll.target_level_id
     WHERE oll.user_id = ?`,
    [userId]
  );
  const targetLanguages = languageRows.map((row) => ({
    languageId: row.language_id ?? void 0,
    languageCode: row.language_code ?? void 0,
    languageName: row.language_name ?? void 0,
    currentLevelOrder: row.current_level_order,
    targetLevelOrder: row.target_level_order
  }));
  const personalityMap = await loadPartnerPersonalities(env2, [userId]);
  const interestsMap = await loadInterests(env2, [userId]);
  const studyGoalRows = await query(
    env2.DB,
    `SELECT m.motivation_name
       FROM onboarding_study_goal osg
       JOIN motivation m ON m.motivation_id = osg.motivation_id
      WHERE osg.user_id = ?`,
    [userId]
  );
  return {
    userId: userRow.user_id,
    nativeLanguageId: userRow.native_lang_id ?? void 0,
    nativeLanguageCode: userRow.language_code ?? void 0,
    nativeLanguageName: userRow.language_name ?? void 0,
    targetLanguages,
    personalities: personalityMap.get(userId) ?? [],
    studyGoals: studyGoalRows.map((row) => row.motivation_name).filter((name) => Boolean(name)),
    interests: interestsMap.get(userId) ?? []
  };
}
__name(loadCompatibilityProfile, "loadCompatibilityProfile");
function intersectStrings(a, b) {
  const setB = new Set(b.map((value) => value.toLowerCase()));
  const seen = /* @__PURE__ */ new Set();
  const result = [];
  for (const value of a) {
    const key = value.toLowerCase();
    if (!seen.has(key) && setB.has(key)) {
      seen.add(key);
      result.push(value);
    }
  }
  return result;
}
__name(intersectStrings, "intersectStrings");
function computeLanguageCompatibility(current, partner) {
  const descriptionParts = [];
  const mutualExchangeLanguages = [];
  let score = 0;
  if (current.nativeLanguageId) {
    const partnerTargets2 = partner.targetLanguages.filter(
      (lang) => lang.languageId === current.nativeLanguageId
    );
    if (partnerTargets2.length > 0) {
      const label = current.nativeLanguageName ?? current.nativeLanguageCode ?? "native language";
      mutualExchangeLanguages.push(label);
      score += 40;
      descriptionParts.push("\uC0C1\uB300\uAC00 \uB0B4 \uBAA8\uAD6D\uC5B4\uB97C \uD559\uC2B5 \uC911\uC785\uB2C8\uB2E4.");
    }
  }
  if (partner.nativeLanguageId) {
    const userTargets = current.targetLanguages.filter(
      (lang) => lang.languageId === partner.nativeLanguageId
    );
    if (userTargets.length > 0) {
      const label = partner.nativeLanguageName ?? partner.nativeLanguageCode ?? "partner language";
      mutualExchangeLanguages.push(label);
      score += 40;
      descriptionParts.push("\uB0B4\uAC00 \uC0C1\uB300\uC758 \uBAA8\uAD6D\uC5B4\uB97C \uD559\uC2B5\uD558\uACE0 \uC788\uC2B5\uB2C8\uB2E4.");
    }
  }
  const currentTargets = current.targetLanguages.map((lang) => lang.languageCode ?? lang.languageName ?? String(lang.languageId ?? "")).filter((value) => value.length > 0);
  const partnerTargets = partner.targetLanguages.map((lang) => lang.languageCode ?? lang.languageName ?? String(lang.languageId ?? "")).filter((value) => value.length > 0);
  const sharedTargetLanguages = intersectStrings(currentTargets, partnerTargets);
  if (sharedTargetLanguages.length > 0) {
    score += 15;
    descriptionParts.push("\uAC19\uC740 \uBAA9\uD45C \uC5B8\uC5B4\uB97C \uD568\uAED8 \uD559\uC2B5\uD558\uACE0 \uC788\uC2B5\uB2C8\uB2E4.");
  }
  let levelBonus = 0;
  if (sharedTargetLanguages.length > 0) {
    const averages = sharedTargetLanguages.map((code) => {
      const normalized = code.toLowerCase();
      const currentLanguage = current.targetLanguages.find((lang) => {
        const candidate = lang.languageCode ?? lang.languageName ?? "";
        return candidate.toLowerCase() === normalized;
      });
      const partnerLanguage = partner.targetLanguages.find((lang) => {
        const candidate = lang.languageCode ?? lang.languageName ?? "";
        return candidate.toLowerCase() === normalized;
      });
      const currentLevel = currentLanguage?.targetLevelOrder ?? currentLanguage?.currentLevelOrder;
      const partnerLevel = partnerLanguage?.targetLevelOrder ?? partnerLanguage?.currentLevelOrder;
      if (currentLevel != null && partnerLevel != null) {
        const diff = Math.abs(currentLevel - partnerLevel);
        if (diff <= 1) return 12;
        if (diff <= 2) return 8;
        return 5;
      }
      return 5;
    });
    if (averages.length > 0) {
      levelBonus = Math.min(15, averages.reduce((sum, value) => sum + value, 0) / averages.length);
      if (levelBonus >= 10) {
        descriptionParts.push("\uC5B8\uC5B4 \uB808\uBCA8\uC774 \uBE44\uC2B7\uD574 \uB300\uD654\uAC00 \uC218\uC6D4\uD569\uB2C8\uB2E4.");
      }
    }
  }
  score += levelBonus;
  if (score === 0) {
    if (current.targetLanguages.length === 0 || partner.targetLanguages.length === 0) {
      score = 50;
      descriptionParts.push("\uC5B8\uC5B4 \uD559\uC2B5 \uC815\uBCF4\uAC00 \uBD80\uC871\uD558\uC5EC \uAE30\uBCF8 \uC810\uC218\uB97C \uC801\uC6A9\uD588\uC2B5\uB2C8\uB2E4.");
    } else {
      score = 30;
      descriptionParts.push("\uC5B8\uC5B4 \uD559\uC2B5 \uBC29\uD5A5\uC774 \uBD80\uBD84\uC801\uC73C\uB85C\uB9CC \uACB9\uCE69\uB2C8\uB2E4.");
    }
  }
  return {
    score: Math.min(100, Math.round(score * 10) / 10),
    description: descriptionParts.join(" "),
    mutualExchangeLanguages: Array.from(new Set(mutualExchangeLanguages)),
    sharedTargetLanguages: Array.from(new Set(sharedTargetLanguages))
  };
}
__name(computeLanguageCompatibility, "computeLanguageCompatibility");
function hasComplementaryTrait(traitsA, traitsB, pair) {
  const [first, second] = pair;
  const aHasFirst = traitsA.has(first);
  const aHasSecond = traitsA.has(second);
  const bHasFirst = traitsB.has(first);
  const bHasSecond = traitsB.has(second);
  return aHasFirst && bHasSecond || aHasSecond && bHasFirst;
}
__name(hasComplementaryTrait, "hasComplementaryTrait");
function computePersonalityCompatibility(current, partner) {
  const traitsA = new Set(current.personalities.map((trait) => trait.toUpperCase()));
  const traitsB = new Set(partner.personalities.map((trait) => trait.toUpperCase()));
  if (traitsA.size === 0 || traitsB.size === 0) {
    return {
      score: 50,
      description: "\uC131\uACA9 \uB370\uC774\uD130\uAC00 \uCDA9\uBD84\uD558\uC9C0 \uC54A\uC544 \uAE30\uBCF8 \uC810\uC218\uB97C \uC801\uC6A9\uD588\uC2B5\uB2C8\uB2E4.",
      overlap: []
    };
  }
  const commonTraits = Array.from(traitsA).filter((trait) => traitsB.has(trait));
  let score = commonTraits.length * 20;
  const complementaryPairs = [
    ["INTROVERT", "EXTROVERT"],
    ["LEADER", "SUPPORTER"],
    ["PLANNER", "ADVENTURER"],
    ["ANALYTICAL", "CREATIVE"]
  ];
  let complementaryScore = 0;
  for (const pair of complementaryPairs) {
    if (hasComplementaryTrait(traitsA, traitsB, pair)) {
      complementaryScore += 15;
    }
  }
  score += complementaryScore;
  if (score === 0) {
    score = 45;
  }
  return {
    score: Math.min(100, Math.round(score * 10) / 10),
    description: commonTraits.length > 0 ? "\uC131\uACA9 \uC720\uD615\uC774 \uC798 \uB9DE\uC73C\uBA70 \uBCF4\uC644 \uAD00\uACC4\uB3C4 \uAE30\uB300\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4." : complementaryScore > 0 ? "\uC11C\uB85C\uC758 \uC131\uACA9\uC774 \uBCF4\uC644\uC801\uC778 \uC870\uD569\uC785\uB2C8\uB2E4." : "\uC131\uACA9 \uC870\uD569 \uB370\uC774\uD130\uAC00 \uC81C\uD55C\uC801\uC785\uB2C8\uB2E4.",
    overlap: commonTraits
  };
}
__name(computePersonalityCompatibility, "computePersonalityCompatibility");
function computeGoalCompatibility(current, partner) {
  if (current.studyGoals.length === 0 || partner.studyGoals.length === 0) {
    return {
      score: 50,
      description: "\uD559\uC2B5 \uBAA9\uD45C \uB370\uC774\uD130\uAC00 \uBD80\uC871\uD558\uC5EC \uAE30\uBCF8 \uC810\uC218\uB97C \uC801\uC6A9\uD588\uC2B5\uB2C8\uB2E4.",
      sharedGoals: []
    };
  }
  const sharedGoals = intersectStrings(current.studyGoals, partner.studyGoals);
  let score = sharedGoals.length * 25;
  const normalizedCurrent = current.studyGoals.map((goal) => goal.toUpperCase());
  const normalizedPartner = partner.studyGoals.map((goal) => goal.toUpperCase());
  const currentSet = new Set(normalizedCurrent);
  const partnerSet = new Set(normalizedPartner);
  const complementaryPairs = [
    ["BUSINESS", "CASUAL"],
    ["ACADEMIC", "PRACTICAL"],
    ["TEST_PREP", "CONVERSATION"]
  ];
  for (const [a, b] of complementaryPairs) {
    if (currentSet.has(a) && partnerSet.has(b) || currentSet.has(b) && partnerSet.has(a)) {
      score += 20;
      break;
    }
  }
  if (score === 0) {
    score = 45;
  }
  return {
    score: Math.min(100, Math.round(score * 10) / 10),
    description: sharedGoals.length > 0 ? "\uACF5\uD1B5 \uD559\uC2B5 \uBAA9\uD45C\uAC00 \uC788\uC5B4 \uD559\uC2B5 \uBC29\uD5A5\uC774 \uC720\uC0AC\uD569\uB2C8\uB2E4." : "\uD559\uC2B5 \uBAA9\uD45C\uAC00 \uBCF4\uC644\uC801\uC774\uC5B4\uC11C \uC11C\uB85C \uC2DC\uB108\uC9C0\uB97C \uB0BC \uC218 \uC788\uC2B5\uB2C8\uB2E4.",
    sharedGoals
  };
}
__name(computeGoalCompatibility, "computeGoalCompatibility");
function computeInterestCompatibility(current, partner) {
  if (current.interests.length === 0 || partner.interests.length === 0) {
    return {
      score: 50,
      description: "\uAD00\uC2EC\uC0AC \uB370\uC774\uD130\uAC00 \uBD80\uC871\uD558\uC5EC \uAE30\uBCF8 \uC810\uC218\uB97C \uC801\uC6A9\uD588\uC2B5\uB2C8\uB2E4.",
      sharedInterests: []
    };
  }
  const sharedInterests = intersectStrings(current.interests, partner.interests);
  const totalUnique = (/* @__PURE__ */ new Set(
    [...current.interests.map((i) => i.toLowerCase()), ...partner.interests.map((i) => i.toLowerCase())]
  )).size;
  const ratio = totalUnique > 0 ? sharedInterests.length * 2 / totalUnique : 0;
  const score = Math.round(Math.min(100, ratio * 1e3)) / 10;
  return {
    score,
    description: sharedInterests.length > 0 ? "\uACF5\uD1B5 \uAD00\uC2EC\uC0AC\uAC00 \uC788\uC5B4 \uC790\uC5F0\uC2A4\uB7FD\uAC8C \uB300\uD654\uB97C \uC774\uC5B4\uAC08 \uC218 \uC788\uC2B5\uB2C8\uB2E4." : "\uAD00\uC2EC\uC0AC\uAC00 \uB2E4\uC591\uD558\uAC8C \uBD84\uD3EC\uD574 \uC788\uC5B4 \uC0C8\uB85C\uC6B4 \uC8FC\uC81C\uB97C \uACF5\uC720\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.",
    sharedInterests
  };
}
__name(computeInterestCompatibility, "computeInterestCompatibility");
function determineCompatibilityLevel(score) {
  if (score >= 80) return "HIGH";
  if (score >= 60) return "MEDIUM";
  return "LOW";
}
__name(determineCompatibilityLevel, "determineCompatibilityLevel");
function createRecommendation(score, categoryScores) {
  let message = "";
  if (score >= 80) {
    message = "\uB9E4\uC6B0 \uC88B\uC740 \uB9E4\uCE6D\uC785\uB2C8\uB2E4! ";
  } else if (score >= 60) {
    message = "\uAD1C\uCC2E\uC740 \uB9E4\uCE6D\uC785\uB2C8\uB2E4. ";
  } else {
    message = "\uD638\uD658\uC131\uC774 \uB0AE\uC744 \uC218 \uC788\uC2B5\uB2C8\uB2E4. ";
  }
  const bestCategory = Object.entries(categoryScores).sort((a, b) => b[1] - a[1]).map(([category]) => category)[0];
  switch (bestCategory) {
    case "language":
      message += "\uC5B8\uC5B4 \uAD50\uD658\uC5D0 \uCD5C\uC801\uD654\uB41C \uD30C\uD2B8\uB108\uC785\uB2C8\uB2E4.";
      break;
    case "personality":
      message += "\uC131\uACA9\uC774 \uC798 \uB9DE\uB294 \uD30C\uD2B8\uB108\uC785\uB2C8\uB2E4.";
      break;
    case "goals":
      message += "\uD559\uC2B5 \uBAA9\uD45C\uAC00 \uBE44\uC2B7\uD55C \uD30C\uD2B8\uB108\uC785\uB2C8\uB2E4.";
      break;
    case "interests":
      message += "\uACF5\uD1B5 \uAD00\uC2EC\uC0AC\uAC00 \uB9CE\uC740 \uD30C\uD2B8\uB108\uC785\uB2C8\uB2E4.";
      break;
    default:
      message += "\uD568\uAED8 \uD559\uC2B5\uD558\uBA70 \uC2DC\uB108\uC9C0\uB97C \uD655\uC778\uD574\uBCF4\uC138\uC694!";
  }
  return message;
}
__name(createRecommendation, "createRecommendation");
async function calculateCompatibilityAnalysis(env2, currentUserId, partnerId) {
  if (currentUserId === partnerId) {
    throw new AppError("\uC790\uC2E0\uACFC\uC758 \uD638\uD658\uC131\uC740 \uBD84\uC11D\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.", 400, "MATCHING_SELF_COMPATIBILITY");
  }
  const [currentProfile, partnerProfile] = await Promise.all([
    loadCompatibilityProfile(env2, currentUserId),
    loadCompatibilityProfile(env2, partnerId)
  ]);
  const language = computeLanguageCompatibility(currentProfile, partnerProfile);
  const personality = computePersonalityCompatibility(currentProfile, partnerProfile);
  const goals = computeGoalCompatibility(currentProfile, partnerProfile);
  const interests = computeInterestCompatibility(currentProfile, partnerProfile);
  const overallScore = Math.round(
    (language.score * 0.3 + personality.score * 0.25 + goals.score * 0.25 + interests.score * 0.2) * 10
  ) / 10;
  const categoryScores = {
    language: language.score,
    personality: personality.score,
    goals: goals.score,
    interests: interests.score
  };
  const categoryDetails = [
    { category: "language", score: language.score, description: language.description },
    { category: "personality", score: personality.score, description: personality.description },
    { category: "goals", score: goals.score, description: goals.description },
    { category: "interests", score: interests.score, description: interests.description }
  ];
  const sharedInsights = {
    mutualExchangeLanguages: language.mutualExchangeLanguages,
    sharedTargetLanguages: language.sharedTargetLanguages,
    sharedInterests: interests.sharedInterests,
    sharedGoals: goals.sharedGoals,
    personalityOverlap: personality.overlap
  };
  return {
    overallScore,
    compatibilityLevel: determineCompatibilityLevel(overallScore),
    recommendation: createRecommendation(overallScore, categoryScores),
    categoryScores,
    categoryDetails,
    sharedInsights
  };
}
__name(calculateCompatibilityAnalysis, "calculateCompatibilityAnalysis");

// src/services/aiMatching.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_db();
var CEFR_LEVELS = ["A1", "A2", "B1", "B2", "C1", "C2"];
function getCEFRLevelIndex(level) {
  const idx = CEFR_LEVELS.indexOf(level.toUpperCase());
  return idx === -1 ? 0 : idx;
}
__name(getCEFRLevelIndex, "getCEFRLevelIndex");
function cosineSimilarity(a, b) {
  if (a.length !== b.length || a.length === 0) return 0;
  let dotProduct = 0;
  let normA = 0;
  let normB = 0;
  for (let i = 0; i < a.length; i++) {
    dotProduct += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }
  if (normA === 0 || normB === 0) return 0;
  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
}
__name(cosineSimilarity, "cosineSimilarity");
function calculateLanguageCompatibility(user, candidate) {
  const userNative = user.nativeLanguageCode || user.nativeLanguage;
  const candidateNative = candidate.nativeLanguageCode || candidate.nativeLanguage;
  const userTargetCodes = user.targetLanguages.map((t) => t.languageCode || t.language);
  const candidateTargetCodes = candidate.targetLanguages.map((t) => t.languageCode || t.language);
  const userTeachesCandidateLearns = candidateTargetCodes.includes(userNative);
  const candidateTeachesUserLearns = userTargetCodes.includes(candidateNative);
  if (userTeachesCandidateLearns && candidateTeachesUserLearns) {
    return 100;
  } else if (userTeachesCandidateLearns || candidateTeachesUserLearns) {
    return 60;
  } else {
    const overlap = userTargetCodes.filter((lang) => candidateTargetCodes.includes(lang));
    return overlap.length > 0 ? 40 : 0;
  }
}
__name(calculateLanguageCompatibility, "calculateLanguageCompatibility");
function calculateLevelCompatibility(user, candidate) {
  if (user.targetLanguages.length === 0 || candidate.targetLanguages.length === 0) {
    return 50;
  }
  const userTargets = user.targetLanguages;
  const candidateTargets = candidate.targetLanguages;
  let totalScore = 0;
  let count3 = 0;
  for (const userTarget of userTargets) {
    for (const candidateTarget of candidateTargets) {
      if (userTarget.languageCode === candidateTarget.languageCode || userTarget.language === candidateTarget.language) {
        const userLevel = getCEFRLevelIndex(userTarget.currentLevel);
        const candidateLevel = getCEFRLevelIndex(candidateTarget.currentLevel);
        const diff = Math.abs(userLevel - candidateLevel);
        const score = Math.max(0, 100 - diff * 20);
        totalScore += score;
        count3++;
      }
    }
  }
  return count3 > 0 ? totalScore / count3 : 50;
}
__name(calculateLevelCompatibility, "calculateLevelCompatibility");
function calculateScheduleCompatibility(user, candidate) {
  if (!user.dailyMinute && !candidate.dailyMinute) {
    return 50;
  }
  if (user.dailyMinute === candidate.dailyMinute) {
    return 100;
  }
  return user.dailyMinute && candidate.dailyMinute ? 60 : 30;
}
__name(calculateScheduleCompatibility, "calculateScheduleCompatibility");
function calculateGoalAlignment(user, candidate) {
  if (user.studyGoals.length === 0 || candidate.studyGoals.length === 0) {
    return 50;
  }
  const overlap = user.studyGoals.filter(
    (goal) => candidate.studyGoals.includes(goal)
  );
  const maxLength = Math.max(user.studyGoals.length, candidate.studyGoals.length);
  return overlap.length / maxLength * 100;
}
__name(calculateGoalAlignment, "calculateGoalAlignment");
function calculatePersonalityMatch(user, candidate) {
  if (user.personalities.length === 0 || candidate.personalities.length === 0) {
    return 50;
  }
  const overlap = user.personalities.filter(
    (trait) => candidate.personalities.includes(trait)
  );
  const maxLength = Math.max(user.personalities.length, candidate.personalities.length);
  return overlap.length / maxLength * 100;
}
__name(calculatePersonalityMatch, "calculatePersonalityMatch");
function calculateTopicOverlap(user, candidate) {
  if (user.interests.length === 0 || candidate.interests.length === 0) {
    return 50;
  }
  const overlap = user.interests.filter(
    (interest) => candidate.interests.includes(interest)
  );
  const maxLength = Math.max(user.interests.length, candidate.interests.length);
  return overlap.length / maxLength * 100;
}
__name(calculateTopicOverlap, "calculateTopicOverlap");
async function convertToExtendedProfile(env2, profile3) {
  const userId = "id" in profile3 ? profile3.id : profile3.userId;
  const targetLangs = await query(
    env2.DB,
    `SELECT
      l.language_id,
      l.language_code,
      l.language_name,
      curr.lang_level_name as current_level_name,
      tgt.lang_level_name as target_level_name
    FROM onboarding_lang_level oll
    JOIN languages l ON l.language_id = oll.language_id
    LEFT JOIN lang_level_type curr ON curr.lang_level_id = oll.current_level_id
    LEFT JOIN lang_level_type tgt ON tgt.lang_level_id = oll.target_level_id
    WHERE oll.user_id = ?`,
    [userId]
  );
  const goals = await query(
    env2.DB,
    `SELECT g.goal_name
    FROM onboarding_goals og
    JOIN goals g ON g.goal_id = og.goal_id
    WHERE og.user_id = ?`,
    [userId]
  );
  const interests = await query(
    env2.DB,
    `SELECT i.interest_name
    FROM onboarding_interests oi
    JOIN interests i ON i.interest_id = oi.interest_id
    WHERE oi.user_id = ?`,
    [userId]
  );
  const personalities = await query(
    env2.DB,
    `SELECT p.personality_name
    FROM onboarding_personalities op
    JOIN personalities p ON p.personality_id = op.personality_id
    WHERE op.user_id = ?`,
    [userId]
  );
  const extended = {
    userId,
    name: profile3.englishName || profile3.name || "Unknown",
    nativeLanguage: profile3.nativeLanguage?.name || "",
    nativeLanguageCode: profile3.nativeLanguage?.code,
    targetLanguages: targetLangs.map((t) => ({
      language: t.language_name,
      languageCode: t.language_code,
      currentLevel: t.current_level_name || "A1",
      targetLevel: t.target_level_name || void 0
    })),
    studyGoals: goals.map((g) => g.goal_name),
    interests: interests.map((i) => i.interest_name),
    personalities: personalities.map((p) => p.personality_name),
    bio: profile3.selfBio,
    communicationMethod: profile3.communicationMethod,
    dailyMinute: profile3.dailyMinute,
    learningExpectation: profile3.learningExpectation
  };
  if (profile3.birthyear) {
    const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    extended.age = currentYear - parseInt(profile3.birthyear);
  }
  if (profile3.gender) {
    extended.gender = profile3.gender;
  }
  if ("location" in profile3 && profile3.location) {
    extended.location = profile3.location.country + (profile3.location.city ? `, ${profile3.location.city}` : "");
  } else if ("locationCountry" in profile3 && profile3.locationCountry) {
    extended.location = profile3.locationCountry + (profile3.locationCity ? `, ${profile3.locationCity}` : "");
  }
  return extended;
}
__name(convertToExtendedProfile, "convertToExtendedProfile");
async function generateProfileEmbedding(ai, profile3) {
  const profileText = `
Name: ${profile3.name}
Native Language: ${profile3.nativeLanguage}
Learning: ${profile3.targetLanguages.map((t) => `${t.language} (${t.currentLevel})`).join(", ")}
Goals: ${profile3.studyGoals.join(", ")}
Interests: ${profile3.interests.join(", ")}
Personality: ${profile3.personalities.join(", ")}
Bio: ${profile3.bio || "N/A"}
  `.trim();
  const embedding = await generateEmbedding(ai, profileText);
  return embedding;
}
__name(generateProfileEmbedding, "generateProfileEmbedding");
async function generateMatchingReasons(ai, user, candidate, score) {
  const messages = [
    {
      role: "system",
      content: `You are a language learning matchmaking expert. Analyze two user profiles and explain why they would be good language exchange partners. Focus on:
- Language exchange compatibility
- Shared interests and goals
- Personality compatibility
- Conversation topics they could enjoy together

Respond in JSON format:
{
  "reasons": ["reason1", "reason2", "reason3"],
  "insights": "overall compatibility insight",
  "topics": ["topic1", "topic2", "topic3", "topic4", "topic5"]
}`
    },
    {
      role: "user",
      content: `User 1:
- Name: ${user.name}
- Native: ${user.nativeLanguage}, Learning: ${user.targetLanguages.map((t) => t.language).join(", ")}
- Goals: ${user.studyGoals.join(", ")}
- Interests: ${user.interests.join(", ")}
- Personality: ${user.personalities.join(", ")}

User 2:
- Name: ${candidate.name}
- Native: ${candidate.nativeLanguage}, Learning: ${candidate.targetLanguages.map((t) => t.language).join(", ")}
- Goals: ${candidate.studyGoals.join(", ")}
- Interests: ${candidate.interests.join(", ")}
- Personality: ${candidate.personalities.join(", ")}

Compatibility Score: ${score.overallScore}/100
Language Match: ${score.breakdown.languageCompatibility}/100
Level Match: ${score.breakdown.levelCompatibility}/100
Goals Alignment: ${score.breakdown.goalAlignment}/100
Topic Overlap: ${score.breakdown.topicOverlap}/100`
    }
  ];
  try {
    const response = await generateChatCompletion(ai, messages, {
      model: "@cf/meta/llama-3.3-70b-instruct-fp8-fast",
      temperature: 0.7,
      max_tokens: 800
    });
    const sanitized = sanitizeJsonResponse(response);
    const parsed = JSON.parse(sanitized);
    return {
      reasons: Array.isArray(parsed.reasons) ? parsed.reasons.slice(0, 5) : [],
      insights: typeof parsed.insights === "string" ? parsed.insights : "",
      topics: Array.isArray(parsed.topics) ? parsed.topics.slice(0, 5) : []
    };
  } catch (error48) {
    log3.error("Failed to generate matching reasons:", error48);
    return {
      reasons: ["Language exchange compatibility", "Shared learning goals"],
      insights: "Compatible language learning partners",
      topics: ["Culture", "Travel", "Daily Life"]
    };
  }
}
__name(generateMatchingReasons, "generateMatchingReasons");
async function calculateAIMatchScore(ai, user, candidate, preferences, env2) {
  const [userExtended, candidateExtended] = await Promise.all([
    convertToExtendedProfile(env2, user),
    convertToExtendedProfile(env2, candidate)
  ]);
  const languageCompatibility = calculateLanguageCompatibility(userExtended, candidateExtended);
  const levelCompatibility = calculateLevelCompatibility(userExtended, candidateExtended);
  const scheduleCompatibility = calculateScheduleCompatibility(userExtended, candidateExtended);
  const goalAlignment = calculateGoalAlignment(userExtended, candidateExtended);
  const personalityMatch = calculatePersonalityMatch(userExtended, candidateExtended);
  const topicOverlap = calculateTopicOverlap(userExtended, candidateExtended);
  let semanticSimilarity = 50;
  try {
    const [userEmbedding, candidateEmbedding] = await Promise.all([
      generateProfileEmbedding(ai, userExtended),
      generateProfileEmbedding(ai, candidateExtended)
    ]);
    const similarity = cosineSimilarity(userEmbedding, candidateEmbedding);
    semanticSimilarity = Math.round(similarity * 100);
  } catch (error48) {
    log3.error("Failed to calculate semantic similarity:", error48);
  }
  const overallScore = Math.round(
    languageCompatibility * preferences.languageWeight + levelCompatibility * preferences.levelWeight + semanticSimilarity * preferences.semanticWeight + scheduleCompatibility * preferences.scheduleWeight + goalAlignment * preferences.goalsWeight + personalityMatch * preferences.personalityWeight + topicOverlap * preferences.topicsWeight
  );
  const score = {
    userId: candidateExtended.userId,
    overallScore,
    breakdown: {
      languageCompatibility,
      levelCompatibility,
      semanticSimilarity,
      scheduleCompatibility,
      goalAlignment,
      personalityMatch,
      topicOverlap
    },
    aiReasons: [],
    suggestedTopics: [],
    compatibilityInsights: ""
  };
  const aiGenerated = await generateMatchingReasons(ai, userExtended, candidateExtended, score);
  score.aiReasons = aiGenerated.reasons;
  score.suggestedTopics = aiGenerated.topics;
  score.compatibilityInsights = aiGenerated.insights;
  return score;
}
__name(calculateAIMatchScore, "calculateAIMatchScore");
async function findBestMatches(ai, user, candidates, preferences, env2, limit = 10) {
  const scores = await Promise.all(
    candidates.map(
      (candidate) => calculateAIMatchScore(ai, user, candidate, preferences, env2)
    )
  );
  scores.sort((a, b) => b.overallScore - a.overallScore);
  return scores.slice(0, limit);
}
__name(findBestMatches, "findBestMatches");

// src/routes/matching.ts
var matchingRoutes = new Hono2();
var requireAuth8 = auth();
function getPaginationParams3(c) {
  const page = Math.max(Number(c.req.query("page") ?? "1"), 1);
  const size = Math.max(Math.min(Number(c.req.query("size") ?? "20"), 50), 1);
  return { page, size };
}
__name(getPaginationParams3, "getPaginationParams");
matchingRoutes.use("*", requireAuth8);
async function getMatchingSettings(env2, userId) {
  const key = `matching:settings:${userId}`;
  const stored = await env2.CACHE.get(key, { type: "json" });
  if (stored) {
    return stored;
  }
  return {
    autoAcceptMatches: false,
    showOnlineStatus: true,
    allowMatchRequests: true,
    preferredAgeRange: null,
    preferredGenders: [],
    preferredNationalities: [],
    preferredLanguages: [],
    maxDistance: null,
    notificationSettings: {
      matchFound: true,
      requestReceived: true
    }
  };
}
__name(getMatchingSettings, "getMatchingSettings");
matchingRoutes.get("/partners", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const { page, size } = getPaginationParams3(c);
  try {
    const result = await recommendPartners(c.env, userId, {
      nativeLanguage: c.req.query("nativeLanguage") || void 0,
      targetLanguage: c.req.query("targetLanguage") || void 0,
      languageLevel: c.req.query("languageLevel") || void 0,
      minAge: c.req.query("minAge") ? Number(c.req.query("minAge")) : void 0,
      maxAge: c.req.query("maxAge") ? Number(c.req.query("maxAge")) : void 0,
      page,
      size
    });
    return paginatedResponse(c, result.data, {
      page: result.page,
      limit: result.size,
      total: result.total
    });
  } catch (error48) {
    if (error48 instanceof AppError) throw error48;
    throw new AppError(
      error48 instanceof Error ? error48.message : "Failed to load partners",
      500,
      "MATCHING_PARTNERS_FAILED"
    );
  }
});
matchingRoutes.post("/partners/advanced", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const filters = await c.req.json().catch(() => ({}));
  const { page, size } = getPaginationParams3(c);
  try {
    const result = await recommendPartners(c.env, userId, {
      nativeLanguage: typeof filters.nativeLanguage === "string" ? filters.nativeLanguage : void 0,
      targetLanguage: typeof filters.targetLanguage === "string" ? filters.targetLanguage : void 0,
      languageLevel: typeof filters.proficiencyLevel === "string" ? filters.proficiencyLevel : void 0,
      minAge: typeof filters.minAge === "number" ? filters.minAge : void 0,
      maxAge: typeof filters.maxAge === "number" ? filters.maxAge : void 0,
      page,
      size
    });
    return paginatedResponse(c, result.data, {
      page: result.page,
      limit: result.size,
      total: result.total
    });
  } catch (error48) {
    if (error48 instanceof AppError) throw error48;
    throw new AppError(
      error48 instanceof Error ? error48.message : "Failed to search partners",
      500,
      "MATCHING_SEARCH_FAILED"
    );
  }
});
matchingRoutes.post("/request", async (c) => {
  const userId = c.get("userId");
  if (!userId) {
    console.error("[POST /matching/request] User ID not found in context");
    throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  }
  let body;
  try {
    body = await c.req.json();
  } catch (parseError) {
    console.error("[POST /matching/request] JSON parse error:", parseError);
    throw new AppError("Invalid request body", 400, "INVALID_JSON");
  }
  console.log("[POST /matching/request] Request details:", JSON.stringify({
    targetUserId: body.targetUserId,
    hasMessage: !!body.message,
    messageLength: body.message?.length,
    userId
  }));
  if (typeof body.targetUserId !== "string" || !body.targetUserId.trim()) {
    throw new AppError("targetUserId is required and must be a valid string", 400, "INVALID_PAYLOAD");
  }
  try {
    const result = await createMatchingRequest(c.env, {
      senderId: userId,
      receiverId: body.targetUserId.trim(),
      message: typeof body.message === "string" ? body.message.trim() : void 0
    });
    console.log("[POST /matching/request] Success:", {
      requestId: result.requestId,
      senderId: userId,
      receiverId: body.targetUserId
    });
    return successResponse(c, {
      success: true,
      requestId: result.requestId
    });
  } catch (error48) {
    console.error("[POST /matching/request] Error caught:", {
      errorType: error48 instanceof Error ? error48.constructor.name : typeof error48,
      errorMessage: error48 instanceof Error ? error48.message : String(error48),
      errorStack: error48 instanceof Error ? error48.stack : void 0,
      isAppError: error48 instanceof AppError,
      statusCode: error48 instanceof AppError ? error48.statusCode : void 0,
      errorCode: error48 instanceof AppError ? error48.code : void 0,
      userId,
      targetUserId: body.targetUserId
    });
    if (error48 instanceof AppError) {
      throw error48;
    }
    throw new AppError(
      error48 instanceof Error ? error48.message : "Failed to send matching request",
      500,
      "MATCHING_REQUEST_FAILED"
    );
  }
});
matchingRoutes.get("/requests/sent", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const { page, size } = getPaginationParams3(c);
  const result = await listSentRequests(c.env, userId, page, size);
  return paginatedResponse(c, result.data, {
    page: result.page,
    limit: result.size,
    total: result.total
  });
});
matchingRoutes.get("/requests/received", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const { page, size } = getPaginationParams3(c);
  const result = await listReceivedRequests(c.env, userId, page, size);
  return paginatedResponse(c, result.data, {
    page: result.page,
    limit: result.size,
    total: result.total
  });
});
matchingRoutes.post("/accept/:requestId", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const requestId2 = c.req.param("requestId");
  const body = await c.req.json().catch(() => ({}));
  try {
    await acceptMatchingRequest(c.env, {
      requestId: requestId2,
      receiverId: userId,
      responseMessage: body.responseMessage
    });
    return successResponse(c, { success: true });
  } catch (error48) {
    if (error48 instanceof AppError) throw error48;
    throw new AppError(
      error48 instanceof Error ? error48.message : "Failed to accept matching request",
      400,
      "MATCHING_ACCEPT_FAILED"
    );
  }
});
matchingRoutes.post("/reject/:requestId", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const requestId2 = c.req.param("requestId");
  const body = await c.req.json().catch(() => ({}));
  try {
    await rejectMatchingRequest(c.env, {
      requestId: requestId2,
      receiverId: userId,
      responseMessage: body.responseMessage
    });
    return successResponse(c, { success: true });
  } catch (error48) {
    if (error48 instanceof AppError) throw error48;
    throw new AppError(
      error48 instanceof Error ? error48.message : "Failed to reject matching request",
      400,
      "MATCHING_REJECT_FAILED"
    );
  }
});
matchingRoutes.get("/matches", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const { page, size } = getPaginationParams3(c);
  const result = await listMatches(c.env, userId, page, size);
  return paginatedResponse(c, result.data, {
    page: result.page,
    limit: result.size,
    total: result.total
  });
});
matchingRoutes.delete("/matches/:matchId", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const matchId = c.req.param("matchId");
  await removeMatch(c.env, { matchId, userId });
  return successResponse(c, { success: true });
});
matchingRoutes.post("/queue", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  const sessionType = typeof body.sessionType === "string" ? body.sessionType : "ANY";
  await addToMatchingQueue(c.env, userId, sessionType);
  return successResponse(c, { success: true });
});
matchingRoutes.delete("/queue", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  await removeFromMatchingQueue(c.env, userId);
  return successResponse(c, { success: true });
});
matchingRoutes.get("/queue/status", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const status = await getMatchingQueueStatus(c.env, userId);
  return successResponse(c, status ?? {});
});
matchingRoutes.get("/history", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const { page, size } = getPaginationParams3(c);
  const result = await listMatches(c.env, userId, page, size);
  return paginatedResponse(c, result.data, {
    page: result.page,
    limit: result.size,
    total: result.total
  });
});
matchingRoutes.post("/feedback", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json();
  if (typeof body.partnerId !== "string" || typeof body.matchId !== "string" || typeof body.overallRating !== "number") {
    throw new AppError("partnerId, matchId, overallRating are required", 400, "INVALID_PAYLOAD");
  }
  await recordFeedback(c.env, {
    reviewerId: userId,
    partnerId: body.partnerId,
    matchId: body.matchId,
    overallRating: body.overallRating,
    writtenFeedback: typeof body.writtenFeedback === "string" ? body.writtenFeedback : void 0,
    wouldMatchAgain: typeof body.wouldMatchAgain === "boolean" ? body.wouldMatchAgain : void 0
  });
  return successResponse(c, { success: true });
});
matchingRoutes.get("/my-matches", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const result = await listMatches(c.env, userId, 1, 50);
  return successResponse(c, result.data);
});
matchingRoutes.get("/stats", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const matches = await listMatches(c.env, userId, 1, 20);
  const queueStatus = await getMatchingQueueStatus(c.env, userId);
  const activeRequest = queueStatus?.queue_status === "WAITING";
  return successResponse(c, {
    totalMatches: matches.total,
    recentMatches: matches.data.slice(0, 5),
    activeRequest,
    queueStatus
  });
});
matchingRoutes.get("/compatibility/:partnerId", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const partnerId = c.req.param("partnerId");
  const analysis = await calculateCompatibilityAnalysis(c.env, userId, partnerId);
  return successResponse(c, {
    partnerId,
    ...analysis
  });
});
matchingRoutes.get("/settings", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const settings = await getMatchingSettings(c.env, userId);
  return successResponse(c, settings);
});
matchingRoutes.patch("/settings", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const updates = await c.req.json().catch(() => ({}));
  const current = await getMatchingSettings(c.env, userId);
  const merged = {
    ...current,
    ...updates,
    updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  await c.env.CACHE.put(`matching:settings:${userId}`, JSON.stringify(merged));
  return successResponse(c, merged);
});
matchingRoutes.post("/ai/best-matches", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  try {
    const body = await c.req.json().catch(() => ({}));
    const limit = typeof body.limit === "number" ? Math.min(body.limit, 50) : 10;
    const userProfile = await getUserProfile(c.env, userId);
    if (!userProfile) {
      throw new AppError("User profile not found", 404, "USER_NOT_FOUND");
    }
    const candidates = await recommendPartners(c.env, userId, {
      page: 1,
      size: 100
      // Get more candidates for AI to analyze
    });
    const preferences = {
      languageWeight: typeof body.languageWeight === "number" ? body.languageWeight : 0.25,
      levelWeight: typeof body.levelWeight === "number" ? body.levelWeight : 0.15,
      semanticWeight: typeof body.semanticWeight === "number" ? body.semanticWeight : 0.15,
      scheduleWeight: typeof body.scheduleWeight === "number" ? body.scheduleWeight : 0.15,
      goalsWeight: typeof body.goalsWeight === "number" ? body.goalsWeight : 0.1,
      personalityWeight: typeof body.personalityWeight === "number" ? body.personalityWeight : 0.1,
      topicsWeight: typeof body.topicsWeight === "number" ? body.topicsWeight : 0.1
    };
    const matches = await findBestMatches(
      c.env.AI,
      userProfile,
      candidates.data,
      preferences,
      c.env,
      limit
    );
    return successResponse(c, {
      matches,
      totalCandidates: candidates.total,
      analyzedCandidates: candidates.data.length
    });
  } catch (error48) {
    if (error48 instanceof AppError) {
      throw error48;
    }
    throw new AppError(
      error48 instanceof Error ? error48.message : "AI matching failed",
      500,
      "AI_MATCHING_FAILED"
    );
  }
});
matchingRoutes.post("/ai/compatibility/:partnerId", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const partnerId = c.req.param("partnerId");
  try {
    const body = await c.req.json().catch(() => ({}));
    const [userProfile, partnerProfile] = await Promise.all([
      getUserProfile(c.env, userId),
      getUserProfile(c.env, partnerId)
    ]);
    if (!userProfile || !partnerProfile) {
      throw new AppError("User or partner profile not found", 404, "PROFILE_NOT_FOUND");
    }
    const preferences = {
      languageWeight: typeof body.languageWeight === "number" ? body.languageWeight : 0.25,
      levelWeight: typeof body.levelWeight === "number" ? body.levelWeight : 0.15,
      semanticWeight: typeof body.semanticWeight === "number" ? body.semanticWeight : 0.15,
      scheduleWeight: typeof body.scheduleWeight === "number" ? body.scheduleWeight : 0.15,
      goalsWeight: typeof body.goalsWeight === "number" ? body.goalsWeight : 0.1,
      personalityWeight: typeof body.personalityWeight === "number" ? body.personalityWeight : 0.1,
      topicsWeight: typeof body.topicsWeight === "number" ? body.topicsWeight : 0.1
    };
    const compatibility = await calculateAIMatchScore(
      c.env.AI,
      userProfile,
      partnerProfile,
      preferences,
      c.env
    );
    return successResponse(c, {
      partnerId,
      compatibility
    });
  } catch (error48) {
    if (error48 instanceof AppError) {
      throw error48;
    }
    throw new AppError(
      error48 instanceof Error ? error48.message : "AI compatibility calculation failed",
      500,
      "AI_COMPATIBILITY_FAILED"
    );
  }
});
var matching_default = matchingRoutes;

// src/routes/achievements.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_errors();

// src/services/achievement.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_db();
init_errors();
var CATEGORY_ALIAS = {
  LEARNING: "STUDY",
  SKILL: "STUDY",
  SOCIAL: "SOCIAL",
  ENGAGEMENT: "ENGAGEMENT",
  TIME: "STREAK",
  MILESTONE: "MILESTONE",
  SPECIAL: "SPECIAL"
};
var DEFAULT_ACHIEVEMENTS = [
  {
    achievementKey: "first_session",
    title: "\uCCAB \uC138\uC158 \uC644\uB8CC",
    description: "\uCCAB \uBC88\uC9F8 \uD654\uC0C1 \uC138\uC158\uC744 \uC644\uB8CC\uD588\uC2B5\uB2C8\uB2E4!",
    category: "LEARNING",
    type: "COUNT",
    tier: "BRONZE",
    targetValue: 1,
    targetUnit: "\uC138\uC158",
    xpReward: 100,
    badgeColor: "#CD7F32",
    sortOrder: 1
  },
  {
    achievementKey: "session_10",
    title: "\uC138\uC158 \uB9C8\uC2A4\uD130",
    description: "10\uBC88\uC758 \uD654\uC0C1 \uC138\uC158\uC744 \uC644\uB8CC\uD588\uC2B5\uB2C8\uB2E4!",
    category: "LEARNING",
    type: "COUNT",
    tier: "SILVER",
    targetValue: 10,
    targetUnit: "\uC138\uC158",
    xpReward: 500,
    badgeColor: "#C0C0C0",
    sortOrder: 2
  },
  {
    achievementKey: "session_50",
    title: "\uC138\uC158 \uC804\uBB38\uAC00",
    description: "50\uBC88\uC758 \uD654\uC0C1 \uC138\uC158\uC744 \uC644\uB8CC\uD588\uC2B5\uB2C8\uB2E4!",
    category: "LEARNING",
    type: "COUNT",
    tier: "GOLD",
    targetValue: 50,
    targetUnit: "\uC138\uC158",
    xpReward: 2e3,
    badgeColor: "#FFD700",
    sortOrder: 3
  },
  {
    achievementKey: "streak_7",
    title: "\uC77C\uC8FC\uC77C \uC5F0\uC18D",
    description: "7\uC77C \uC5F0\uC18D\uC73C\uB85C \uC138\uC158\uC5D0 \uCC38\uC5EC\uD588\uC2B5\uB2C8\uB2E4!",
    category: "ENGAGEMENT",
    type: "STREAK",
    tier: "SILVER",
    targetValue: 7,
    targetUnit: "\uC77C",
    xpReward: 750,
    badgeColor: "#C0C0C0",
    sortOrder: 4
  },
  {
    achievementKey: "streak_30",
    title: "\uD55C \uB2EC \uC5F0\uC18D",
    description: "30\uC77C \uC5F0\uC18D\uC73C\uB85C \uC138\uC158\uC5D0 \uCC38\uC5EC\uD588\uC2B5\uB2C8\uB2E4!",
    category: "ENGAGEMENT",
    type: "STREAK",
    tier: "GOLD",
    targetValue: 30,
    targetUnit: "\uC77C",
    xpReward: 3e3,
    badgeColor: "#FFD700",
    sortOrder: 5
  },
  {
    achievementKey: "first_friend",
    title: "\uCCAB \uCE5C\uAD6C",
    description: "\uCCAB \uBC88\uC9F8 \uD559\uC2B5 \uCE5C\uAD6C\uB97C \uB9CC\uB4E4\uC5C8\uC2B5\uB2C8\uB2E4!",
    category: "SOCIAL",
    type: "COUNT",
    tier: "BRONZE",
    targetValue: 1,
    targetUnit: "\uCE5C\uAD6C",
    xpReward: 200,
    badgeColor: "#CD7F32",
    sortOrder: 6
  },
  {
    achievementKey: "friends_5",
    title: "\uC778\uAE30\uC7C1\uC774",
    description: "5\uBA85\uC758 \uD559\uC2B5 \uCE5C\uAD6C\uB97C \uB9CC\uB4E4\uC5C8\uC2B5\uB2C8\uB2E4!",
    category: "SOCIAL",
    type: "COUNT",
    tier: "SILVER",
    targetValue: 5,
    targetUnit: "\uCE5C\uAD6C",
    xpReward: 1e3,
    badgeColor: "#C0C0C0",
    sortOrder: 7
  },
  {
    achievementKey: "study_hours_10",
    title: "10\uC2DC\uAC04 \uB2EC\uC131",
    description: "\uCD1D 10\uC2DC\uAC04\uC758 \uD559\uC2B5\uC744 \uC644\uB8CC\uD588\uC2B5\uB2C8\uB2E4!",
    category: "TIME",
    type: "ACCUMULATE",
    tier: "BRONZE",
    targetValue: 600,
    targetUnit: "\uBD84",
    xpReward: 500,
    badgeColor: "#CD7F32",
    sortOrder: 8
  },
  {
    achievementKey: "study_hours_50",
    title: "50\uC2DC\uAC04 \uB2EC\uC131",
    description: "\uCD1D 50\uC2DC\uAC04\uC758 \uD559\uC2B5\uC744 \uC644\uB8CC\uD588\uC2B5\uB2C8\uB2E4!",
    category: "TIME",
    type: "ACCUMULATE",
    tier: "SILVER",
    targetValue: 3e3,
    targetUnit: "\uBD84",
    xpReward: 2500,
    badgeColor: "#C0C0C0",
    sortOrder: 9
  },
  {
    achievementKey: "study_hours_100",
    title: "100\uC2DC\uAC04 \uB2EC\uC131",
    description: "\uCD1D 100\uC2DC\uAC04\uC758 \uD559\uC2B5\uC744 \uC644\uB8CC\uD588\uC2B5\uB2C8\uB2E4!",
    category: "TIME",
    type: "ACCUMULATE",
    tier: "GOLD",
    targetValue: 6e3,
    targetUnit: "\uBD84",
    xpReward: 5e3,
    badgeColor: "#FFD700",
    sortOrder: 10
  },
  {
    achievementKey: "level_up_first",
    title: "\uCCAB \uB808\uBCA8\uC5C5",
    description: "\uCC98\uC74C\uC73C\uB85C \uB808\uBCA8\uC774 \uC62C\uB790\uC2B5\uB2C8\uB2E4!",
    category: "SKILL",
    type: "THRESHOLD",
    tier: "BRONZE",
    targetValue: 2,
    targetUnit: "\uB808\uBCA8",
    xpReward: 300,
    badgeColor: "#CD7F32",
    sortOrder: 11
  },
  {
    achievementKey: "level_5",
    title: "\uC911\uAE09\uC790",
    description: "\uB808\uBCA8 5\uC5D0 \uB3C4\uB2EC\uD588\uC2B5\uB2C8\uB2E4!",
    category: "SKILL",
    type: "THRESHOLD",
    tier: "SILVER",
    targetValue: 5,
    targetUnit: "\uB808\uBCA8",
    xpReward: 1500,
    badgeColor: "#C0C0C0",
    sortOrder: 12
  },
  {
    achievementKey: "level_10",
    title: "\uACE0\uAE09\uC790",
    description: "\uB808\uBCA8 10\uC5D0 \uB3C4\uB2EC\uD588\uC2B5\uB2C8\uB2E4!",
    category: "SKILL",
    type: "THRESHOLD",
    tier: "GOLD",
    targetValue: 10,
    targetUnit: "\uB808\uBCA8",
    xpReward: 5e3,
    badgeColor: "#FFD700",
    sortOrder: 13
  },
  {
    achievementKey: "early_adopter",
    title: "\uC5BC\uB9AC \uC5B4\uB2F5\uD130",
    description: "\uC11C\uBE44\uC2A4 \uC624\uD508 \uCCAB \uB2EC\uC5D0 \uAC00\uC785\uD588\uC2B5\uB2C8\uB2E4!",
    category: "SPECIAL",
    type: "MILESTONE",
    tier: "LEGENDARY",
    xpReward: 1e3,
    badgeColor: "#9932CC",
    isHidden: true,
    sortOrder: 14
  },
  {
    achievementKey: "perfect_week",
    title: "\uC644\uBCBD\uD55C \uD55C \uC8FC",
    description: "\uC77C\uC8FC\uC77C \uB3D9\uC548 \uB9E4\uC77C \uC138\uC158\uC5D0 \uCC38\uC5EC\uD588\uC2B5\uB2C8\uB2E4!",
    category: "ENGAGEMENT",
    type: "COMBINATION",
    tier: "PLATINUM",
    targetValue: 7,
    targetUnit: "\uC77C",
    xpReward: 2e3,
    badgeColor: "#E5E4E2",
    sortOrder: 15
  }
];
function toBoolean(value) {
  return value === 1 || value === true;
}
__name(toBoolean, "toBoolean");
function aliasCategory(original) {
  if (!original) return "GENERAL";
  return CATEGORY_ALIAS[original] ?? original;
}
__name(aliasCategory, "aliasCategory");
function mapAchievementRow(row) {
  return {
    id: row.achievement_id,
    achievementKey: row.achievement_key,
    title: row.title,
    description: row.description ?? void 0,
    category: aliasCategory(row.category),
    originalCategory: row.category,
    type: row.type,
    tier: row.tier,
    targetValue: row.target_value ?? void 0,
    targetUnit: row.target_unit ?? void 0,
    xpReward: row.xp_reward ?? void 0,
    badgeIconUrl: row.badge_icon_url ?? void 0,
    badgeColor: row.badge_color ?? void 0,
    isActive: toBoolean(row.is_active),
    isHidden: toBoolean(row.is_hidden),
    sortOrder: row.sort_order ?? void 0,
    prerequisiteAchievementId: row.prerequisite_achievement_id ?? void 0
  };
}
__name(mapAchievementRow, "mapAchievementRow");
function mapUserAchievementRow(row) {
  const achievement = mapAchievementRow({
    achievement_id: row.achievement_id,
    achievement_key: row.achievement_key,
    title: row.title,
    description: row.description,
    category: row.category,
    type: row.type,
    tier: row.tier,
    target_value: row.target_value,
    target_unit: row.target_unit,
    xp_reward: row.xp_reward,
    badge_icon_url: row.badge_icon_url,
    badge_color: row.badge_color,
    is_active: row.is_active,
    is_hidden: row.is_hidden,
    sort_order: row.sort_order,
    prerequisite_achievement_id: row.prerequisite_achievement_id,
    created_at: "",
    updated_at: ""
  });
  const targetValue = row.target_value ?? 0;
  const current = row.current_progress ?? 0;
  const progressPercentage = targetValue > 0 ? Math.min(100, current / targetValue * 100) : toBoolean(row.is_completed) ? 100 : 0;
  return {
    id: row.user_achievement_id,
    achievement,
    currentProgress: current,
    isCompleted: toBoolean(row.is_completed),
    completedAt: row.completed_at ?? void 0,
    isRewardClaimed: toBoolean(row.is_reward_claimed),
    rewardClaimedAt: row.reward_claimed_at ?? void 0,
    progressPercentage
  };
}
__name(mapUserAchievementRow, "mapUserAchievementRow");
async function seedDefaultAchievements(env2) {
  const countRow = await queryFirst(
    env2.DB,
    "SELECT COUNT(*) as count FROM achievements"
  );
  if ((countRow?.count ?? 0) > 0) {
    return;
  }
  const now = (/* @__PURE__ */ new Date()).toISOString();
  await transaction(
    env2.DB,
    DEFAULT_ACHIEVEMENTS.map((item) => ({
      sql: `INSERT INTO achievements (
              achievement_key,
              title,
              description,
              category,
              type,
              tier,
              target_value,
              target_unit,
              xp_reward,
              badge_icon_url,
              badge_color,
              is_active,
              is_hidden,
              sort_order,
              created_at,
              updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NULL, ?, 1, ?, ?, ?, ?)`,
      params: [
        item.achievementKey,
        item.title,
        item.description ?? null,
        item.category,
        item.type,
        item.tier,
        item.targetValue ?? null,
        item.targetUnit ?? null,
        item.xpReward ?? null,
        item.badgeColor ?? null,
        item.isHidden ? 1 : 0,
        item.sortOrder ?? null,
        now,
        now
      ]
    }))
  );
}
__name(seedDefaultAchievements, "seedDefaultAchievements");
async function fetchAchievementByKey(env2, achievementKey) {
  const row = await queryFirst(
    env2.DB,
    "SELECT * FROM achievements WHERE achievement_key = ? AND is_active = 1 LIMIT 1",
    [achievementKey]
  );
  if (!row) {
    throw new AppError("\uC874\uC7AC\uD558\uC9C0 \uC54A\uB294 \uC5C5\uC801\uC785\uB2C8\uB2E4.", 404, "ACHIEVEMENT_NOT_FOUND");
  }
  return row;
}
__name(fetchAchievementByKey, "fetchAchievementByKey");
async function ensureUserAchievement(env2, userId, achievementId) {
  const existing = await queryFirst(
    env2.DB,
    `SELECT ua.*, a.achievement_key, a.title, a.description, a.category, a.type, a.tier,
            a.target_value, a.target_unit, a.xp_reward, a.badge_icon_url, a.badge_color,
            a.is_active, a.is_hidden, a.sort_order, a.prerequisite_achievement_id
       FROM user_achievements ua
       JOIN achievements a ON a.achievement_id = ua.achievement_id
      WHERE ua.user_id = ? AND ua.achievement_id = ?
      LIMIT 1`,
    [userId, achievementId]
  );
  if (existing) {
    return existing;
  }
  const now = (/* @__PURE__ */ new Date()).toISOString();
  await execute(
    env2.DB,
    `INSERT INTO user_achievements (
        user_id,
        achievement_id,
        current_progress,
        is_completed,
        completed_at,
        is_reward_claimed,
        reward_claimed_at,
        created_at,
        updated_at
      ) VALUES (?, ?, 0, 0, NULL, 0, NULL, ?, ?)`,
    [userId, achievementId, now, now]
  );
  const inserted = await queryFirst(
    env2.DB,
    `SELECT ua.*, a.achievement_key, a.title, a.description, a.category, a.type, a.tier,
            a.target_value, a.target_unit, a.xp_reward, a.badge_icon_url, a.badge_color,
            a.is_active, a.is_hidden, a.sort_order, a.prerequisite_achievement_id
       FROM user_achievements ua
       JOIN achievements a ON a.achievement_id = ua.achievement_id
      WHERE ua.user_id = ? AND ua.achievement_id = ?
      LIMIT 1`,
    [userId, achievementId]
  );
  if (!inserted) {
    throw new AppError("\uC5C5\uC801 \uC815\uBCF4\uB97C \uCD08\uAE30\uD654\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.", 500, "ACHIEVEMENT_INIT_FAILED");
  }
  return inserted;
}
__name(ensureUserAchievement, "ensureUserAchievement");
async function updateUserAchievementProgress(env2, userId, achievement, progress, incrementMode) {
  const targetValue = achievement.target_value ?? void 0;
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const row = await ensureUserAchievement(env2, userId, achievement.achievement_id);
  const current = incrementMode ? Math.max(0, (row.current_progress ?? 0) + progress) : Math.max(0, progress);
  let isCompleted = row.is_completed;
  let completedAt = row.completed_at;
  if (typeof targetValue === "number" && current >= targetValue && !toBoolean(row.is_completed)) {
    isCompleted = 1;
    completedAt = now;
  }
  await execute(
    env2.DB,
    `UPDATE user_achievements
        SET current_progress = ?,
            is_completed = ?,
            completed_at = ?,
            updated_at = ?
      WHERE user_id = ? AND achievement_id = ?`,
    [current, isCompleted, completedAt, now, userId, achievement.achievement_id]
  );
  const updated = await queryFirst(
    env2.DB,
    `SELECT ua.*, a.achievement_key, a.title, a.description, a.category, a.type, a.tier,
            a.target_value, a.target_unit, a.xp_reward, a.badge_icon_url, a.badge_color,
            a.is_active, a.is_hidden, a.sort_order, a.prerequisite_achievement_id
       FROM user_achievements ua
       JOIN achievements a ON a.achievement_id = ua.achievement_id
      WHERE ua.user_id = ? AND ua.achievement_id = ?
      LIMIT 1`,
    [userId, achievement.achievement_id]
  );
  if (!updated) {
    throw new AppError("\uC5C5\uC801 \uC9C4\uD589\uB3C4\uB97C \uAC31\uC2E0\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.", 500, "ACHIEVEMENT_UPDATE_FAILED");
  }
  return updated;
}
__name(updateUserAchievementProgress, "updateUserAchievementProgress");
async function getAllAchievements(env2) {
  await seedDefaultAchievements(env2);
  const rows = await query(
    env2.DB,
    `SELECT * FROM achievements
      WHERE is_active = 1
      ORDER BY COALESCE(sort_order, 9999), title`
  );
  return rows.map(mapAchievementRow);
}
__name(getAllAchievements, "getAllAchievements");
async function getAchievementsByCategory(env2, category) {
  await seedDefaultAchievements(env2);
  const normalized = category.toUpperCase();
  const rows = await query(
    env2.DB,
    `SELECT * FROM achievements
      WHERE is_active = 1 AND UPPER(category) = ?
      ORDER BY COALESCE(sort_order, 9999), title`,
    [normalized]
  );
  return rows.map(mapAchievementRow);
}
__name(getAchievementsByCategory, "getAchievementsByCategory");
async function getUserAchievements(env2, userId) {
  await seedDefaultAchievements(env2);
  const rows = await query(
    env2.DB,
    `SELECT ua.*, a.achievement_key, a.title, a.description, a.category, a.type, a.tier,
            a.target_value, a.target_unit, a.xp_reward, a.badge_icon_url, a.badge_color,
            a.is_active, a.is_hidden, a.sort_order, a.prerequisite_achievement_id
       FROM user_achievements ua
       JOIN achievements a ON a.achievement_id = ua.achievement_id
      WHERE ua.user_id = ?
      ORDER BY ua.is_completed DESC, ua.completed_at DESC, COALESCE(a.sort_order, 9999)`,
    [userId]
  );
  return rows.map(mapUserAchievementRow);
}
__name(getUserAchievements, "getUserAchievements");
async function getCompletedAchievements(env2, userId) {
  const rows = await query(
    env2.DB,
    `SELECT ua.*, a.achievement_key, a.title, a.description, a.category, a.type, a.tier,
            a.target_value, a.target_unit, a.xp_reward, a.badge_icon_url, a.badge_color,
            a.is_active, a.is_hidden, a.sort_order, a.prerequisite_achievement_id
       FROM user_achievements ua
       JOIN achievements a ON a.achievement_id = ua.achievement_id
      WHERE ua.user_id = ? AND ua.is_completed = 1
      ORDER BY ua.completed_at DESC`,
    [userId]
  );
  return rows.map(mapUserAchievementRow);
}
__name(getCompletedAchievements, "getCompletedAchievements");
async function getInProgressAchievements(env2, userId) {
  const rows = await query(
    env2.DB,
    `SELECT ua.*, a.achievement_key, a.title, a.description, a.category, a.type, a.tier,
            a.target_value, a.target_unit, a.xp_reward, a.badge_icon_url, a.badge_color,
            a.is_active, a.is_hidden, a.sort_order, a.prerequisite_achievement_id
       FROM user_achievements ua
       JOIN achievements a ON a.achievement_id = ua.achievement_id
      WHERE ua.user_id = ? AND ua.is_completed = 0
      ORDER BY ua.current_progress DESC, COALESCE(a.sort_order, 9999)`,
    [userId]
  );
  return rows.map(mapUserAchievementRow);
}
__name(getInProgressAchievements, "getInProgressAchievements");
async function getAchievementStats(env2, userId) {
  await seedDefaultAchievements(env2);
  const [totalRow, completedRow, inProgressRow, totalXpRow, unclaimedRow] = await Promise.all([
    queryFirst(env2.DB, "SELECT COUNT(*) as count FROM achievements WHERE is_active = 1"),
    queryFirst(
      env2.DB,
      "SELECT COUNT(*) as count FROM user_achievements WHERE user_id = ? AND is_completed = 1",
      [userId]
    ),
    queryFirst(
      env2.DB,
      "SELECT COUNT(*) as count FROM user_achievements WHERE user_id = ? AND is_completed = 0 AND current_progress > 0",
      [userId]
    ),
    queryFirst(
      env2.DB,
      `SELECT COALESCE(SUM(a.xp_reward), 0) as total
         FROM user_achievements ua
         JOIN achievements a ON a.achievement_id = ua.achievement_id
        WHERE ua.user_id = ? AND ua.is_reward_claimed = 1`,
      [userId]
    ),
    queryFirst(
      env2.DB,
      "SELECT COUNT(*) as count FROM user_achievements WHERE user_id = ? AND is_completed = 1 AND is_reward_claimed = 0",
      [userId]
    )
  ]);
  const achievementsByCategoryRows = await query(
    env2.DB,
    `SELECT a.category as key, COUNT(*) as count
       FROM user_achievements ua
       JOIN achievements a ON a.achievement_id = ua.achievement_id
      WHERE ua.user_id = ? AND ua.is_completed = 1
      GROUP BY a.category`,
    [userId]
  );
  const achievementsByTierRows = await query(
    env2.DB,
    `SELECT a.tier as key, COUNT(*) as count
       FROM user_achievements ua
       JOIN achievements a ON a.achievement_id = ua.achievement_id
      WHERE ua.user_id = ? AND ua.is_completed = 1
      GROUP BY a.tier`,
    [userId]
  );
  const recentRows = await query(
    env2.DB,
    `SELECT ua.*, a.achievement_key, a.title, a.description, a.category, a.type, a.tier,
            a.target_value, a.target_unit, a.xp_reward, a.badge_icon_url, a.badge_color,
            a.is_active, a.is_hidden, a.sort_order, a.prerequisite_achievement_id
       FROM user_achievements ua
       JOIN achievements a ON a.achievement_id = ua.achievement_id
      WHERE ua.user_id = ? AND ua.is_completed = 1
      ORDER BY ua.completed_at DESC
      LIMIT 5`,
    [userId]
  );
  const nearCompletionRows = await query(
    env2.DB,
    `SELECT ua.*, a.achievement_key, a.title, a.description, a.category, a.type, a.tier,
            a.target_value, a.target_unit, a.xp_reward, a.badge_icon_url, a.badge_color,
            a.is_active, a.is_hidden, a.sort_order, a.prerequisite_achievement_id
       FROM user_achievements ua
       JOIN achievements a ON a.achievement_id = ua.achievement_id
      WHERE ua.user_id = ?
        AND ua.is_completed = 0
        AND a.target_value IS NOT NULL
        AND a.target_value > 0
        AND (ua.current_progress * 100.0 / a.target_value) >= 80
      ORDER BY (ua.current_progress * 100.0 / a.target_value) DESC
      LIMIT 5`,
    [userId]
  );
  const totalAchievements = totalRow?.count ?? 0;
  const completedAchievements = completedRow?.count ?? 0;
  const completionRate = totalAchievements > 0 ? completedAchievements / totalAchievements * 100 : 0;
  const achievementsByCategory = {};
  for (const row of achievementsByCategoryRows) {
    achievementsByCategory[aliasCategory(row.key)] = row.count;
  }
  const achievementsByTier = {};
  for (const row of achievementsByTierRows) {
    achievementsByTier[row.key ?? "UNKNOWN"] = row.count;
  }
  return {
    totalAchievements,
    completedAchievements,
    inProgressAchievements: inProgressRow?.count ?? 0,
    totalXpEarned: totalXpRow?.total ?? 0,
    unclaimedRewards: unclaimedRow?.count ?? 0,
    completionRate,
    achievementsByCategory,
    achievementsByTier,
    recentCompletions: recentRows.map(mapUserAchievementRow),
    nearCompletion: nearCompletionRows.map(mapUserAchievementRow)
  };
}
__name(getAchievementStats, "getAchievementStats");
async function updateAchievementProgress(env2, userId, achievementKey, progress) {
  if (!achievementKey) {
    throw new AppError("achievementKey\uB294 \uD544\uC218\uC785\uB2C8\uB2E4.", 400, "INVALID_ACHIEVEMENT_KEY");
  }
  if (!Number.isFinite(progress) || progress < 0) {
    throw new AppError("progress\uB294 0 \uC774\uC0C1\uC758 \uC22B\uC790\uC5EC\uC57C \uD569\uB2C8\uB2E4.", 400, "INVALID_PROGRESS");
  }
  const achievement = await fetchAchievementByKey(env2, achievementKey);
  const updated = await updateUserAchievementProgress(env2, userId, achievement, progress, false);
  return mapUserAchievementRow(updated);
}
__name(updateAchievementProgress, "updateAchievementProgress");
async function incrementAchievementProgress(env2, userId, achievementKey, increment) {
  if (!achievementKey) {
    throw new AppError("achievementKey\uB294 \uD544\uC218\uC785\uB2C8\uB2E4.", 400, "INVALID_ACHIEVEMENT_KEY");
  }
  if (!Number.isFinite(increment) || increment <= 0) {
    throw new AppError("increment\uB294 1 \uC774\uC0C1\uC758 \uC22B\uC790\uC5EC\uC57C \uD569\uB2C8\uB2E4.", 400, "INVALID_INCREMENT");
  }
  const achievement = await fetchAchievementByKey(env2, achievementKey);
  const updated = await updateUserAchievementProgress(env2, userId, achievement, increment, true);
  return mapUserAchievementRow(updated);
}
__name(incrementAchievementProgress, "incrementAchievementProgress");
async function claimAchievementReward(env2, userId, userAchievementId) {
  const row = await queryFirst(
    env2.DB,
    `SELECT ua.*, a.achievement_key, a.title, a.description, a.category, a.type, a.tier,
            a.target_value, a.target_unit, a.xp_reward, a.badge_icon_url, a.badge_color,
            a.is_active, a.is_hidden, a.sort_order, a.prerequisite_achievement_id
       FROM user_achievements ua
       JOIN achievements a ON a.achievement_id = ua.achievement_id
      WHERE ua.user_achievement_id = ?
      LIMIT 1`,
    [userAchievementId]
  );
  if (!row) {
    throw new AppError("\uC874\uC7AC\uD558\uC9C0 \uC54A\uB294 \uC0AC\uC6A9\uC790 \uC5C5\uC801\uC785\uB2C8\uB2E4.", 404, "USER_ACHIEVEMENT_NOT_FOUND");
  }
  if (row.user_id !== userId) {
    throw new AppError("\uBCF8\uC778\uC758 \uC5C5\uC801\uB9CC \uBCF4\uC0C1\uC744 \uBC1B\uC744 \uC218 \uC788\uC2B5\uB2C8\uB2E4.", 403, "FORBIDDEN");
  }
  if (!toBoolean(row.is_completed)) {
    throw new AppError("\uC644\uB8CC\uB418\uC9C0 \uC54A\uC740 \uC5C5\uC801\uC785\uB2C8\uB2E4.", 400, "ACHIEVEMENT_NOT_COMPLETED");
  }
  if (toBoolean(row.is_reward_claimed)) {
    throw new AppError("\uC774\uBBF8 \uBCF4\uC0C1\uC744 \uC218\uB839\uD588\uC2B5\uB2C8\uB2E4.", 400, "ACHIEVEMENT_REWARD_ALREADY_CLAIMED");
  }
  const now = (/* @__PURE__ */ new Date()).toISOString();
  await execute(
    env2.DB,
    `UPDATE user_achievements
        SET is_reward_claimed = 1,
            reward_claimed_at = ?,
            updated_at = ?
      WHERE user_achievement_id = ?`,
    [now, now, userAchievementId]
  );
  const updated = await queryFirst(
    env2.DB,
    `SELECT ua.*, a.achievement_key, a.title, a.description, a.category, a.type, a.tier,
            a.target_value, a.target_unit, a.xp_reward, a.badge_icon_url, a.badge_color,
            a.is_active, a.is_hidden, a.sort_order, a.prerequisite_achievement_id
       FROM user_achievements ua
       JOIN achievements a ON a.achievement_id = ua.achievement_id
      WHERE ua.user_achievement_id = ?
      LIMIT 1`,
    [userAchievementId]
  );
  if (!updated) {
    throw new AppError("\uC5C5\uC801 \uBCF4\uC0C1 \uC815\uBCF4\uB97C \uAC31\uC2E0\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.", 500, "ACHIEVEMENT_REWARD_FAILED");
  }
  return mapUserAchievementRow(updated);
}
__name(claimAchievementReward, "claimAchievementReward");
async function initializeUserAchievements(env2, userId) {
  await seedDefaultAchievements(env2);
  const achievementIds = await query(
    env2.DB,
    "SELECT achievement_id FROM achievements WHERE is_active = 1"
  );
  const statements = achievementIds.map(({ achievement_id }) => ({
    sql: `INSERT OR IGNORE INTO user_achievements (
            user_id,
            achievement_id,
            current_progress,
            is_completed,
            completed_at,
            is_reward_claimed,
            reward_claimed_at,
            created_at,
            updated_at
          ) VALUES (?, ?, 0, 0, NULL, 0, NULL, ?, ?)`,
    params: [userId, achievement_id, (/* @__PURE__ */ new Date()).toISOString(), (/* @__PURE__ */ new Date()).toISOString()]
  }));
  if (statements.length) {
    await transaction(env2.DB, statements);
  }
}
__name(initializeUserAchievements, "initializeUserAchievements");
async function checkAndCompleteAchievements(env2, userId) {
  await seedDefaultAchievements(env2);
  const candidates = await query(
    env2.DB,
    `SELECT ua.*, a.achievement_key, a.title, a.description, a.category, a.type, a.tier,
            a.target_value, a.target_unit, a.xp_reward, a.badge_icon_url, a.badge_color,
            a.is_active, a.is_hidden, a.sort_order, a.prerequisite_achievement_id
       FROM user_achievements ua
       JOIN achievements a ON a.achievement_id = ua.achievement_id
      WHERE ua.user_id = ? AND ua.is_completed = 0
      ORDER BY ua.current_progress DESC`,
    [userId]
  );
  const completed = [];
  const now = (/* @__PURE__ */ new Date()).toISOString();
  for (const candidate of candidates) {
    const targetValue = candidate.target_value ?? null;
    if (typeof targetValue !== "number" || candidate.current_progress < targetValue) {
      continue;
    }
    if (candidate.prerequisite_achievement_id) {
      const prereq = await queryFirst(
        env2.DB,
        `SELECT is_completed FROM user_achievements
          WHERE user_id = ? AND achievement_id = ?
          LIMIT 1`,
        [userId, candidate.prerequisite_achievement_id]
      );
      if (!prereq || !toBoolean(prereq.is_completed)) {
        continue;
      }
    }
    await execute(
      env2.DB,
      `UPDATE user_achievements
          SET is_completed = 1,
              completed_at = COALESCE(completed_at, ?),
              updated_at = ?
        WHERE user_achievement_id = ?`,
      [now, now, candidate.user_achievement_id]
    );
    const updated = await queryFirst(
      env2.DB,
      `SELECT ua.*, a.achievement_key, a.title, a.description, a.category, a.type, a.tier,
              a.target_value, a.target_unit, a.xp_reward, a.badge_icon_url, a.badge_color,
              a.is_active, a.is_hidden, a.sort_order, a.prerequisite_achievement_id
         FROM user_achievements ua
         JOIN achievements a ON a.achievement_id = ua.achievement_id
        WHERE ua.user_achievement_id = ?
        LIMIT 1`,
      [candidate.user_achievement_id]
    );
    if (updated) {
      completed.push(mapUserAchievementRow(updated));
      try {
        const xpReward = updated.xp_reward || 0;
        await createNotification(env2, {
          userId,
          type: "ACHIEVEMENT_UNLOCKED",
          title: "\u{1F3C6} \uC5C5\uC801 \uB2EC\uC131!",
          content: `"${updated.title}" \uC5C5\uC801\uC744 \uB2EC\uC131\uD588\uC2B5\uB2C8\uB2E4! (${xpReward} XP \uD68D\uB4DD)`,
          category: "achievement",
          priority: 2,
          actionUrl: `/achievements`,
          actionData: {
            achievementId: updated.achievement_id,
            achievementKey: updated.achievement_key,
            title: updated.title,
            tier: updated.tier,
            xpReward
          }
        });
      } catch (error48) {
        console.error(`Failed to send ACHIEVEMENT_UNLOCKED notification for achievement ${updated.achievement_id}:`, error48);
      }
    }
  }
  return completed;
}
__name(checkAndCompleteAchievements, "checkAndCompleteAchievements");

// src/routes/achievements.ts
var achievementsRoutes = new Hono2();
var requireAuth9 = auth();
function requireUserId2(userId) {
  if (!userId) {
    throw new AppError("\uC778\uC99D \uC815\uBCF4\uAC00 \uD544\uC694\uD569\uB2C8\uB2E4.", 401, "UNAUTHORIZED");
  }
  return userId;
}
__name(requireUserId2, "requireUserId");
achievementsRoutes.use("*", requireAuth9);
achievementsRoutes.get("/", async (c) => {
  const achievements = await getAllAchievements(c.env);
  return successResponse(c, achievements);
});
achievementsRoutes.get("/category/:category", async (c) => {
  const category = c.req.param("category");
  if (!category) {
    throw new AppError("\uCE74\uD14C\uACE0\uB9AC\uAC00 \uD544\uC694\uD569\uB2C8\uB2E4.", 400, "INVALID_CATEGORY");
  }
  const achievements = await getAchievementsByCategory(c.env, category);
  return successResponse(c, achievements);
});
achievementsRoutes.get("/my", async (c) => {
  const userId = requireUserId2(c.get("userId"));
  await initializeUserAchievements(c.env, userId);
  const achievements = await getUserAchievements(c.env, userId);
  return successResponse(c, achievements);
});
achievementsRoutes.get("/my/completed", async (c) => {
  const userId = requireUserId2(c.get("userId"));
  const achievements = await getCompletedAchievements(c.env, userId);
  return successResponse(c, achievements);
});
achievementsRoutes.get("/my/in-progress", async (c) => {
  const userId = requireUserId2(c.get("userId"));
  const achievements = await getInProgressAchievements(c.env, userId);
  return successResponse(c, achievements);
});
achievementsRoutes.get("/my/stats", async (c) => {
  const userId = requireUserId2(c.get("userId"));
  await initializeUserAchievements(c.env, userId);
  const stats = await getAchievementStats(c.env, userId);
  return successResponse(c, stats);
});
achievementsRoutes.post("/progress", async (c) => {
  const userId = requireUserId2(c.get("userId"));
  const body = await c.req.json().catch(() => ({}));
  const achievementKey = typeof body?.achievementKey === "string" ? body.achievementKey.trim() : "";
  const progress = typeof body?.progress === "number" ? body.progress : Number(body?.progress);
  if (!achievementKey) {
    throw new AppError("achievementKey\uB294 \uD544\uC218\uC785\uB2C8\uB2E4.", 400, "INVALID_ACHIEVEMENT_KEY");
  }
  if (!Number.isFinite(progress)) {
    throw new AppError("progress\uB294 \uC22B\uC790\uC5EC\uC57C \uD569\uB2C8\uB2E4.", 400, "INVALID_PROGRESS");
  }
  const updated = await updateAchievementProgress(c.env, userId, achievementKey, progress);
  return successResponse(c, updated);
});
achievementsRoutes.post("/progress/increment", async (c) => {
  const userId = requireUserId2(c.get("userId"));
  const achievementKey = (c.req.query("achievementKey") || "").trim();
  const incrementRaw = c.req.query("increment");
  const increment = incrementRaw ? Number(incrementRaw) : 1;
  if (!achievementKey) {
    throw new AppError("achievementKey\uB294 \uD544\uC218\uC785\uB2C8\uB2E4.", 400, "INVALID_ACHIEVEMENT_KEY");
  }
  if (!Number.isFinite(increment)) {
    throw new AppError("increment\uB294 \uC22B\uC790\uC5EC\uC57C \uD569\uB2C8\uB2E4.", 400, "INVALID_INCREMENT");
  }
  const updated = await incrementAchievementProgress(c.env, userId, achievementKey, increment);
  return successResponse(c, updated);
});
achievementsRoutes.post("/:userAchievementId/claim-reward", async (c) => {
  const userId = requireUserId2(c.get("userId"));
  const idRaw = c.req.param("userAchievementId");
  const userAchievementId = Number(idRaw);
  if (!Number.isFinite(userAchievementId)) {
    throw new AppError("userAchievementId\uAC00 \uC720\uD6A8\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.", 400, "INVALID_PATH_PARAM");
  }
  const result = await claimAchievementReward(c.env, userId, userAchievementId);
  return successResponse(c, result);
});
achievementsRoutes.post("/initialize", async (c) => {
  const userId = requireUserId2(c.get("userId"));
  await initializeUserAchievements(c.env, userId);
  return successResponse(c, { initialized: true });
});
achievementsRoutes.post("/check-completion", async (c) => {
  const userId = requireUserId2(c.get("userId"));
  const completed = await checkAndCompleteAchievements(c.env, userId);
  return successResponse(c, completed);
});
var achievements_default = achievementsRoutes;

// src/routes/chat.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_errors();

// src/services/chat.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_db();
init_errors();
function nowIso5() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
__name(nowIso5, "nowIso");
function toBoolean2(value) {
  return value === 1 || value === true;
}
__name(toBoolean2, "toBoolean");
function mapParticipant(row) {
  return {
    userId: row.user_id,
    name: row.name ?? void 0,
    profileImage: row.profile_image ?? void 0
  };
}
__name(mapParticipant, "mapParticipant");
async function fetchParticipants2(env2, roomId) {
  const rows = await query(
    env2.DB,
    `SELECT p.room_id, p.user_id, p.joined_at, u.name, u.profile_image
       FROM chat_room_participant p
       LEFT JOIN users u ON u.user_id = p.user_id
      WHERE p.room_id = ?
      ORDER BY p.joined_at ASC`,
    [roomId]
  );
  return rows.map(mapParticipant);
}
__name(fetchParticipants2, "fetchParticipants");
function computeMessageType(row, images, files) {
  const hasText = Boolean(row.message && row.message.trim().length > 0);
  const hasImages = images.length > 0;
  const hasAudio = Boolean(row.audio_url);
  const hasFiles = files.length > 0;
  if (hasAudio && !hasImages && !hasText && !hasFiles) return "AUDIO";
  if (hasImages && !hasAudio && !hasText && !hasFiles) return "IMAGE";
  if (hasFiles && !hasAudio && !hasImages && !hasText) return "FILE";
  if (hasText && !hasAudio && !hasImages && !hasFiles) return "TEXT";
  return "MIXED";
}
__name(computeMessageType, "computeMessageType");
function mapFile(row) {
  return {
    fileId: row.file_id,
    originalFilename: row.original_filename,
    fileUrl: row.file_url ?? `/api/v1/upload/file/${row.file_path}`,
    fileType: row.file_type,
    contentType: row.content_type ?? void 0,
    fileSize: row.file_size ?? void 0,
    thumbnailUrl: row.thumbnail_url ?? void 0,
    duration: row.duration ?? void 0,
    createdAt: row.created_at
  };
}
__name(mapFile, "mapFile");
function mapMessage(row, images, files) {
  const participant = {
    userId: row.user_id,
    name: row.name ?? void 0,
    profileImage: row.profile_image ?? void 0
  };
  return {
    messageId: row.message_id,
    roomId: row.room_id,
    sender: participant,
    message: row.message ?? void 0,
    imageUrls: images.map((img) => img.image_url),
    audioUrl: row.audio_url ?? void 0,
    audioDuration: void 0,
    files,
    messageType: computeMessageType(row, images, files),
    sentAt: row.created_at
  };
}
__name(mapMessage, "mapMessage");
async function ensureRoomExists(env2, roomId) {
  const row = await queryFirst(
    env2.DB,
    "SELECT * FROM chat_room WHERE room_id = ? LIMIT 1",
    [roomId]
  );
  if (!row) {
    throw new AppError("\uCC44\uD305\uBC29\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.", 404, "CHAT_ROOM_NOT_FOUND");
  }
  return row;
}
__name(ensureRoomExists, "ensureRoomExists");
async function mapRoom(env2, room) {
  const participants = await fetchParticipants2(env2, room.room_id);
  const lastMessageRow = await queryFirst(
    env2.DB,
    `SELECT m.message, m.created_at
       FROM chat_message m
      WHERE m.room_id = ?
      ORDER BY m.created_at DESC
      LIMIT 1`,
    [room.room_id]
  );
  return {
    roomId: room.room_id,
    roomName: room.room_name,
    roomType: room.room_type,
    isPublic: toBoolean2(room.is_public),
    maxParticipants: room.max_participants ?? void 0,
    participants,
    lastMessage: lastMessageRow?.message ?? void 0,
    lastMessageAt: lastMessageRow?.created_at ?? void 0
  };
}
__name(mapRoom, "mapRoom");
async function listUserChatRooms(env2, userId) {
  const rows = await query(
    env2.DB,
    `SELECT r.*
       FROM chat_room r
       JOIN chat_room_participant p ON p.room_id = r.room_id
      WHERE p.user_id = ?
      ORDER BY r.updated_at DESC, r.created_at DESC`,
    [userId]
  );
  const summaries = [];
  for (const row of rows) {
    summaries.push(await mapRoom(env2, row));
  }
  return summaries;
}
__name(listUserChatRooms, "listUserChatRooms");
async function listPublicChatRooms(env2, userId) {
  const rows = await query(
    env2.DB,
    `SELECT r.*
       FROM chat_room r
      WHERE r.is_public = 1
        AND r.room_id NOT IN (SELECT room_id FROM chat_room_participant WHERE user_id = ?)
      ORDER BY r.created_at DESC`,
    [userId]
  );
  const summaries = [];
  for (const row of rows) {
    summaries.push(await mapRoom(env2, row));
  }
  return summaries;
}
__name(listPublicChatRooms, "listPublicChatRooms");
async function createChatRoom(env2, creatorId, roomName, participantIds = [], options) {
  if (!roomName?.trim()) {
    throw new AppError("\uCC44\uD305\uBC29 \uC774\uB984\uC740 \uD544\uC218\uC785\uB2C8\uB2E4.", 400, "INVALID_ROOM_NAME");
  }
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const isPublic = options?.isPublic ? 1 : 0;
  const roomType = options?.roomType ?? "GROUP";
  const maxParticipants = options?.maxParticipants ?? null;
  await execute(
    env2.DB,
    `INSERT INTO chat_room (room_name, room_type, is_public, max_participants, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?)`,
    [roomName.trim(), roomType, isPublic, maxParticipants, now, now]
  );
  const roomIdRow = await queryFirst(env2.DB, "SELECT last_insert_rowid() as id");
  const roomId = Number(roomIdRow?.id ?? 0);
  if (!roomId) {
    throw new AppError("\uCC44\uD305\uBC29\uC744 \uC0DD\uC131\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.", 500, "CHAT_ROOM_CREATE_FAILED");
  }
  const uniqueIds = /* @__PURE__ */ new Set([creatorId, ...participantIds]);
  const statements = Array.from(uniqueIds).map((id) => ({
    sql: `INSERT OR IGNORE INTO chat_room_participant (room_id, user_id, joined_at)
            VALUES (?, ?, ?)`,
    params: [roomId, id, now]
  }));
  await transaction(env2.DB, statements);
  const room = await ensureRoomExists(env2, roomId);
  return mapRoom(env2, room);
}
__name(createChatRoom, "createChatRoom");
async function joinChatRoom(env2, roomId, userId) {
  const room = await ensureRoomExists(env2, roomId);
  const now = (/* @__PURE__ */ new Date()).toISOString();
  await execute(
    env2.DB,
    `INSERT OR IGNORE INTO chat_room_participant (room_id, user_id, joined_at)
      VALUES (?, ?, ?)`,
    [roomId, userId, now]
  );
  return mapRoom(env2, room);
}
__name(joinChatRoom, "joinChatRoom");
async function leaveChatRoom(env2, roomId, userId) {
  await ensureRoomExists(env2, roomId);
  await execute(
    env2.DB,
    "DELETE FROM chat_room_participant WHERE room_id = ? AND user_id = ?",
    [roomId, userId]
  );
}
__name(leaveChatRoom, "leaveChatRoom");
async function listRoomMessages(env2, roomId, page, size) {
  await ensureRoomExists(env2, roomId);
  const offset = Math.max(page, 0) * size;
  const messageRows = await query(
    env2.DB,
    `SELECT m.*, u.name, u.profile_image
       FROM chat_message m
       LEFT JOIN users u ON u.user_id = m.user_id
      WHERE m.room_id = ?
      ORDER BY m.created_at DESC
      LIMIT ? OFFSET ?`,
    [roomId, size, offset]
  );
  const messageIds = messageRows.map((row) => row.message_id);
  if (messageIds.length === 0) {
    return [];
  }
  const imageRows = await query(
    env2.DB,
    `SELECT message_id, image_url
       FROM chat_image
      WHERE message_id IN (${messageIds.map(() => "?").join(",")})`,
    messageIds
  );
  const fileRows = await query(
    env2.DB,
    `SELECT f.*
       FROM chat_files f
      WHERE f.message_id IN (${messageIds.map(() => "?").join(",")})
        AND f.is_deleted = 0`,
    messageIds
  );
  const imageMap = /* @__PURE__ */ new Map();
  for (const img of imageRows) {
    const list = imageMap.get(img.message_id) ?? [];
    list.push(img);
    imageMap.set(img.message_id, list);
  }
  const fileMap = /* @__PURE__ */ new Map();
  for (const file2 of fileRows) {
    const mapped = mapFile(file2);
    const list = fileMap.get(file2.message_id) ?? [];
    list.push(mapped);
    fileMap.set(file2.message_id, list);
  }
  const messages = messageRows.map((row) => {
    const images = imageMap.get(row.message_id) ?? [];
    const files = fileMap.get(row.message_id) ?? [];
    return mapMessage(row, images, files);
  }).reverse();
  return messages;
}
__name(listRoomMessages, "listRoomMessages");
async function searchRoomMessages(env2, roomId, keyword, page, size) {
  await ensureRoomExists(env2, roomId);
  if (!keyword?.trim()) {
    return [];
  }
  const offset = Math.max(page, 0) * size;
  const messageRows = await query(
    env2.DB,
    `SELECT m.*, u.name, u.profile_image
       FROM chat_message m
       LEFT JOIN users u ON u.user_id = m.user_id
      WHERE m.room_id = ? AND m.message LIKE ?
      ORDER BY m.created_at DESC
      LIMIT ? OFFSET ?`,
    [roomId, `%${keyword}%`, size, offset]
  );
  const messageIds = messageRows.map((row) => row.message_id);
  if (messageIds.length === 0) {
    return [];
  }
  const imageRows = await query(
    env2.DB,
    `SELECT message_id, image_url
       FROM chat_image
      WHERE message_id IN (${messageIds.map(() => "?").join(",")})`,
    messageIds
  );
  const fileRows = await query(
    env2.DB,
    `SELECT f.*
       FROM chat_files f
      WHERE f.message_id IN (${messageIds.map(() => "?").join(",")})
        AND f.is_deleted = 0`,
    messageIds
  );
  const imageMap = /* @__PURE__ */ new Map();
  for (const img of imageRows) {
    const list = imageMap.get(img.message_id) ?? [];
    list.push(img);
    imageMap.set(img.message_id, list);
  }
  const fileMap = /* @__PURE__ */ new Map();
  for (const file2 of fileRows) {
    const mapped = mapFile(file2);
    const list = fileMap.get(file2.message_id) ?? [];
    list.push(mapped);
    fileMap.set(file2.message_id, list);
  }
  return messageRows.map((row) => mapMessage(row, imageMap.get(row.message_id) ?? [], fileMap.get(row.message_id) ?? [])).reverse();
}
__name(searchRoomMessages, "searchRoomMessages");
async function uploadChatImages(env2, roomId, userId, files) {
  await ensureRoomExists(env2, roomId);
  const participant = await queryFirst(
    env2.DB,
    "SELECT 1 FROM chat_room_participant WHERE room_id = ? AND user_id = ? LIMIT 1",
    [roomId, userId]
  );
  if (!participant) {
    throw new AppError("\uCC44\uD305\uBC29\uC5D0 \uCC38\uC5EC\uD558\uC9C0 \uC54A\uC740 \uC0AC\uC6A9\uC790\uC785\uB2C8\uB2E4.", 403, "CHAT_ROOM_FORBIDDEN");
  }
  if (!files.length) {
    return [];
  }
  const urls = [];
  for (const file2 of files) {
    const buffer = await file2.arrayBuffer();
    const key = `chat/${roomId}/images/${generateUniqueFileName(file2.name, userId)}`;
    await saveToR2(env2.STORAGE, key, buffer, file2.type, {
      roomId: String(roomId),
      uploader: userId,
      fileName: file2.name
    });
    const url2 = `/api/v1/upload/file/${key}`;
    urls.push(url2);
  }
  return urls;
}
__name(uploadChatImages, "uploadChatImages");
async function uploadChatAudio(env2, roomId, userId, file2) {
  await ensureRoomExists(env2, roomId);
  const participant = await queryFirst(
    env2.DB,
    "SELECT 1 FROM chat_room_participant WHERE room_id = ? AND user_id = ? LIMIT 1",
    [roomId, userId]
  );
  if (!participant) {
    throw new AppError("\uCC44\uD305\uBC29\uC5D0 \uCC38\uC5EC\uD558\uC9C0 \uC54A\uC740 \uC0AC\uC6A9\uC790\uC785\uB2C8\uB2E4.", 403, "CHAT_ROOM_FORBIDDEN");
  }
  const buffer = await file2.arrayBuffer();
  const key = `chat/${roomId}/audio/${generateUniqueFileName(file2.name, userId)}`;
  await saveToR2(env2.STORAGE, key, buffer, file2.type, {
    roomId: String(roomId),
    uploader: userId,
    fileName: file2.name
  });
  return `/api/v1/upload/file/${key}`;
}
__name(uploadChatAudio, "uploadChatAudio");
async function listMyChatFiles(env2, userId) {
  const rows = await query(
    env2.DB,
    `SELECT f.*
       FROM chat_files f
       JOIN chat_message m ON m.message_id = f.message_id
      WHERE m.user_id = ? AND f.is_deleted = 0
      ORDER BY f.created_at DESC`,
    [userId]
  );
  return rows.map(mapFile);
}
__name(listMyChatFiles, "listMyChatFiles");
async function deleteChatFile(env2, userId, fileId) {
  const row = await queryFirst(
    env2.DB,
    `SELECT f.*
       FROM chat_files f
       JOIN chat_message m ON m.message_id = f.message_id
      WHERE f.file_id = ?
      LIMIT 1`,
    [fileId]
  );
  if (!row) {
    throw new AppError("\uD30C\uC77C\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.", 404, "CHAT_FILE_NOT_FOUND");
  }
  const messageOwner = await queryFirst(
    env2.DB,
    "SELECT user_id FROM chat_message WHERE message_id = ? LIMIT 1",
    [row.message_id]
  );
  if (messageOwner?.user_id !== userId) {
    throw new AppError("\uBCF8\uC778\uC774 \uC5C5\uB85C\uB4DC\uD55C \uD30C\uC77C\uB9CC \uC0AD\uC81C\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.", 403, "CHAT_FILE_FORBIDDEN");
  }
  await execute(
    env2.DB,
    "UPDATE chat_files SET is_deleted = 1, updated_at = ? WHERE file_id = ?",
    [(/* @__PURE__ */ new Date()).toISOString(), fileId]
  );
}
__name(deleteChatFile, "deleteChatFile");
function parseDataUrl(base64DataUrl) {
  const match = base64DataUrl.match(/^data:(.+);base64,(.*)$/);
  if (!match) {
    throw new AppError("\uC798\uBABB\uB41C \uC624\uB514\uC624 \uB370\uC774\uD130\uC785\uB2C8\uB2E4.", 400, "INVALID_AUDIO_DATA");
  }
  const contentType = match[1];
  const base643 = match[2];
  const binaryString = atob(base643);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i += 1) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return { contentType, buffer: bytes.buffer };
}
__name(parseDataUrl, "parseDataUrl");
async function createChatMessage(env2, userId, payload) {
  const roomId = Number(payload.roomId);
  if (!Number.isFinite(roomId)) {
    throw new AppError("roomId\uAC00 \uD544\uC694\uD569\uB2C8\uB2E4.", 400, "INVALID_ROOM_ID");
  }
  const room = await queryFirst(
    env2.DB,
    "SELECT * FROM chat_room WHERE room_id = ? LIMIT 1",
    [roomId]
  );
  if (!room) {
    throw new AppError("\uCC44\uD305\uBC29\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.", 404, "CHAT_ROOM_NOT_FOUND");
  }
  const participant = await queryFirst(
    env2.DB,
    "SELECT 1 FROM chat_room_participant WHERE room_id = ? AND user_id = ? LIMIT 1",
    [roomId, userId]
  );
  if (!participant) {
    throw new AppError("\uCC44\uD305\uBC29\uC5D0 \uCC38\uC5EC\uD558\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.", 403, "CHAT_ROOM_FORBIDDEN");
  }
  const now = nowIso5();
  const messageText = typeof payload.message === "string" && payload.message.trim().length > 0 ? payload.message.trim() : null;
  const imageUrls = Array.isArray(payload.imageUrls) ? payload.imageUrls.filter((url2) => typeof url2 === "string" && url2.length > 0) : [];
  let audioUrl = payload.audioUrl ?? null;
  if (!audioUrl && typeof payload.audioData === "string" && payload.audioData.startsWith("data:")) {
    const { contentType, buffer } = parseDataUrl(payload.audioData);
    const key = `chat/${roomId}/audio/${generateUniqueFileName("voice-message.webm", userId)}`;
    await saveToR2(env2.STORAGE, key, buffer, contentType, {
      roomId: String(roomId),
      uploader: userId,
      type: "voice-message"
    });
    audioUrl = `/api/v1/upload/file/${key}`;
  }
  if (!messageText && !imageUrls.length && !audioUrl) {
    throw new AppError("\uBA54\uC2DC\uC9C0 \uB0B4\uC6A9\uC774 \uC5C6\uC2B5\uB2C8\uB2E4.", 400, "EMPTY_MESSAGE");
  }
  await execute(
    env2.DB,
    `INSERT INTO chat_message (
        room_id,
        user_id,
        message,
        audio_url,
        created_at,
        updated_at
      ) VALUES (?, ?, ?, ?, ?, ?)`,
    [roomId, userId, messageText ?? null, audioUrl, now, now]
  );
  const messageIdRow = await queryFirst(env2.DB, "SELECT last_insert_rowid() as id");
  const messageId = Number(messageIdRow?.id ?? 0);
  if (!messageId) {
    throw new AppError("\uBA54\uC2DC\uC9C0\uB97C \uC800\uC7A5\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.", 500, "CHAT_MESSAGE_CREATE_FAILED");
  }
  if (imageUrls.length) {
    for (const url2 of imageUrls) {
      await execute(
        env2.DB,
        `INSERT INTO chat_image (message_id, image_url, created_at, updated_at)
          VALUES (?, ?, ?, ?)`,
        [messageId, url2, now, now]
      );
    }
  }
  await execute(
    env2.DB,
    "UPDATE chat_room SET updated_at = ? WHERE room_id = ?",
    [now, roomId]
  );
  const messageRow = await queryFirst(
    env2.DB,
    `SELECT m.*, u.name, u.profile_image
       FROM chat_message m
       LEFT JOIN users u ON u.user_id = m.user_id
      WHERE m.message_id = ?
      LIMIT 1`,
    [messageId]
  );
  if (!messageRow) {
    throw new AppError("\uBA54\uC2DC\uC9C0\uB97C \uC870\uD68C\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.", 500, "CHAT_MESSAGE_LOAD_FAILED");
  }
  const images = await query(
    env2.DB,
    "SELECT message_id, image_url FROM chat_image WHERE message_id = ?",
    [messageId]
  );
  const files = await query(
    env2.DB,
    "SELECT * FROM chat_files WHERE message_id = ? AND is_deleted = 0",
    [messageId]
  );
  const mappedFiles = files.map(mapFile);
  const chatMessage = mapMessage(messageRow, images, mappedFiles);
  try {
    console.log("[createChatMessage] Sending notifications to room participants");
    const senderInfo = await queryFirst(
      env2.DB,
      "SELECT english_name, name FROM users WHERE user_id = ? LIMIT 1",
      [userId]
    );
    const senderName = senderInfo?.english_name || senderInfo?.name || "\uC775\uBA85\uC758 \uC0AC\uC6A9\uC790";
    const otherParticipants = await query(
      env2.DB,
      "SELECT user_id FROM chat_room_participant WHERE room_id = ? AND user_id != ?",
      [roomId, userId]
    );
    let contentPreview = messageText || "";
    if (!contentPreview && audioUrl) {
      contentPreview = "\uC74C\uC131 \uBA54\uC2DC\uC9C0";
    } else if (!contentPreview && imageUrls.length > 0) {
      contentPreview = "\uC774\uBBF8\uC9C0";
    }
    if (contentPreview.length > 50) {
      contentPreview = contentPreview.substring(0, 50) + "...";
    }
    for (const participant2 of otherParticipants) {
      try {
        await createNotification(env2, {
          userId: participant2.user_id,
          type: "CHAT_MESSAGE",
          title: `${room.room_name}`,
          content: `${senderName}: ${contentPreview}`,
          category: "chat",
          priority: 1,
          actionUrl: `/chat/${roomId}`,
          actionData: {
            roomId,
            messageId,
            senderId: userId,
            senderName
          },
          senderUserId: userId
        });
      } catch (notificationError) {
        console.error("[createChatMessage] Failed to send notification to participant:", {
          error: notificationError instanceof Error ? notificationError.message : String(notificationError),
          participantId: participant2.user_id
        });
      }
    }
    console.log("[createChatMessage] Notifications sent to", otherParticipants.length, "participants");
  } catch (notificationError) {
    console.error("[createChatMessage] Failed to send notifications:", {
      error: notificationError instanceof Error ? notificationError.message : String(notificationError),
      roomId,
      messageId
    });
  }
  return chatMessage;
}
__name(createChatMessage, "createChatMessage");
async function markRoomMessagesAsRead(env2, roomId, userId) {
  await ensureRoomExists(env2, roomId);
  const messageIds = await query(
    env2.DB,
    "SELECT message_id FROM chat_message WHERE room_id = ? AND user_id != ?",
    [roomId, userId]
  );
  if (!messageIds.length) {
    return;
  }
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const statements = messageIds.map(({ message_id }) => ({
    sql: `INSERT OR REPLACE INTO message_read_status (message_id, user_id, read_at, is_deleted, created_at, updated_at)
            VALUES (?, ?, ?, 0, ?, ?)`,
    params: [message_id, userId, now, now, now]
  }));
  await transaction(env2.DB, statements);
}
__name(markRoomMessagesAsRead, "markRoomMessagesAsRead");
async function getUnreadCountForRoom(env2, roomId, userId) {
  await ensureRoomExists(env2, roomId);
  const row = await queryFirst(
    env2.DB,
    `SELECT COUNT(*) as count
       FROM chat_message m
      WHERE m.room_id = ?
        AND m.user_id != ?
        AND m.message_id NOT IN (
          SELECT message_id FROM message_read_status
           WHERE user_id = ? AND is_deleted = 0
        )`,
    [roomId, userId, userId]
  );
  return row?.count ?? 0;
}
__name(getUnreadCountForRoom, "getUnreadCountForRoom");
async function getTotalUnreadCount(env2, userId) {
  const row = await queryFirst(
    env2.DB,
    `SELECT COUNT(*) as count
       FROM chat_message m
      WHERE m.user_id != ?
        AND m.message_id NOT IN (
          SELECT message_id FROM message_read_status WHERE user_id = ? AND is_deleted = 0
        )`,
    [userId, userId]
  );
  return row?.count ?? 0;
}
__name(getTotalUnreadCount, "getTotalUnreadCount");

// src/routes/chat.ts
var chatRoutes = new Hono2();
var requireAuth10 = auth();
function requireUserId3(userId) {
  if (!userId) {
    throw new AppError("\uC778\uC99D \uC815\uBCF4\uAC00 \uD544\uC694\uD569\uB2C8\uB2E4.", 401, "UNAUTHORIZED");
  }
  return userId;
}
__name(requireUserId3, "requireUserId");
function parseRoomId(raw2) {
  const roomId = Number(raw2);
  if (!Number.isFinite(roomId)) {
    throw new AppError("\uC720\uD6A8\uD558\uC9C0 \uC54A\uC740 roomId \uC785\uB2C8\uB2E4.", 400, "INVALID_ROOM_ID");
  }
  return roomId;
}
__name(parseRoomId, "parseRoomId");
chatRoutes.use("*", requireAuth10);
chatRoutes.get("/rooms", async (c) => {
  const userId = requireUserId3(c.get("userId"));
  const rooms = await listUserChatRooms(c.env, userId);
  return successResponse(c, rooms);
});
chatRoutes.get("/rooms/public", async (c) => {
  const userId = requireUserId3(c.get("userId"));
  const rooms = await listPublicChatRooms(c.env, userId);
  return successResponse(c, rooms);
});
chatRoutes.post("/rooms", async (c) => {
  const userId = requireUserId3(c.get("userId"));
  const body = await c.req.json().catch(() => ({}));
  const roomName = typeof body?.roomName === "string" ? body.roomName : "";
  const participantIds = Array.isArray(body?.participantIds) ? body.participantIds.filter((id) => typeof id === "string") : [];
  const isPublic = Boolean(body?.isPublic);
  const roomType = typeof body?.roomType === "string" ? body.roomType : void 0;
  const maxParticipants = typeof body?.maxParticipants === "number" ? Number(body.maxParticipants) : void 0;
  const room = await createChatRoom(c.env, userId, roomName, participantIds, {
    isPublic,
    roomType,
    maxParticipants
  });
  try {
    const hubId = c.env.CHAT_HUB.idFromName("global");
    const hubStub = c.env.CHAT_HUB.get(hubId);
    const publish = /* @__PURE__ */ __name((destination, payload, targetUserId) => hubStub.fetch("https://chat-hub/publish", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ destination, payload, userId: targetUserId })
    }), "publish");
    if (room.isPublic) {
      await publish("/sub/chat/public-rooms", room);
    }
    if (Array.isArray(room.participants)) {
      await Promise.all(
        room.participants.filter((participant) => participant.userId).map((participant) => publish("/user/queue/rooms", room, participant.userId))
      );
    }
  } catch (error48) {
    console.error("[chatRoutes] Failed to publish room creation event", error48);
  }
  return successResponse(c, room);
});
chatRoutes.post("/rooms/:roomId/join", async (c) => {
  const userId = requireUserId3(c.get("userId"));
  const roomId = parseRoomId(c.req.param("roomId"));
  const room = await joinChatRoom(c.env, roomId, userId);
  return successResponse(c, room);
});
chatRoutes.post("/rooms/:roomId/leave", async (c) => {
  const userId = requireUserId3(c.get("userId"));
  const roomId = parseRoomId(c.req.param("roomId"));
  await leaveChatRoom(c.env, roomId, userId);
  return successResponse(c, { success: true });
});
chatRoutes.get("/rooms/:roomId/messages", async (c) => {
  const userId = requireUserId3(c.get("userId"));
  const roomId = parseRoomId(c.req.param("roomId"));
  const page = Number(c.req.query("page") ?? "0");
  const size = Number(c.req.query("size") ?? "50");
  if (!Number.isFinite(page) || page < 0) {
    throw new AppError("page \uAC12\uC774 \uC62C\uBC14\uB974\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.", 400, "INVALID_PAGE_PARAM");
  }
  const perPage = Number.isFinite(size) && size > 0 ? Math.min(size, 200) : 50;
  const messages = await listRoomMessages(c.env, roomId, page, perPage);
  return successResponse(c, messages);
});
chatRoutes.get("/rooms/:roomId/messages/search", async (c) => {
  const userId = requireUserId3(c.get("userId"));
  const roomId = parseRoomId(c.req.param("roomId"));
  const keyword = c.req.query("keyword") ?? "";
  const page = Number(c.req.query("page") ?? "0");
  const size = Number(c.req.query("size") ?? "20");
  const perPage = Number.isFinite(size) && size > 0 ? Math.min(size, 100) : 20;
  const messages = await searchRoomMessages(c.env, roomId, keyword, page, perPage);
  return successResponse(c, messages);
});
chatRoutes.post("/rooms/:roomId/images", async (c) => {
  const userId = requireUserId3(c.get("userId"));
  const roomId = parseRoomId(c.req.param("roomId"));
  const formData = await c.req.formData();
  const entries = formData.getAll("files");
  const files = entries.filter((value) => typeof value === "object" && value !== null && "arrayBuffer" in value).map((value) => value);
  if (!files.length) {
    return successResponse(c, []);
  }
  const urls = await uploadChatImages(c.env, roomId, userId, files);
  return successResponse(c, urls);
});
chatRoutes.post("/upload/image", async (c) => {
  const userId = requireUserId3(c.get("userId"));
  const formData = await c.req.formData();
  const roomIdValue = formData.get("roomId");
  const roomId = typeof roomIdValue === "string" ? Number(roomIdValue) : Number(roomIdValue);
  if (!Number.isFinite(roomId)) {
    throw new AppError("roomId\uAC00 \uD544\uC694\uD569\uB2C8\uB2E4.", 400, "INVALID_ROOM_ID");
  }
  const fileEntry = formData.get("image") ?? formData.get("file");
  if (!fileEntry || typeof fileEntry !== "object" || !("arrayBuffer" in fileEntry)) {
    throw new AppError("\uC774\uBBF8\uC9C0 \uD30C\uC77C\uC774 \uD544\uC694\uD569\uB2C8\uB2E4.", 400, "IMAGE_FILE_REQUIRED");
  }
  const file2 = fileEntry;
  const urls = await uploadChatImages(c.env, roomId, userId, [file2]);
  const primary = urls.length > 0 ? urls[0] : null;
  return successResponse(c, { url: primary, urls });
});
chatRoutes.post("/rooms/:roomId/audio", async (c) => {
  const userId = requireUserId3(c.get("userId"));
  const roomId = parseRoomId(c.req.param("roomId"));
  const formData = await c.req.formData();
  const entry = formData.get("file");
  if (!entry || typeof entry !== "object" || !("arrayBuffer" in entry)) {
    throw new AppError("\uC624\uB514\uC624 \uD30C\uC77C\uC774 \uD544\uC694\uD569\uB2C8\uB2E4.", 400, "AUDIO_FILE_REQUIRED");
  }
  const file2 = entry;
  const url2 = await uploadChatAudio(c.env, roomId, userId, file2);
  return successResponse(c, url2);
});
chatRoutes.get("/files/my-files", async (c) => {
  const userId = requireUserId3(c.get("userId"));
  const files = await listMyChatFiles(c.env, userId);
  return successResponse(c, files);
});
chatRoutes.delete("/files/:fileId", async (c) => {
  const userId = requireUserId3(c.get("userId"));
  const fileId = Number(c.req.param("fileId"));
  if (!Number.isFinite(fileId)) {
    throw new AppError("\uD30C\uC77C ID\uAC00 \uC62C\uBC14\uB974\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.", 400, "INVALID_FILE_ID");
  }
  await deleteChatFile(c.env, userId, fileId);
  return successResponse(c, { success: true });
});
chatRoutes.post("/read-status/rooms/:roomId/read-all", async (c) => {
  const userId = requireUserId3(c.get("userId"));
  const roomId = parseRoomId(c.req.param("roomId"));
  await markRoomMessagesAsRead(c.env, roomId, userId);
  return successResponse(c, { success: true });
});
chatRoutes.get("/read-status/rooms/:roomId/unread-count", async (c) => {
  const userId = requireUserId3(c.get("userId"));
  const roomId = parseRoomId(c.req.param("roomId"));
  const count3 = await getUnreadCountForRoom(c.env, roomId, userId);
  return successResponse(c, count3);
});
chatRoutes.get("/read-status/total-unread-count", async (c) => {
  const userId = requireUserId3(c.get("userId"));
  const count3 = await getTotalUnreadCount(c.env, userId);
  return successResponse(c, count3);
});
var chat_default = chatRoutes;

// src/routes/settings.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_errors();
init_db();
var settingsRoutes = new Hono2();
var requireAuth11 = auth();
settingsRoutes.use("*", requireAuth11);
async function loadSettingsMap(env2, userId) {
  const rows = await query(
    env2.DB,
    "SELECT setting_key, setting_value FROM user_settings WHERE user_id = ?",
    [userId]
  );
  const map2 = /* @__PURE__ */ new Map();
  for (const row of rows) {
    if (row.setting_key) {
      map2.set(row.setting_key, row.setting_value ?? "");
    }
  }
  return map2;
}
__name(loadSettingsMap, "loadSettingsMap");
async function saveSettingsEntries(env2, userId, entries) {
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const statements = Object.entries(entries).filter(([_, value]) => value !== void 0).map(([key, value]) => ({
    sql: "INSERT OR REPLACE INTO user_settings (user_id, setting_key, setting_value, updated_at) VALUES (?, ?, ?, ?)",
    params: [userId, key, value === null ? null : String(value), now]
  }));
  if (statements.length === 0) return;
  await transaction(env2.DB, statements);
}
__name(saveSettingsEntries, "saveSettingsEntries");
async function deleteSettingsKeys(env2, userId, keys) {
  if (!keys.length) return;
  const placeholders = keys.map(() => "?").join(",");
  await execute(
    env2.DB,
    `DELETE FROM user_settings WHERE user_id = ? AND setting_key IN (${placeholders})`,
    [userId, ...keys]
  );
}
__name(deleteSettingsKeys, "deleteSettingsKeys");
function toBool(value, fallback = false) {
  if (value === void 0) return fallback;
  if (value === "true" || value === "1") return true;
  if (value === "false" || value === "0") return false;
  return fallback;
}
__name(toBool, "toBool");
settingsRoutes.get("/account", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const [profile3, settings] = await Promise.all([
    getUserProfile(c.env, userId),
    loadSettingsMap(c.env, userId)
  ]);
  if (!profile3) {
    throw new AppError("User not found", 404, "USER_NOT_FOUND");
  }
  return successResponse(c, {
    email: profile3.email ?? "",
    phoneNumber: settings.get("account.phoneNumber") ?? "",
    englishName: profile3.englishName ?? "",
    residence: settings.get("account.residence") ?? profile3.location?.country ?? "",
    profileImage: profile3.profileImage ?? null,
    bio: profile3.selfBio ?? "",
    birthDate: profile3.birthday ?? "",
    gender: profile3.gender ?? ""
  });
});
settingsRoutes.patch("/account", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  const profilePayload = {};
  if (typeof body.englishName === "string") profilePayload.englishName = body.englishName.trim();
  if (typeof body.bio === "string") profilePayload.selfBio = body.bio.trim();
  if (typeof body.birthDate === "string") profilePayload.birthday = body.birthDate;
  if (typeof body.gender === "string") profilePayload.gender = body.gender;
  if (typeof body.profileImage === "string" && body.profileImage.length > 0) {
    profilePayload.profileImage = body.profileImage;
  }
  if (Object.keys(profilePayload).length > 0) {
    await updateUserProfile(c.env, userId, profilePayload);
  }
  const entries = {};
  if (body.phoneNumber !== void 0) entries["account.phoneNumber"] = body.phoneNumber ? String(body.phoneNumber) : "";
  if (body.residence !== void 0) entries["account.residence"] = body.residence ? String(body.residence) : "";
  if (body.email !== void 0) entries["account.email"] = body.email ? String(body.email) : "";
  await saveSettingsEntries(c.env, userId, entries);
  if (body.email && typeof body.email === "string") {
    await execute(
      c.env.DB,
      "UPDATE users SET email = ?, updated_at = ? WHERE user_id = ?",
      [body.email.trim(), (/* @__PURE__ */ new Date()).toISOString(), userId]
    );
  }
  return successResponse(c, { success: true });
});
settingsRoutes.delete("/account", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  await execute(
    c.env.DB,
    "UPDATE users SET user_disable = 1, updated_at = ? WHERE user_id = ?",
    [(/* @__PURE__ */ new Date()).toISOString(), userId]
  );
  return successResponse(c, { disabled: true });
});
settingsRoutes.get("/notifications", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const settings = await getUserSettings(c.env, userId);
  const prefs = settings.notificationPreferences ?? {};
  return successResponse(c, {
    email: prefs.email ?? false,
    push: prefs.push ?? false,
    sms: prefs.sms ?? false
  });
});
settingsRoutes.patch("/notifications", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  const preferences = {};
  for (const key of ["email", "push", "sms"]) {
    if (body[key] !== void 0) {
      preferences[key] = Boolean(body[key]);
    }
  }
  await updateUserSettings(c.env, userId, { notificationPreferences: preferences });
  return successResponse(c, { success: true });
});
settingsRoutes.get("/privacy", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const map2 = await loadSettingsMap(c.env, userId);
  return successResponse(c, {
    profilePublic: toBool(map2.get("privacy.profilePublic"), true),
    showOnlineStatus: toBool(map2.get("privacy.showOnlineStatus"), true),
    allowMessages: toBool(map2.get("privacy.allowMessages"), true)
  });
});
settingsRoutes.patch("/privacy", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  const entries = {};
  if (body.profilePublic !== void 0) entries["privacy.profilePublic"] = String(Boolean(body.profilePublic));
  if (body.showOnlineStatus !== void 0) entries["privacy.showOnlineStatus"] = String(Boolean(body.showOnlineStatus));
  if (body.allowMessages !== void 0) entries["privacy.allowMessages"] = String(Boolean(body.allowMessages));
  await saveSettingsEntries(c.env, userId, entries);
  return successResponse(c, { success: true });
});
settingsRoutes.get("/language", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const settings = await getUserSettings(c.env, userId);
  return successResponse(c, {
    language: settings.language ?? "ko",
    timeZone: settings.timeZone ?? "Asia/Seoul"
  });
});
settingsRoutes.patch("/language", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  const payload = {};
  if (body.language !== void 0) payload.language = String(body.language);
  if (body.timeZone !== void 0) payload.timeZone = String(body.timeZone);
  if (body.marketingOptIn !== void 0) payload.marketingOptIn = Boolean(body.marketingOptIn);
  await updateUserSettings(c.env, userId, payload);
  return successResponse(c, { success: true });
});
settingsRoutes.patch("/password", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  if (typeof body.currentPassword !== "string" || typeof body.newPassword !== "string") {
    throw new AppError("currentPassword and newPassword are required", 400, "INVALID_PAYLOAD");
  }
  return successResponse(c, { success: true, message: "Password change acknowledged (no-op in worker)." });
});
settingsRoutes.post("/export", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const profile3 = await getUserProfile(c.env, userId);
  return successResponse(c, {
    exportedAt: (/* @__PURE__ */ new Date()).toISOString(),
    profile: profile3,
    sessions: [],
    messages: []
  });
});
settingsRoutes.get("/login-history", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const ninetyDaysAgo = /* @__PURE__ */ new Date();
  ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
  const history = await query(
    c.env.DB,
    `SELECT
      id,
      login_time,
      ip_address,
      device,
      browser,
      location,
      country_code,
      suspicious,
      suspicious_reason,
      success
    FROM login_history
    WHERE user_id = ? AND login_time >= ? AND success = 1
    ORDER BY login_time DESC
    LIMIT 100`,
    [userId, ninetyDaysAgo.toISOString()]
  );
  const formattedHistory = history.map((record2) => ({
    loginTime: record2.login_time,
    ipAddress: record2.ip_address || "Unknown",
    device: record2.device || "Unknown Device",
    browser: record2.browser || null,
    location: record2.location || "Unknown Location",
    countryCode: record2.country_code || null,
    suspicious: Boolean(record2.suspicious),
    suspiciousReason: record2.suspicious_reason || null
  }));
  return successResponse(c, formattedHistory);
});
settingsRoutes.get("/two-factor", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const map2 = await loadSettingsMap(c.env, userId);
  const pending = map2.get("security.twoFactor.setup");
  return successResponse(c, {
    enabled: toBool(map2.get("security.twoFactor.enabled"), false),
    qrCode: pending ? map2.get("security.twoFactor.qrCode") ?? null : null
  });
});
settingsRoutes.post("/two-factor/enable", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const secret = crypto.randomUUID().replace(/-/g, "").slice(0, 16).toUpperCase();
  const otpauth = `otpauth://totp/StudyMate:${userId}?secret=${secret}&issuer=StudyMate`;
  await saveSettingsEntries(c.env, userId, {
    "security.twoFactor.setup": "pending",
    "security.twoFactor.secret": secret,
    "security.twoFactor.qrCode": otpauth
  });
  return successResponse(c, { qrCode: otpauth });
});
settingsRoutes.post("/two-factor/disable", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User id missing from context", 500, "CONTEXT_MISSING_USER");
  const body = await c.req.json().catch(() => ({}));
  const map2 = await loadSettingsMap(c.env, userId);
  if (map2.get("security.twoFactor.setup") === "pending") {
    await saveSettingsEntries(c.env, userId, { "security.twoFactor.enabled": "true" });
    await deleteSettingsKeys(c.env, userId, ["security.twoFactor.setup", "security.twoFactor.qrCode"]);
    return successResponse(c, { success: true, enabled: true, verified: true });
  }
  await saveSettingsEntries(c.env, userId, { "security.twoFactor.enabled": "false" });
  await deleteSettingsKeys(c.env, userId, ["security.twoFactor.secret", "security.twoFactor.qrCode"]);
  return successResponse(c, { success: true, enabled: false });
});
var settings_default = settingsRoutes;

// src/routes/pronunciation.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_errors();

// src/services/pronunciationEvaluation.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function analyzePhonemes(ai, transcription, targetLanguage = "English") {
  const messages = [
    {
      role: "system",
      content: `You are an expert phonetician specializing in ${targetLanguage} pronunciation analysis. Analyze the transcribed speech and identify phoneme-level pronunciation issues.

Respond in JSON format:
{
  "phonemes": [
    {
      "phoneme": "\u03B8",
      "word": "think",
      "position": 0,
      "accuracy": 65,
      "issues": ["fronting - pronounced as /s/ or /t/"],
      "nativeSample": "\u03B8",
      "userPronunciation": "s"
    }
  ]
}`
    },
    {
      role: "user",
      content: `Analyze the phonemes in this speech transcription:

"${transcription}"

Identify commonly mispronounced phonemes, especially:
- Consonant clusters
- Th-sounds (\u03B8, \xF0)
- R and L sounds
- Vowel quality
- Final consonants

Provide accuracy scores and specific issues for each problematic phoneme.`
    }
  ];
  try {
    const response = await generateChatCompletion(ai, messages, {
      model: "@cf/meta/llama-3.3-70b-instruct-fp8-fast",
      temperature: 0.3,
      max_tokens: 1500
    });
    const sanitized = sanitizeJsonResponse(response);
    const parsed = JSON.parse(sanitized);
    if (Array.isArray(parsed.phonemes)) {
      return parsed.phonemes.map((p) => ({
        phoneme: p.phoneme || "",
        word: p.word || "",
        position: p.position || 0,
        accuracy: typeof p.accuracy === "number" ? p.accuracy : 50,
        issues: Array.isArray(p.issues) ? p.issues : [],
        nativeSample: p.nativeSample,
        userPronunciation: p.userPronunciation
      }));
    }
    return [];
  } catch (error48) {
    log3.error("Failed to analyze phonemes:", error48);
    return [];
  }
}
__name(analyzePhonemes, "analyzePhonemes");
async function analyzeIntonation(ai, transcription, targetLanguage = "English") {
  const messages = [
    {
      role: "system",
      content: `You are an expert in ${targetLanguage} intonation patterns. Analyze the speech and identify intonation patterns for each sentence.

Respond in JSON format:
{
  "patterns": [
    {
      "type": "rising",
      "sentenceType": "question",
      "isCorrect": true,
      "expectedPattern": "rising at end",
      "detectedPattern": "rising at end",
      "confidence": 85
    }
  ]
}`
    },
    {
      role: "user",
      content: `Analyze intonation patterns in this transcription:

"${transcription}"

For each sentence, identify:
- Intonation type (rising, falling, level, fall-rise, rise-fall)
- Sentence type (statement, question, command, exclamation)
- Whether the pattern matches the sentence type
- Confidence level`
    }
  ];
  try {
    const response = await generateChatCompletion(ai, messages, {
      model: "@cf/meta/llama-3.3-70b-instruct-fp8-fast",
      temperature: 0.3,
      max_tokens: 1200
    });
    const sanitized = sanitizeJsonResponse(response);
    const parsed = JSON.parse(sanitized);
    if (Array.isArray(parsed.patterns)) {
      return parsed.patterns.map((p) => ({
        type: p.type || "level",
        sentenceType: p.sentenceType || "statement",
        isCorrect: p.isCorrect !== false,
        expectedPattern: p.expectedPattern || "",
        detectedPattern: p.detectedPattern || "",
        confidence: typeof p.confidence === "number" ? p.confidence : 50
      }));
    }
    return [];
  } catch (error48) {
    log3.error("Failed to analyze intonation:", error48);
    return [];
  }
}
__name(analyzeIntonation, "analyzeIntonation");
async function analyzeRhythm(ai, transcription, targetLanguage = "English") {
  const messages = [
    {
      role: "system",
      content: `You are an expert in ${targetLanguage} speech rhythm analysis. Analyze the rhythm, stress patterns, and speaking rate.

Respond in JSON format:
{
  "syllableCount": 45,
  "stressPattern": "1001010010",
  "expectedStress": "1001010010",
  "rhythmType": "stress-timed",
  "isNaturalRhythm": true,
  "pauseLocations": [5, 12, 20],
  "speakingRate": 180,
  "consistency": 75
}`
    },
    {
      role: "user",
      content: `Analyze the rhythm in this speech:

"${transcription}"

Determine:
- Total syllable count
- Stress pattern (1=stressed, 0=unstressed syllables)
- Expected stress pattern for natural speech
- Rhythm type (stress-timed for English)
- Natural pause locations
- Speaking rate (syllables per minute)
- Rhythm consistency (0-100)`
    }
  ];
  try {
    const response = await generateChatCompletion(ai, messages, {
      model: "@cf/meta/llama-3.3-70b-instruct-fp8-fast",
      temperature: 0.3,
      max_tokens: 1e3
    });
    const sanitized = sanitizeJsonResponse(response);
    const parsed = JSON.parse(sanitized);
    return {
      syllableCount: parsed.syllableCount || 0,
      stressPattern: parsed.stressPattern || "",
      expectedStress: parsed.expectedStress || "",
      rhythmType: parsed.rhythmType || "stress-timed",
      isNaturalRhythm: parsed.isNaturalRhythm !== false,
      pauseLocations: Array.isArray(parsed.pauseLocations) ? parsed.pauseLocations : [],
      speakingRate: parsed.speakingRate || 150,
      consistency: typeof parsed.consistency === "number" ? parsed.consistency : 50
    };
  } catch (error48) {
    log3.error("Failed to analyze rhythm:", error48);
    return {
      syllableCount: 0,
      stressPattern: "",
      expectedStress: "",
      rhythmType: "stress-timed",
      isNaturalRhythm: false,
      pauseLocations: [],
      speakingRate: 150,
      consistency: 50
    };
  }
}
__name(analyzeRhythm, "analyzeRhythm");
async function analyzeStress(ai, transcription, targetLanguage = "English") {
  const messages = [
    {
      role: "system",
      content: `You are an expert in ${targetLanguage} word and sentence stress. Analyze stress placement at word and sentence levels.

Respond in JSON format:
{
  "wordStresses": [
    {
      "word": "important",
      "expectedStress": 1,
      "detectedStress": 1,
      "isCorrect": true,
      "syllableCount": 3
    }
  ],
  "sentenceStress": {
    "contentWords": ["important", "meeting", "tomorrow"],
    "functionWords": ["the", "is", "at"],
    "correctlyStressed": 8,
    "totalContentWords": 10
  },
  "overallAccuracy": 80
}`
    },
    {
      role: "user",
      content: `Analyze stress patterns in this speech:

"${transcription}"

Identify:
- Word-level stress for multi-syllable words
- Content words that should receive sentence stress
- Function words that should be reduced
- Overall stress accuracy`
    }
  ];
  try {
    const response = await generateChatCompletion(ai, messages, {
      model: "@cf/meta/llama-3.3-70b-instruct-fp8-fast",
      temperature: 0.3,
      max_tokens: 1500
    });
    const sanitized = sanitizeJsonResponse(response);
    const parsed = JSON.parse(sanitized);
    return {
      wordStresses: Array.isArray(parsed.wordStresses) ? parsed.wordStresses : [],
      sentenceStress: {
        contentWords: Array.isArray(parsed.sentenceStress?.contentWords) ? parsed.sentenceStress.contentWords : [],
        functionWords: Array.isArray(parsed.sentenceStress?.functionWords) ? parsed.sentenceStress.functionWords : [],
        correctlyStressed: parsed.sentenceStress?.correctlyStressed || 0,
        totalContentWords: parsed.sentenceStress?.totalContentWords || 0
      },
      overallAccuracy: typeof parsed.overallAccuracy === "number" ? parsed.overallAccuracy : 50
    };
  } catch (error48) {
    log3.error("Failed to analyze stress:", error48);
    return {
      wordStresses: [],
      sentenceStress: {
        contentWords: [],
        functionWords: [],
        correctlyStressed: 0,
        totalContentWords: 0
      },
      overallAccuracy: 50
    };
  }
}
__name(analyzeStress, "analyzeStress");
async function classifyPronunciationErrors(ai, transcription, phonemeAnalysis) {
  if (phonemeAnalysis.length === 0) {
    return [];
  }
  const messages = [
    {
      role: "system",
      content: `You are an expert in pronunciation error analysis. Classify pronunciation errors and provide corrective suggestions.

Respond in JSON format:
{
  "errors": [
    {
      "type": "substitution",
      "phoneme": "\u03B8",
      "word": "think",
      "position": 0,
      "severity": "major",
      "suggestion": "Place tongue between teeth and blow air",
      "example": "Try: 'thin', 'thick', 'thank'"
    }
  ]
}`
    },
    {
      role: "user",
      content: `Classify these pronunciation issues and provide corrections:

Transcription: "${transcription}"

Phoneme issues: ${JSON.stringify(phonemeAnalysis.slice(0, 10))}

For each error, determine:
- Error type (substitution, omission, insertion, distortion)
- Severity (critical, major, minor)
- Specific correction suggestion
- Practice examples`
    }
  ];
  try {
    const response = await generateChatCompletion(ai, messages, {
      model: "@cf/meta/llama-3.3-70b-instruct-fp8-fast",
      temperature: 0.3,
      max_tokens: 1500
    });
    const sanitized = sanitizeJsonResponse(response);
    const parsed = JSON.parse(sanitized);
    if (Array.isArray(parsed.errors)) {
      return parsed.errors.map((e) => ({
        type: e.type || "substitution",
        phoneme: e.phoneme || "",
        word: e.word || "",
        position: e.position || 0,
        severity: e.severity || "minor",
        suggestion: e.suggestion || "",
        example: e.example || ""
      }));
    }
    return [];
  } catch (error48) {
    log3.error("Failed to classify pronunciation errors:", error48);
    return [];
  }
}
__name(classifyPronunciationErrors, "classifyPronunciationErrors");
async function generateRecommendations(ai, evaluation) {
  const messages = [
    {
      role: "system",
      content: `You are a pronunciation coach. Generate personalized improvement recommendations.

Respond in JSON format:
{
  "recommendations": [
    {
      "priority": "high",
      "category": "Consonant Sounds",
      "description": "Focus on 'th' sounds",
      "exercises": [
        "Practice minimal pairs: think/sink, thick/sick",
        "Tongue placement drills",
        "Record and compare with native speaker"
      ]
    }
  ]
}`
    },
    {
      role: "user",
      content: `Based on this pronunciation analysis, generate improvement recommendations:

Overall Score: ${evaluation.overallScore || 0}/100
Segmental Score: ${evaluation.scores?.segmental || 0}/100
Suprasegmental Score: ${evaluation.scores?.suprasegmental || 0}/100

Main issues:
${evaluation.errors?.slice(0, 5).map((e) => `- ${e.phoneme} in "${e.word}": ${e.suggestion}`).join("\n") || "None identified"}

Weaknesses:
${evaluation.weaknesses?.join(", ") || "None identified"}

Generate 3-5 prioritized recommendations with specific exercises.`
    }
  ];
  try {
    const response = await generateChatCompletion(ai, messages, {
      model: "@cf/meta/llama-3.3-70b-instruct-fp8-fast",
      temperature: 0.7,
      max_tokens: 1200
    });
    const sanitized = sanitizeJsonResponse(response);
    const parsed = JSON.parse(sanitized);
    if (Array.isArray(parsed.recommendations)) {
      return parsed.recommendations.map((r) => ({
        priority: r.priority || "medium",
        category: r.category || "",
        description: r.description || "",
        exercises: Array.isArray(r.exercises) ? r.exercises : []
      }));
    }
    return [];
  } catch (error48) {
    log3.error("Failed to generate recommendations:", error48);
    return [];
  }
}
__name(generateRecommendations, "generateRecommendations");
async function performComprehensivePronunciationEvaluation(ai, transcription, targetLanguage = "English") {
  const [
    phonemeAnalysis,
    intonationPatterns,
    rhythmAnalysis,
    stressAnalysis
  ] = await Promise.all([
    analyzePhonemes(ai, transcription, targetLanguage),
    analyzeIntonation(ai, transcription, targetLanguage),
    analyzeRhythm(ai, transcription, targetLanguage),
    analyzeStress(ai, transcription, targetLanguage)
  ]);
  const errors = await classifyPronunciationErrors(ai, transcription, phonemeAnalysis);
  const segmentalScore = phonemeAnalysis.length > 0 ? Math.round(phonemeAnalysis.reduce((sum, p) => sum + p.accuracy, 0) / phonemeAnalysis.length) : 70;
  const intonationScore = intonationPatterns.length > 0 ? Math.round(intonationPatterns.filter((p) => p.isCorrect).length / intonationPatterns.length * 100) : 70;
  const rhythmScore = rhythmAnalysis.consistency;
  const stressScore = stressAnalysis.overallAccuracy;
  const suprasegmentalScore = Math.round(
    (intonationScore + rhythmScore + stressScore) / 3
  );
  const overallScore = Math.round(
    segmentalScore * 0.4 + //  40%
    suprasegmentalScore * 0.35 + //  35%
    stressScore * 0.15 + //  15%
    intonationScore * 0.1
    //  10%
  );
  const intelligibility = Math.round(
    segmentalScore * 0.6 + suprasegmentalScore * 0.4
  );
  const fluency = Math.round(
    (rhythmScore + Math.min(rhythmAnalysis.speakingRate / 180 * 100, 100)) / 2
  );
  const nativelikeness = Math.round(
    (segmentalScore + suprasegmentalScore + stressScore) / 3 * 0.8
    //  80
  );
  let cefrLevel = "A1";
  if (overallScore >= 90) cefrLevel = "C2";
  else if (overallScore >= 80) cefrLevel = "C1";
  else if (overallScore >= 70) cefrLevel = "B2";
  else if (overallScore >= 60) cefrLevel = "B1";
  else if (overallScore >= 45) cefrLevel = "A2";
  const strengths = [];
  const weaknesses = [];
  if (segmentalScore >= 80) strengths.push("Clear individual sound production");
  else if (segmentalScore < 60) weaknesses.push("Individual sound accuracy needs improvement");
  if (suprasegmentalScore >= 80) strengths.push("Natural intonation and rhythm");
  else if (suprasegmentalScore < 60) weaknesses.push("Prosody and speech melody need work");
  if (stressScore >= 80) strengths.push("Good word and sentence stress");
  else if (stressScore < 60) weaknesses.push("Stress placement needs attention");
  if (rhythmAnalysis.isNaturalRhythm) strengths.push("Natural speaking rhythm");
  else weaknesses.push("Speaking rhythm is not yet natural");
  const partialEval = {
    overallScore,
    scores: {
      segmental: segmentalScore,
      suprasegmental: suprasegmentalScore,
      intelligibility,
      fluency,
      nativelikeness
    },
    errors,
    weaknesses
  };
  const recommendations = await generateRecommendations(ai, partialEval);
  const nextLevelRequirements = [];
  if (cefrLevel === "A1") {
    nextLevelRequirements.push("Master basic consonant and vowel sounds");
    nextLevelRequirements.push("Develop consistent word stress");
    nextLevelRequirements.push("Practice basic intonation patterns");
  } else if (cefrLevel === "A2") {
    nextLevelRequirements.push("Improve difficult consonant clusters");
    nextLevelRequirements.push("Refine sentence stress and rhythm");
    nextLevelRequirements.push("Develop natural intonation for questions");
  } else if (cefrLevel === "B1") {
    nextLevelRequirements.push("Perfect problematic phonemes (e.g., th, r, l)");
    nextLevelRequirements.push("Master connected speech and linking");
    nextLevelRequirements.push("Improve speech flow and naturalness");
  } else if (cefrLevel === "B2") {
    nextLevelRequirements.push("Refine subtle pronunciation differences");
    nextLevelRequirements.push("Develop more native-like prosody");
    nextLevelRequirements.push("Reduce L1 interference in all contexts");
  } else if (cefrLevel === "C1") {
    nextLevelRequirements.push("Perfect pronunciation in all contexts");
    nextLevelRequirements.push("Master regional variations and nuances");
    nextLevelRequirements.push("Achieve near-native fluency and naturalness");
  }
  return {
    overallScore,
    scores: {
      segmental: segmentalScore,
      suprasegmental: suprasegmentalScore,
      intelligibility,
      fluency,
      nativelikeness
    },
    phonemeAnalysis,
    intonationPatterns,
    rhythmAnalysis,
    stressAnalysis,
    errors,
    recommendations,
    strengths,
    weaknesses,
    cefrLevel,
    nextLevelRequirements
  };
}
__name(performComprehensivePronunciationEvaluation, "performComprehensivePronunciationEvaluation");

// src/routes/pronunciation.ts
var pronunciationRoutes = new Hono2();
var requireAuth12 = auth();
pronunciationRoutes.use("*", requireAuth12);
pronunciationRoutes.post("/evaluate", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  try {
    const formData = await c.req.formData();
    const audioFile = formData.get("audio");
    const targetLanguage = formData.get("targetLanguage") || "English";
    const expectedText = formData.get("text");
    if (!audioFile) {
      throw new AppError("Audio file is required", 400, "MISSING_AUDIO");
    }
    const audioBuffer = await audioFile.arrayBuffer();
    const transcription = await processAudio(c.env.AI, audioBuffer, {
      language: targetLanguage.toLowerCase() === "english" ? "en" : targetLanguage.toLowerCase() === "korean" ? "ko" : void 0
    });
    if (!transcription?.text) {
      throw new AppError("Failed to transcribe audio", 500, "TRANSCRIPTION_FAILED");
    }
    const evaluation = await performComprehensivePronunciationEvaluation(
      c.env.AI,
      transcription.text,
      targetLanguage
    );
    return successResponse(c, {
      transcription: transcription.text,
      expectedText: expectedText || null,
      evaluation
    });
  } catch (error48) {
    if (error48 instanceof AppError) {
      throw error48;
    }
    throw new AppError(
      error48 instanceof Error ? error48.message : "Pronunciation evaluation failed",
      500,
      "PRONUNCIATION_EVAL_FAILED"
    );
  }
});
pronunciationRoutes.post("/evaluate-text", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  try {
    const body = await c.req.json();
    if (!body.transcription || typeof body.transcription !== "string") {
      throw new AppError("Transcription text is required", 400, "MISSING_TRANSCRIPTION");
    }
    const targetLanguage = body.targetLanguage || "English";
    const evaluation = await performComprehensivePronunciationEvaluation(
      c.env.AI,
      body.transcription,
      targetLanguage
    );
    return successResponse(c, {
      transcription: body.transcription,
      evaluation
    });
  } catch (error48) {
    if (error48 instanceof AppError) {
      throw error48;
    }
    throw new AppError(
      error48 instanceof Error ? error48.message : "Pronunciation evaluation failed",
      500,
      "PRONUNCIATION_EVAL_FAILED"
    );
  }
});
pronunciationRoutes.get("/phonemes/:language", async (c) => {
  const userId = c.get("userId");
  if (!userId) throw new AppError("User not found in context", 500, "CONTEXT_MISSING_USER");
  const language = c.req.param("language");
  const phonemeGuides = {
    english: {
      language: "English",
      phonemes: [
        {
          symbol: "\u03B8",
          description: 'Voiceless dental fricative (as in "think")',
          examples: ["think", "\u062B", "thank", "three"],
          tips: "Place tongue between teeth and blow air"
        },
        {
          symbol: "\xF0",
          description: 'Voiced dental fricative (as in "this")',
          examples: ["this", "that", "they", "though"],
          tips: "Like \u03B8 but with voice"
        },
        {
          symbol: "r",
          description: "Alveolar approximant",
          examples: ["red", "right", "royal", "around"],
          tips: "Curl tongue slightly back, do not trill"
        },
        {
          symbol: "l",
          description: "Alveolar lateral approximant",
          examples: ["light", "love", "full", "all"],
          tips: "Touch tongue to alveolar ridge"
        }
      ]
    },
    korean: {
      language: "Korean",
      phonemes: [
        {
          symbol: "\u3131/\u314B/\u3132",
          description: "Plain/Aspirated/Tense k sounds",
          examples: ["\uAC00\uB2E4", "\uCE74\uB4DC", "\uAE4C\uB2E4"],
          tips: "Distinguish between plain, aspirated, and tense"
        }
      ]
    }
  };
  const guide = phonemeGuides[language.toLowerCase()];
  if (!guide) {
    throw new AppError("Phoneme guide not available for this language", 404, "LANGUAGE_NOT_SUPPORTED");
  }
  return successResponse(c, guide);
});
var pronunciation_default = pronunciationRoutes;

// src/durable/WebRTCRoom.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { DurableObject } from "cloudflare:workers";
var WebRTCRoom = class extends DurableObject {
  static {
    __name(this, "WebRTCRoom");
  }
  constructor(state, env2) {
    super(state, env2);
    this.env = env2;
    this.roomId = state.id.toString();
    this.roomData = {
      id: this.roomId,
      participants: [],
      maxParticipants: 4,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      type: "audio",
      metadata: {},
      settings: {
        allowScreenShare: true,
        allowRecording: false,
        autoMuteOnJoin: false,
        stunServers: [
          { urls: "stun:stun1.l.google.com:19302" },
          { urls: "stun:stun2.l.google.com:19302" },
          { urls: "stun.cloudflare.com:3478" }
        ],
        turnServers: [
          {
            urls: "turn:openrelay.metered.ca:80",
            username: "openrelayproject",
            credential: "openrelayproject"
          },
          {
            urls: "turn:openrelay.metered.ca:443",
            username: "openrelayproject",
            credential: "openrelayproject"
          },
          {
            urls: "turn:freestun.net:3478",
            username: "free",
            credential: "free"
          }
        ],
        recordingSettings: {
          enabled: true,
          autoStart: false,
          maxDuration: 60,
          // 1
          format: "webm",
          quality: "medium",
          audioOnly: false
        }
      },
      metrics: {
        totalParticipants: 0,
        peakParticipants: 0,
        messagesExchanged: 0,
        connectionErrors: 0,
        lastActivity: (/* @__PURE__ */ new Date()).toISOString(),
        sessionDuration: 0
      }
    };
    this.restoreParticipants();
  }
  async fetch(request) {
    const url2 = new URL(request.url);
    if (request.headers.get("Upgrade") === "websocket") {
      return this.handleWebSocket(request);
    }
    switch (url2.pathname) {
      case "/init":
        return this.handleInit(request);
      case "/join":
        return this.handleJoin(request);
      case "/leave":
        return this.handleLeave(request);
      case "/info":
        return this.handleInfo();
      case "/settings":
        return this.handleSettings(request);
      case "/metadata":
        return this.handleMetadata(request);
      case "/ice-servers":
        return this.handleIceServers();
      case "/metrics":
        return this.handleMetrics();
      default:
        return new Response("Not Found", { status: 404 });
    }
  }
  async handleWebSocket(request) {
    const url2 = new URL(request.url);
    const userId = url2.searchParams.get("userId");
    const userName = url2.searchParams.get("userName") || "Anonymous";
    if (!userId) {
      return new Response("Missing userId parameter", { status: 400 });
    }
    const activeParticipants = this.getActiveParticipants();
    if (activeParticipants.length >= this.roomData.maxParticipants) {
      return new Response(JSON.stringify({ error: "Room is full" }), {
        status: 400,
        headers: { "Content-Type": "application/json" }
      });
    }
    const pair = new WebSocketPair();
    const [client, server] = Object.values(pair);
    const userData = {
      userId,
      userName,
      joinedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    server.serializeAttachment(userData);
    this.ctx.acceptWebSocket(server, [userId]);
    const participant = {
      id: userId,
      name: userName,
      joinedAt: userData.joinedAt,
      audioEnabled: true,
      videoEnabled: this.roomData.type === "video",
      isScreenSharing: false
    };
    this.roomData.participants.push(participant);
    this.updateMetrics("join");
    await this.saveRoomData();
    await this.syncActiveRoomCache();
    await this.sendAnalytics("participant_joined", {
      userId,
      userName,
      totalParticipants: this.roomData.participants.length,
      roomType: this.roomData.type
    });
    server.send(JSON.stringify({
      type: "connected",
      roomData: this.roomData,
      userId
    }));
    this.broadcast({
      type: "participant-joined",
      participant
    }, userId);
    return new Response(null, { status: 101, webSocket: client });
  }
  async handleInit(request) {
    try {
      const { roomType = "audio", maxParticipants = 4, metadata = {} } = await request.json();
      this.roomData.type = roomType;
      this.roomData.maxParticipants = maxParticipants;
      this.roomData.createdAt = (/* @__PURE__ */ new Date()).toISOString();
      this.roomData.metadata = metadata || {};
      await this.saveRoomData();
      await this.syncActiveRoomCache();
      return new Response(JSON.stringify({
        success: true,
        roomId: this.roomId,
        roomType,
        maxParticipants,
        metadata,
        createdAt: this.roomData.createdAt
      }), {
        headers: { "Content-Type": "application/json" }
      });
    } catch (error48) {
      log3.error("Init error", error48, void 0, { component: "WEBRTC_ROOM" });
      return new Response(JSON.stringify({
        error: "Failed to initialize room"
      }), {
        status: 500,
        headers: { "Content-Type": "application/json" }
      });
    }
  }
  async handleJoin(request) {
    try {
      const { userId, userName, roomType } = await request.json();
      const existingParticipant = this.roomData.participants.find((p) => p.id === userId);
      if (existingParticipant) {
        return new Response(JSON.stringify({
          success: true,
          roomData: this.roomData,
          message: "Already in room"
        }), {
          headers: { "Content-Type": "application/json" }
        });
      }
      const activeParticipants = this.getActiveParticipants();
      if (activeParticipants.length >= this.roomData.maxParticipants) {
        return new Response(JSON.stringify({
          error: "Room is full"
        }), {
          status: 400,
          headers: { "Content-Type": "application/json" }
        });
      }
      if (roomType && this.roomData.participants.length === 0) {
        this.roomData.type = roomType;
      }
      await this.saveRoomData();
      return new Response(JSON.stringify({
        success: true,
        roomData: this.roomData,
        websocketUrl: `/room/${this.roomId}/websocket?userId=${userId}&userName=${encodeURIComponent(userName)}`
      }), {
        headers: { "Content-Type": "application/json" }
      });
    } catch (error48) {
      log3.error("Join error", error48, void 0, { component: "WEBRTC_ROOM" });
      return new Response(JSON.stringify({
        error: "Failed to join room"
      }), {
        status: 500,
        headers: { "Content-Type": "application/json" }
      });
    }
  }
  async handleLeave(request) {
    try {
      const { userId } = await request.json();
      await this.handleParticipantLeave(userId);
      return new Response(JSON.stringify({ success: true }));
    } catch (error48) {
      log3.error("Leave error", error48, void 0, { component: "WEBRTC_ROOM" });
      return new Response(JSON.stringify({
        error: "Failed to leave room"
      }), { status: 500 });
    }
  }
  async handleSignal(request) {
    try {
      const { from, to, signal } = await request.json();
      const websockets = this.ctx.getWebSockets(to);
      websockets.forEach((ws) => {
        try {
          ws.send(JSON.stringify({ type: "signal", from, signal }));
        } catch (e) {
          log3.error("Signal forward error", e, void 0, { component: "WEBRTC_ROOM" });
        }
      });
      return new Response(JSON.stringify({ success: true }));
    } catch (error48) {
      log3.error("Signal error", error48, void 0, { component: "WEBRTC_ROOM" });
      return new Response(JSON.stringify({
        error: "Failed to send signal"
      }), { status: 500 });
    }
  }
  async handleInfo() {
    const roomData = await this.ctx.storage.get("roomData") || this.roomData;
    return new Response(JSON.stringify(roomData));
  }
  // WebSocket Hibernation API event handlers
  async webSocketMessage(ws, message) {
    try {
      const userData = ws.deserializeAttachment();
      if (!userData) {
        ws.close(1008, "User data not found");
        return;
      }
      const msg = typeof message === "string" ? JSON.parse(message) : null;
      if (!msg) return;
      await this.handleWebSocketMessage(ws, userData.userId, msg);
    } catch (error48) {
      log3.error("WebSocket message error", error48, void 0, { component: "WEBRTC_ROOM" });
      this.updateMetrics("error");
      await this.sendAnalytics("websocket_error", { error: String(error48) });
      ws.send(JSON.stringify({
        type: "error",
        message: "Invalid message format"
      }));
    }
  }
  async webSocketClose(ws, code, reason, wasClean) {
    const userData = ws.deserializeAttachment();
    if (userData) {
      await this.handleParticipantLeave(userData.userId);
    }
  }
  async webSocketError(ws, error48) {
    log3.error("WebSocket error", error48, void 0, { component: "WEBRTC_ROOM" });
    this.updateMetrics("error");
    await this.sendAnalytics("websocket_connection_error", { error: String(error48) });
    const userData = ws.deserializeAttachment();
    if (userData) {
      await this.handleParticipantLeave(userData.userId);
    }
  }
  async handleWebSocketMessage(ws, userId, message) {
    const { type, data } = message;
    this.updateMetrics("message");
    switch (type) {
      case "offer":
      case "answer":
      case "ice-candidate":
        if (data.to) {
          this.sendToParticipant(data.to, {
            type,
            from: userId,
            data: data.signal || data
          });
        }
        break;
      case "toggle-audio":
        await this.updateParticipantStatus(userId, { audioEnabled: data.enabled });
        break;
      case "toggle-video":
        await this.updateParticipantStatus(userId, { videoEnabled: data.enabled });
        break;
      case "toggle-screen-share":
        await this.updateParticipantStatus(userId, { isScreenSharing: data.enabled });
        this.broadcast({
          type: "screen-share-changed",
          userId,
          isSharing: data.enabled
        }, userId);
        break;
      case "chat":
        this.broadcast({
          type: "chat",
          from: userId,
          message: data.message,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        break;
      case "start-recording":
        if (this.roomData.settings.allowRecording && this.roomData.settings.recordingSettings?.enabled) {
          this.broadcast({
            type: "recording-started",
            initiatedBy: userId,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            settings: this.roomData.settings.recordingSettings
          });
          await this.sendAnalytics("recording_started", { userId });
        }
        break;
      case "stop-recording":
        this.broadcast({
          type: "recording-stopped",
          stoppedBy: userId,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        await this.sendAnalytics("recording_stopped", { userId });
        break;
      case "recording-chunk":
        await this.handleRecordingChunk(userId, data);
        break;
      case "quality-report":
        await this.handleQualityReport(userId, data);
        break;
      case "ping":
        ws.send(JSON.stringify({ type: "pong" }));
        break;
      default:
        log3.warn("Unknown message type", { component: "WEBRTC_ROOM" }, { type });
    }
  }
  async updateParticipantStatus(userId, updates) {
    const participant = this.roomData.participants.find((p) => p.id === userId);
    if (participant) {
      Object.assign(participant, updates);
      await this.saveRoomData();
      this.broadcast({
        type: "participant-updated",
        participant
      });
    }
  }
  async handleParticipantLeave(userId) {
    const participantIndex = this.roomData.participants.findIndex((p) => p.id === userId);
    if (participantIndex === -1) return;
    this.roomData.participants.splice(participantIndex, 1);
    this.updateMetrics("leave");
    await this.saveRoomData();
    await this.syncActiveRoomCache();
    await this.sendAnalytics("participant_left", {
      userId,
      remainingParticipants: this.roomData.participants.length,
      sessionDuration: this.roomData.metrics.sessionDuration
    });
    this.broadcast({
      type: "participant-left",
      userId
    });
    const activeParticipants = this.getActiveParticipants();
    if (activeParticipants.length === 0) {
      const cleanupTime = Date.now() + 6e4;
      await this.ctx.storage.setAlarm(cleanupTime);
    }
  }
  // Handle alarm for room cleanup
  async alarm() {
    const activeParticipants = this.getActiveParticipants();
    if (activeParticipants.length === 0) {
      await this.ctx.storage.deleteAll();
      await this.syncActiveRoomCache({ forceRemove: true });
    }
  }
  async handleSettings(request) {
    if (request.method === "GET") {
      return new Response(JSON.stringify(this.roomData.settings), {
        headers: { "Content-Type": "application/json" }
      });
    }
    if (request.method === "PATCH") {
      try {
        const updates = await request.json();
        Object.assign(this.roomData.settings, updates);
        await this.saveRoomData();
        await this.syncActiveRoomCache();
        this.broadcast({
          type: "settings-updated",
          settings: this.roomData.settings
        });
        return new Response(JSON.stringify({ success: true }), {
          headers: { "Content-Type": "application/json" }
        });
      } catch (error48) {
        return new Response(JSON.stringify({ error: "Invalid request" }), {
          status: 400,
          headers: { "Content-Type": "application/json" }
        });
      }
    }
    return new Response("Method not allowed", { status: 405 });
  }
  async handleMetadata(request) {
    if (request.method !== "PATCH" && request.method !== "POST") {
      return new Response("Method not allowed", { status: 405 });
    }
    try {
      const metadata = await request.json();
      if (!metadata || typeof metadata !== "object") {
        return new Response(JSON.stringify({ error: "metadata object is required" }), {
          status: 400,
          headers: { "Content-Type": "application/json" }
        });
      }
      this.roomData.metadata = {
        ...this.roomData.metadata || {},
        ...metadata
      };
      await this.saveRoomData();
      await this.syncActiveRoomCache();
      return new Response(JSON.stringify({
        success: true,
        metadata: this.roomData.metadata
      }), {
        headers: { "Content-Type": "application/json" }
      });
    } catch (error48) {
      log3.error("Metadata update error", error48, void 0, { component: "WEBRTC_ROOM" });
      return new Response(JSON.stringify({ error: "Failed to update metadata" }), {
        status: 500,
        headers: { "Content-Type": "application/json" }
      });
    }
  }
  async syncActiveRoomCache(options) {
    if (!this.env?.CACHE) {
      return;
    }
    try {
      if (options?.forceRemove) {
        await removeActiveRoom(this.env.CACHE, this.roomId);
        return;
      }
      const activeCount = this.getActiveParticipants().length;
      const roomInfo = {
        roomId: this.roomId,
        roomType: this.roomData.type === "video" ? "video" : "audio",
        currentParticipants: activeCount,
        maxParticipants: this.roomData.maxParticipants,
        status: activeCount > 0 ? "active" : "waiting",
        createdAt: this.roomData.createdAt,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        metadata: this.roomData.metadata || {}
      };
      await upsertActiveRoom(this.env.CACHE, roomInfo);
    } catch (error48) {
      log3.warn("Active room cache sync failed", void 0, {
        component: "WEBRTC_ROOM",
        error: error48 instanceof Error ? error48.message : String(error48)
      });
    }
  }
  broadcast(message, excludeUserId) {
    const data = JSON.stringify(message);
    this.ctx.getWebSockets().forEach((ws) => {
      try {
        const userData = ws.deserializeAttachment();
        if (userData && userData.userId !== excludeUserId) {
          ws.send(data);
        }
      } catch (error48) {
        log3.error("Broadcast error", error48, void 0, { component: "WEBRTC_ROOM" });
      }
    });
  }
  sendToParticipant(userId, message) {
    const data = JSON.stringify(message);
    const websockets = this.ctx.getWebSockets(userId);
    websockets.forEach((ws) => {
      try {
        ws.send(data);
      } catch (error48) {
        log3.error("Send to user error", error48, void 0, { component: "WEBRTC_ROOM", userId });
      }
    });
  }
  async handleIceServers() {
    const iceServers = [
      ...this.roomData.settings.stunServers || [],
      ...this.roomData.settings.turnServers || []
    ];
    return new Response(JSON.stringify({
      iceServers,
      ttl: 3600
      // ICE   TTL (1)
    }), {
      headers: { "Content-Type": "application/json" }
    });
  }
  async handleMetrics() {
    this.updateMetrics("message");
    const activeParticipants = this.getActiveParticipants();
    const metricsData = {
      roomId: this.roomData.id,
      currentParticipants: activeParticipants.length,
      metrics: this.roomData.metrics,
      roomSettings: {
        type: this.roomData.type,
        maxParticipants: this.roomData.maxParticipants,
        createdAt: this.roomData.createdAt
      },
      participants: activeParticipants.map((p) => ({
        id: p.id,
        name: p.name,
        joinedAt: p.joinedAt,
        audioEnabled: p.audioEnabled,
        videoEnabled: p.videoEnabled,
        isScreenSharing: p.isScreenSharing
      }))
    };
    return new Response(JSON.stringify(metricsData), {
      headers: { "Content-Type": "application/json" }
    });
  }
  getActiveParticipants() {
    const connectedUserIds = /* @__PURE__ */ new Set();
    this.ctx.getWebSockets().forEach((ws) => {
      const userData = ws.deserializeAttachment();
      if (userData) {
        connectedUserIds.add(userData.userId);
      }
    });
    return this.roomData.participants.filter((p) => connectedUserIds.has(p.id));
  }
  async saveRoomData() {
    await this.ctx.storage.put("roomData", this.roomData);
  }
  updateMetrics(type, data) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    this.roomData.metrics.lastActivity = now;
    switch (type) {
      case "join":
        this.roomData.metrics.totalParticipants++;
        const currentCount = this.roomData.participants.length;
        if (currentCount > this.roomData.metrics.peakParticipants) {
          this.roomData.metrics.peakParticipants = currentCount;
        }
        break;
      case "message":
        this.roomData.metrics.messagesExchanged++;
        break;
      case "error":
        this.roomData.metrics.connectionErrors++;
        break;
    }
    const createdTime = new Date(this.roomData.createdAt).getTime();
    const currentTime = new Date(now).getTime();
    this.roomData.metrics.sessionDuration = Math.floor((currentTime - createdTime) / 1e3);
  }
  async sendAnalytics(event, data) {
    try {
      if (this.env?.ANALYTICS) {
        await this.env.ANALYTICS.writeDataPoint({
          blobs: [this.roomData.id, event],
          doubles: [
            this.roomData.participants.length,
            this.roomData.metrics.peakParticipants,
            this.roomData.metrics.messagesExchanged,
            this.roomData.metrics.connectionErrors
          ],
          indexes: [this.roomData.id]
        });
      }
    } catch (error48) {
      console.error("Analytics error:", error48);
    }
  }
  async handleRecordingChunk(userId, data) {
    try {
      const { filename, size, duration: duration3 } = data;
      const recordingMetadata = {
        roomId: this.roomData.id,
        userId,
        filename,
        size,
        duration: duration3,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        participants: this.roomData.participants.map((p) => ({
          id: p.id,
          name: p.name
        }))
      };
      if (this.env?.CACHE) {
        const recordingKey = `recording:${this.roomData.id}:${filename}`;
        await this.env.CACHE.put(recordingKey, JSON.stringify(recordingMetadata), {
          expirationTtl: 86400 * 30
          // 30 
        });
      }
      this.broadcast({
        type: "recording-chunk-saved",
        filename,
        size,
        duration: duration3,
        uploadedBy: userId,
        timestamp: recordingMetadata.timestamp
      }, userId);
      await this.sendAnalytics("recording_chunk_saved", {
        userId,
        filename,
        size,
        duration: duration3
      });
    } catch (error48) {
      console.error("Recording chunk handling error:", error48);
    }
  }
  async handleQualityReport(userId, data) {
    try {
      const { qualityData, timestamp } = data;
      if (this.env?.CACHE) {
        const qualityKey = `quality:${this.roomId}:${userId}:${Date.now()}`;
        const qualityReport = {
          roomId: this.roomData.id,
          userId,
          timestamp: timestamp || (/* @__PURE__ */ new Date()).toISOString(),
          quality: qualityData,
          participantCount: this.roomData.participants.length
        };
        await this.env.CACHE.put(qualityKey, JSON.stringify(qualityReport), {
          expirationTtl: 3600
          // 1 
        });
      }
      await this.sendQualityAnalytics(userId, qualityData);
      if (qualityData.overall === "poor" || qualityData.overall === "fair") {
        this.broadcast({
          type: "quality-alert",
          userId,
          quality: qualityData.overall,
          issues: this.extractQualityIssues(qualityData),
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }, userId);
      }
      const participant = this.roomData.participants.find((p) => p.id === userId);
      if (participant) {
        participant.connectionQuality = qualityData.overall;
        participant.lastQualityUpdate = (/* @__PURE__ */ new Date()).toISOString();
        await this.saveRoomData();
      }
    } catch (error48) {
      console.error("Quality report handling error:", error48);
    }
  }
  async sendQualityAnalytics(userId, qualityData) {
    try {
      if (this.env?.ANALYTICS) {
        await this.env.ANALYTICS.writeDataPoint({
          blobs: [this.roomData.id, userId, "quality_report"],
          doubles: [
            qualityData.audio?.stats?.packetLossRate || 0,
            qualityData.video?.stats?.packetLossRate || 0,
            qualityData.network?.stats?.roundTripTime || 0,
            qualityData.audio?.stats?.jitter || 0,
            this.getQualityScore(qualityData.overall)
          ],
          indexes: [this.roomData.id, userId]
        });
      }
    } catch (error48) {
      console.error("Quality analytics error:", error48);
    }
  }
  getQualityScore(quality) {
    const scores = { "excellent": 100, "good": 75, "fair": 50, "poor": 25 };
    return scores[quality] || 0;
  }
  extractQualityIssues(qualityData) {
    const issues = [];
    if (qualityData.audio?.stats?.packetLossRate > 0.05) {
      issues.push("audio_packet_loss");
    }
    if (qualityData.video?.stats?.packetLossRate > 0.05) {
      issues.push("video_packet_loss");
    }
    if (qualityData.network?.stats?.roundTripTime > 300) {
      issues.push("high_latency");
    }
    if (qualityData.audio?.stats?.jitter > 50) {
      issues.push("audio_jitter");
    }
    return issues;
  }
  async restoreParticipants() {
    const stored = await this.ctx.storage.get("roomData");
    if (stored) {
      this.roomData = stored;
      const activeParticipants = this.getActiveParticipants();
      this.roomData.participants = activeParticipants;
      if (activeParticipants.length !== stored.participants.length) {
        await this.saveRoomData();
      }
    }
  }
};

// src/durable/UserPresence.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { DurableObject as DurableObject2 } from "cloudflare:workers";

// src/services/userStatus.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function isoNow() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
__name(isoNow, "isoNow");
async function updateUserStatus(env2, userId, status, options = {}) {
  const payload = {
    userId,
    status,
    sessionId: options.sessionId ?? null,
    deviceInfo: options.deviceInfo ?? null,
    metadata: options.metadata ?? null,
    updatedAt: isoNow()
  };
  const result = await env2.DB.prepare(
    `UPDATE user_status
       SET status = ?,
           current_session_id = ?,
           device_info = ?,
           last_seen_at = ?,
           updated_at = ?
     WHERE user_id = ?`
  ).bind(status, options.sessionId ?? null, options.deviceInfo ?? null, payload.updatedAt, payload.updatedAt, userId).run();
  if (result.changes === 0) {
    await env2.DB.prepare(
      `INSERT INTO user_status (
          user_id,
          status,
          last_seen_at,
          device_info,
          current_session_id,
          created_at,
          updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?)`
    ).bind(
      userId,
      status,
      payload.updatedAt,
      options.deviceInfo ?? null,
      options.sessionId ?? null,
      payload.updatedAt,
      payload.updatedAt
    ).run();
  }
}
__name(updateUserStatus, "updateUserStatus");
async function touchUserStatus(env2, userId) {
  const now = isoNow();
  const result = await env2.DB.prepare(
    `UPDATE user_status
       SET last_seen_at = ?,
           updated_at = ?
     WHERE user_id = ?`
  ).bind(now, now, userId).run();
  if (result.changes === 0) {
    await env2.DB.prepare(
      `INSERT INTO user_status (
          user_id,
          status,
          last_seen_at,
          device_info,
          current_session_id,
          created_at,
          updated_at
        ) VALUES (?, 'OFFLINE', ?, NULL, NULL, ?, ?)`
    ).bind(userId, now, now, now).run();
  }
}
__name(touchUserStatus, "touchUserStatus");
async function setInactiveUsersOffline(env2, cutoffMinutes) {
  const now = isoNow();
  const cutoffDate = new Date(Date.now() - cutoffMinutes * 60 * 1e3).toISOString();
  const result = await env2.DB.prepare(
    `UPDATE user_status
        SET status = 'OFFLINE',
            current_session_id = NULL,
            updated_at = ?,
            device_info = device_info
      WHERE status != 'OFFLINE'
        AND last_seen_at IS NOT NULL
        AND last_seen_at < ?`
  ).bind(now, cutoffDate).run();
  return result.changes ?? 0;
}
__name(setInactiveUsersOffline, "setInactiveUsersOffline");

// src/durable/UserPresence.ts
var STATUS_KEY = "status";
var ONLINE_LIST_PREFIX = "presence:online";
var SESSION_PREFIX2 = "presence:session";
var INACTIVE_THRESHOLD_MS = 15 * 60 * 1e3;
var UserPresence = class extends DurableObject2 {
  static {
    __name(this, "UserPresence");
  }
  constructor(state, env2) {
    super(state, env2);
    this.env = env2;
    this.userId = state.id.toString();
  }
  async ensureState() {
    const cached2 = await this.ctx.storage.get(STATUS_KEY);
    if (cached2) {
      return cached2;
    }
    const row = await this.env.DB.prepare(
      `SELECT status, last_seen_at, device_info, current_session_id
         FROM user_status WHERE user_id = ? LIMIT 1`
    ).bind(this.userId).first();
    if (!row) {
      return null;
    }
    const state = {
      userId: this.userId,
      status: row.status ?? "OFFLINE",
      lastSeenAt: row.last_seen_at ?? (/* @__PURE__ */ new Date()).toISOString(),
      deviceInfo: row.device_info ?? void 0,
      sessionId: row.current_session_id ?? void 0
    };
    await this.ctx.storage.put(STATUS_KEY, state);
    await this.updateIndexes(state);
    return state;
  }
  async setStatus(request) {
    const body = await request.json();
    const state = {
      ...body,
      userId: body.userId ?? this.userId,
      lastSeenAt: body.lastSeenAt ?? (/* @__PURE__ */ new Date()).toISOString()
    };
    await this.ctx.storage.put(STATUS_KEY, state);
    await this.updateIndexes(state);
    await updateUserStatus(this.env, state.userId, state.status, {
      sessionId: state.sessionId,
      deviceInfo: state.deviceInfo
    });
    return new Response(JSON.stringify(state), { status: 200, headers: { "Content-Type": "application/json" } });
  }
  async touch() {
    const current = await this.ctx.storage.get(STATUS_KEY) ?? await this.ensureState();
    if (!current) {
      return new Response(JSON.stringify({ success: false, reason: "USER_NOT_FOUND" }), { status: 404 });
    }
    const updated = {
      ...current,
      lastSeenAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    await this.ctx.storage.put(STATUS_KEY, updated);
    await this.updateIndexes(updated);
    await touchUserStatus(this.env, updated.userId);
    return new Response(JSON.stringify({ success: true }), { status: 200, headers: { "Content-Type": "application/json" } });
  }
  async getStatus() {
    const current = await this.ctx.storage.get(STATUS_KEY) ?? await this.ensureState();
    if (!current) {
      return new Response(JSON.stringify({ status: "OFFLINE" }), { status: 200, headers: { "Content-Type": "application/json" } });
    }
    return new Response(JSON.stringify(current), { status: 200, headers: { "Content-Type": "application/json" } });
  }
  async setOffline() {
    const current = await this.ctx.storage.get(STATUS_KEY) ?? await this.ensureState();
    if (!current) {
      return new Response(JSON.stringify({ success: true }), { status: 200 });
    }
    const updated = {
      ...current,
      status: "OFFLINE",
      sessionId: void 0,
      lastSeenAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    await this.ctx.storage.put(STATUS_KEY, updated);
    await this.updateIndexes(updated, { removeFromSession: current.sessionId });
    await updateUserStatus(this.env, updated.userId, "OFFLINE");
    return new Response(JSON.stringify(updated), { status: 200, headers: { "Content-Type": "application/json" } });
  }
  async alarm() {
    const current = await this.ctx.storage.get(STATUS_KEY);
    if (!current) {
      return;
    }
    const lastSeen = new Date(current.lastSeenAt).getTime();
    if (Date.now() - lastSeen > INACTIVE_THRESHOLD_MS && current.status !== "OFFLINE") {
      await this.setOffline();
    } else {
      await this.scheduleAlarm();
    }
  }
  async fetch(request) {
    const url2 = new URL(request.url);
    switch (url2.pathname) {
      case "/status":
        return this.getStatus();
      case "/set":
        if (request.method !== "POST") return new Response("Method Not Allowed", { status: 405 });
        await this.scheduleAlarm();
        return this.setStatus(request);
      case "/touch":
        if (request.method !== "POST") return new Response("Method Not Allowed", { status: 405 });
        await this.scheduleAlarm();
        return this.touch();
      case "/offline":
        if (request.method !== "POST") return new Response("Method Not Allowed", { status: 405 });
        return this.setOffline();
      default:
        return new Response("Not Found", { status: 404 });
    }
  }
  async updateIndexes(state, options = {}) {
    const { status, userId, sessionId } = state;
    if (!userId) return;
    if (status === "ONLINE" || status === "STUDYING" || status === "AWAY") {
      await this.env.CACHE.put(`${ONLINE_LIST_PREFIX}:${userId}`, state.status, { expirationTtl: 60 * 10 });
    } else {
      await this.env.CACHE.delete(`${ONLINE_LIST_PREFIX}:${userId}`);
    }
    if (sessionId) {
      await this.env.CACHE.put(`${SESSION_PREFIX2}:${sessionId}:${userId}`, state.status, { expirationTtl: 60 * 10 });
    }
    if (options.removeFromSession) {
      await this.env.CACHE.delete(`${SESSION_PREFIX2}:${options.removeFromSession}:${userId}`);
    }
  }
  async scheduleAlarm() {
    const alarmTime = Date.now() + INACTIVE_THRESHOLD_MS;
    await this.ctx.storage.setAlarm(alarmTime);
  }
};

// src/durable/ChatHub.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_db();
init_errors();
init_jwt4();
init_security();
function nowIso6() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
__name(nowIso6, "nowIso");
function parseStompFrame(raw2) {
  const trimmed = raw2.replace(/\r/g, "");
  if (!trimmed.trim()) {
    return null;
  }
  const parts = trimmed.split("\n");
  const command = parts.shift() ?? "";
  const headers = {};
  while (parts.length > 0) {
    const line = parts.shift();
    if (line === "") {
      break;
    }
    const idx = line.indexOf(":");
    if (idx > -1) {
      const key = line.slice(0, idx).trim();
      const value = line.slice(idx + 1).trim();
      headers[key] = value;
    }
  }
  const body = parts.join("\n");
  return { command, headers, body };
}
__name(parseStompFrame, "parseStompFrame");
function serializeStompFrame(frame) {
  const headerLines = Object.entries(frame.headers).map(([key, value]) => `${key}:${value}`).join("\n");
  return `${frame.command}
${headerLines}

${frame.body}\0`;
}
__name(serializeStompFrame, "serializeStompFrame");
function normalizeDestination(destination, userId) {
  if (destination.startsWith("/user/")) {
    const keyUser = userId ?? "";
    return `${destination}|${keyUser}`;
  }
  return destination;
}
__name(normalizeDestination, "normalizeDestination");
function safeJsonParse(input) {
  try {
    return JSON.parse(input);
  } catch {
    return null;
  }
}
__name(safeJsonParse, "safeJsonParse");
function buildMessageFrame(subscriptionId, destination, body) {
  return {
    command: "MESSAGE",
    headers: {
      subscription: subscriptionId,
      "message-id": crypto.randomUUID(),
      destination,
      "content-type": "application/json"
    },
    body: JSON.stringify(body ?? null)
  };
}
__name(buildMessageFrame, "buildMessageFrame");
var ChatHub = class {
  constructor(state, env2) {
    this.state = state;
    this.env = env2;
    this.connections = /* @__PURE__ */ new Map();
    this.destinationMap = /* @__PURE__ */ new Map();
  }
  static {
    __name(this, "ChatHub");
  }
  async fetch(request) {
    const upgradeHeader = request.headers.get("Upgrade");
    if (upgradeHeader && upgradeHeader.toLowerCase() === "websocket") {
      const pair = new WebSocketPair();
      const client = pair[0];
      const server = pair[1];
      this.acceptWebSocket(server);
      return new Response(null, { status: 101, webSocket: client });
    }
    if (request.method === "POST") {
      const event = await request.json();
      await this.publish(event.destination, event.payload, event.userId);
      return new Response(null, { status: 204 });
    }
    return new Response("Not Found", { status: 404 });
  }
  acceptWebSocket(socket, userId) {
    const id = crypto.randomUUID();
    const state = {
      id,
      userId: userId ?? "",
      subscriptions: /* @__PURE__ */ new Map(),
      buffer: ""
    };
    this.connections.set(socket, state);
    socket.accept();
    socket.addEventListener("message", (event) => {
      if (typeof event.data !== "string") {
        return;
      }
      state.buffer += event.data;
      let frameEnd = state.buffer.indexOf("\0");
      while (frameEnd >= 0) {
        const rawFrame = state.buffer.slice(0, frameEnd);
        state.buffer = state.buffer.slice(frameEnd + 1);
        const frame = parseStompFrame(rawFrame);
        if (frame) {
          this.handleFrame(socket, state, frame).catch((error48) => {
            console.error("[ChatHub] Failed to handle frame", error48);
          });
        }
        frameEnd = state.buffer.indexOf("\0");
      }
    });
    socket.addEventListener("close", () => {
      this.cleanup(socket);
    });
    socket.addEventListener("error", () => {
      this.cleanup(socket);
    });
  }
  async handleFrame(socket, state, frame) {
    switch (frame.command) {
      case "CONNECT": {
        const auth2 = await this.authenticateConnection(frame.headers);
        if (!auth2) {
          this.sendError(socket, "Unauthorized");
          socket.close(1008, "Unauthorized");
          return;
        }
        state.userId = auth2.id;
        const profile3 = await this.getUserProfile(auth2.id);
        state.profile = {
          name: profile3.name ?? auth2.name,
          profileImage: profile3.profileImage
        };
        this.sendFrame(socket, {
          command: "CONNECTED",
          headers: {
            version: "1.2",
            "heart-beat": "0,0"
          },
          body: ""
        });
        break;
      }
      case "SUBSCRIBE": {
        const destination = frame.headers.destination;
        const subscriptionId = frame.headers.id;
        if (!destination || !subscriptionId) {
          this.sendError(socket, "SUBSCRIBE frame missing destination or id");
          return;
        }
        const key = normalizeDestination(destination, state.userId);
        state.subscriptions.set(subscriptionId, key);
        let subMap = this.destinationMap.get(key);
        if (!subMap) {
          subMap = /* @__PURE__ */ new Map();
          this.destinationMap.set(key, subMap);
        }
        subMap.set(socket, subscriptionId);
        break;
      }
      case "UNSUBSCRIBE": {
        const subscriptionId = frame.headers.id;
        if (!subscriptionId) {
          return;
        }
        const key = state.subscriptions.get(subscriptionId);
        if (!key) {
          return;
        }
        state.subscriptions.delete(subscriptionId);
        const subMap = this.destinationMap.get(key);
        subMap?.delete(socket);
        if (subMap && subMap.size === 0) {
          this.destinationMap.delete(key);
        }
        break;
      }
      case "SEND": {
        const destination = frame.headers.destination;
        if (!destination) {
          this.sendError(socket, "SEND frame missing destination");
          return;
        }
        await this.handleSend(socket, destination, frame.body, state);
        break;
      }
      case "DISCONNECT": {
        socket.close(1e3, "Client disconnect");
        break;
      }
      default:
        break;
    }
  }
  async handleSend(socket, destination, body, state) {
    if (!state.userId) {
      this.sendError(socket, "Unauthorized");
      socket.close(1008, "Unauthorized");
      return;
    }
    if (destination === "/pub/chat/message") {
      const parsed = safeJsonParse(body) ?? {};
      const roomId = Number(parsed.roomId);
      if (!Number.isFinite(roomId)) {
        throw new AppError("roomId\uAC00 \uD544\uC694\uD569\uB2C8\uB2E4.", 400, "INVALID_ROOM_ID");
      }
      const message = await createChatMessage(this.env, state.userId, {
        roomId,
        message: parsed.message,
        imageUrls: parsed.imageUrls,
        audioData: parsed.audioData,
        audioUrl: parsed.audioUrl,
        messageType: parsed.messageType
      });
      await this.publish(`/sub/chat/room/${message.roomId}`, message);
    } else if (destination === "/pub/chat/typing") {
      const payload = safeJsonParse(body);
      if (!payload || !Number.isFinite(payload.roomId)) {
        return;
      }
      const profile3 = state.profile ?? await this.getUserProfile(state.userId);
      state.profile = profile3;
      await this.publish(`/sub/chat/room/${payload.roomId}/typing`, {
        userId: state.userId,
        userName: profile3.name,
        userProfileImage: profile3.profileImage,
        isTyping: Boolean(payload.isTyping),
        timestamp: nowIso6()
      });
    }
  }
  async authenticateConnection(headers) {
    const authorization = headers["Authorization"] ?? headers["authorization"];
    if (!authorization) {
      return null;
    }
    const match = authorization.match(/^Bearer (.+)$/i);
    if (!match) {
      return null;
    }
    try {
      const secret = assertEnvVar(this.env.JWT_SECRET, "JWT_SECRET");
      const verifyOptions = { alg: "HS512" };
      const issuer = this.env.JWT_ISSUER ?? this.env.API_BASE_URL;
      if (issuer) {
        verifyOptions.iss = issuer;
      }
      const payload = await verify2(match[1], secret, verifyOptions);
      const id = payload.sub ? String(payload.sub) : "";
      if (!id) {
        return null;
      }
      return { id, name: payload.name };
    } catch {
      return null;
    }
  }
  async getUserProfile(userId) {
    const row = await queryFirst(
      this.env.DB,
      "SELECT name, profile_image FROM users WHERE user_id = ? LIMIT 1",
      [userId]
    );
    return {
      name: row?.name ?? void 0,
      profileImage: row?.profile_image ?? void 0
    };
  }
  async publish(destination, payload, userId) {
    const key = normalizeDestination(destination, userId);
    const subscribers = this.destinationMap.get(key);
    if (!subscribers || subscribers.size === 0) {
      return;
    }
    for (const [socket, subscriptionId] of subscribers.entries()) {
      if (socket.readyState !== WebSocket.OPEN) {
        continue;
      }
      this.sendFrame(socket, buildMessageFrame(subscriptionId, destination, payload));
    }
  }
  sendFrame(socket, frame) {
    try {
      socket.send(serializeStompFrame(frame));
    } catch (error48) {
      console.error("[ChatHub] Failed to send frame", error48);
      socket.close(1011, "Frame send error");
    }
  }
  sendError(socket, message) {
    this.sendFrame(socket, {
      command: "ERROR",
      headers: { message },
      body: message
    });
  }
  cleanup(socket) {
    const state = this.connections.get(socket);
    if (!state) {
      return;
    }
    for (const [subscriptionId, key] of state.subscriptions.entries()) {
      const subMap = this.destinationMap.get(key);
      subMap?.delete(socket);
      if (subMap && subMap.size === 0) {
        this.destinationMap.delete(key);
      }
    }
    this.connections.delete(socket);
  }
};

// src/middleware/index.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/middleware/logger.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/middleware/request-id/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/hono/dist/middleware/request-id/request-id.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/index.ts
init_analytics();

// src/websocket/notificationSocket.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_jwt4();
init_security();
var HEARTBEAT_INTERVAL_MS = 25e3;
var NOTIFICATION_POLL_INTERVAL_MS = 15e3;
var MAX_SENT_HISTORY = 200;
async function handleNotificationWebSocket(c) {
  const url2 = new URL(c.req.url);
  const token = url2.searchParams.get("token") ?? extractBearerToken(c.req.header("Authorization")) ?? "";
  const user = await verifyUserToken(token, c.env);
  if (!user) {
    return new Response("Unauthorized", { status: 401 });
  }
  const { 0: client, 1: server } = new WebSocketPair();
  const session = new NotificationSocketSession(server, c.env, user.id);
  session.start();
  return new Response(null, { status: 101, webSocket: client });
}
__name(handleNotificationWebSocket, "handleNotificationWebSocket");
function extractBearerToken(authorizationHeader) {
  if (!authorizationHeader) return void 0;
  const match = authorizationHeader.match(/^Bearer (.+)$/i);
  return match?.[1];
}
__name(extractBearerToken, "extractBearerToken");
async function verifyUserToken(token, env2) {
  if (!token) return null;
  try {
    const secret = assertEnvVar(env2.JWT_SECRET, "JWT_SECRET");
    const verifyOptions = { alg: "HS512" };
    const issuer = env2.JWT_ISSUER ?? env2.API_BASE_URL;
    if (issuer) {
      verifyOptions.iss = issuer;
    }
    const payload = await verify2(token, secret, verifyOptions);
    if (typeof payload.sub !== "string") {
      return null;
    }
    return { id: payload.sub };
  } catch (error48) {
    console.error("[notifications-ws] Failed to verify token", error48);
    return null;
  }
}
__name(verifyUserToken, "verifyUserToken");
var NotificationSocketSession = class {
  constructor(ws, env2, userId) {
    this.buffer = "";
    this.connected = false;
    this.subscriptions = /* @__PURE__ */ new Map();
    this.sentHistory = /* @__PURE__ */ new Set();
    this.sentOrder = [];
    this.ws = ws;
    this.env = env2;
    this.userId = userId;
  }
  static {
    __name(this, "NotificationSocketSession");
  }
  start() {
    this.ws.accept();
    this.ws.addEventListener("message", (event) => {
      this.handleIncomingData(event.data);
    });
    this.ws.addEventListener("close", () => {
      this.cleanup();
    });
    this.ws.addEventListener("error", (event) => {
      console.error("[notifications-ws] Socket error", event);
      this.cleanup();
    });
  }
  handleIncomingData(data) {
    const text = typeof data === "string" ? data : data instanceof ArrayBuffer ? new TextDecoder().decode(data) : "";
    if (!text) {
      return;
    }
    this.buffer += text;
    while (true) {
      const terminatorIndex = this.buffer.indexOf("\0");
      if (terminatorIndex === -1) {
        break;
      }
      const frameText = this.buffer.slice(0, terminatorIndex);
      this.buffer = this.buffer.slice(terminatorIndex + 1);
      const trimmed = frameText.trim();
      if (trimmed === "") {
        continue;
      }
      const frame = this.parseFrame(frameText);
      if (frame) {
        this.handleFrame(frame);
      }
    }
  }
  parseFrame(raw2) {
    const lines = raw2.split("\n");
    if (!lines.length) return null;
    const command = lines.shift()?.trim() ?? "";
    if (!command) return null;
    const headers = {};
    let line;
    while ((line = lines.shift()) !== void 0) {
      if (line === "") break;
      const separatorIndex = line.indexOf(":");
      if (separatorIndex === -1) continue;
      const key = line.slice(0, separatorIndex).trim();
      const value = line.slice(separatorIndex + 1).trim();
      headers[key] = value;
    }
    const body = lines.join("\n");
    return { command, headers, body };
  }
  handleFrame(frame) {
    const { command } = frame;
    switch (command) {
      case "CONNECT":
      case "STOMP":
        this.handleConnect(frame);
        break;
      case "SUBSCRIBE":
        this.handleSubscribe(frame);
        break;
      case "UNSUBSCRIBE":
        this.handleUnsubscribe(frame);
        break;
      case "DISCONNECT":
        this.handleDisconnect(frame);
        break;
      case "SEND":
        this.ackReceipt(frame.headers["receipt"]);
        break;
      default:
        console.warn("[notifications-ws] Unsupported STOMP command", command);
        this.sendError(`Unsupported command: ${command}`);
    }
  }
  handleConnect(frame) {
    if (this.connected) {
      return;
    }
    const heartbeatHeader = frame.headers["heart-beat"] ?? "0,0";
    const [, clientHeartbeatRaw] = heartbeatHeader.split(",");
    const clientHeartbeat = Number(clientHeartbeatRaw) || 0;
    const serverHeartbeat = Math.max(clientHeartbeat, HEARTBEAT_INTERVAL_MS);
    this.connected = true;
    this.sendFrame("CONNECTED", {
      version: "1.2",
      "heart-beat": `0,${serverHeartbeat}`
    });
    this.scheduleHeartbeat(serverHeartbeat);
  }
  scheduleHeartbeat(interval) {
    if (interval <= 0) return;
    const sendBeat = /* @__PURE__ */ __name(() => {
      if (this.ws.readyState === WebSocket.OPEN) {
        this.ws.send("\n");
        this.heartbeatTimer = setTimeout(sendBeat, interval);
      }
    }, "sendBeat");
    this.heartbeatTimer = setTimeout(sendBeat, interval);
  }
  handleSubscribe(frame) {
    const id = frame.headers["id"] ?? crypto.randomUUID();
    const destination = frame.headers["destination"];
    if (!destination) {
      this.sendError("SUBSCRIBE frame missing destination header");
      return;
    }
    this.subscriptions.set(id, { destination });
    if (destination.includes("notifications")) {
      this.startNotificationPolling(id, destination);
    }
    this.ackReceipt(frame.headers["receipt"]);
  }
  handleUnsubscribe(frame) {
    const id = frame.headers["id"];
    if (!id) {
      this.sendError("UNSUBSCRIBE frame missing id header");
      return;
    }
    this.stopNotificationPolling(id);
    this.subscriptions.delete(id);
    this.ackReceipt(frame.headers["receipt"]);
  }
  handleDisconnect(frame) {
    this.ackReceipt(frame.headers["receipt"]);
    this.cleanup();
    this.ws.close(1e3, "Client disconnected");
  }
  ackReceipt(receiptId) {
    if (!receiptId) return;
    this.sendFrame("RECEIPT", { "receipt-id": receiptId });
  }
  sendError(message) {
    this.sendFrame("ERROR", { message }, message);
  }
  sendFrame(command, headers = {}, body = "") {
    if (this.ws.readyState !== WebSocket.OPEN) {
      return;
    }
    const headerLines = Object.entries(headers).map(([key, value]) => `${key}:${value}`);
    const frame = [command, ...headerLines, "", body, "\0"].join("\n");
    this.ws.send(frame);
  }
  async startNotificationPolling(subscriptionId, destination) {
    const poll = /* @__PURE__ */ __name(async () => {
      try {
        await this.sendNotificationSnapshot(subscriptionId, destination);
      } catch (error48) {
        console.error("[notifications-ws] Failed to send notification snapshot", error48);
      }
      const context2 = this.subscriptions.get(subscriptionId);
      if (!context2) return;
      context2.pollTimer = setTimeout(poll, NOTIFICATION_POLL_INTERVAL_MS);
    }, "poll");
    await poll();
  }
  stopNotificationPolling(subscriptionId) {
    const context2 = this.subscriptions.get(subscriptionId);
    if (context2?.pollTimer) {
      clearTimeout(context2.pollTimer);
    }
  }
  async sendNotificationSnapshot(subscriptionId, destination) {
    const result = await listNotifications(this.env, this.userId, {
      page: 1,
      size: 20,
      unreadOnly: true
    });
    const freshNotifications = result.data.filter((item) => this.registerNotification(item.id));
    for (const notification of freshNotifications) {
      const payload = this.serializeNotification(notification, result.unreadCount);
      this.sendFrame("MESSAGE", {
        subscription: subscriptionId,
        "message-id": crypto.randomUUID(),
        destination,
        "content-type": "application/json"
      }, payload);
    }
  }
  registerNotification(notificationId) {
    if (this.sentHistory.has(notificationId)) {
      return false;
    }
    this.sentHistory.add(notificationId);
    this.sentOrder.push(notificationId);
    if (this.sentOrder.length > MAX_SENT_HISTORY) {
      const expired = this.sentOrder.shift();
      if (typeof expired === "number") {
        this.sentHistory.delete(expired);
      }
    }
    return true;
  }
  serializeNotification(notification, unreadCount) {
    const payload = {
      ...notification,
      unreadCount,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    return JSON.stringify(payload);
  }
  cleanup() {
    if (this.heartbeatTimer) {
      clearTimeout(this.heartbeatTimer);
      this.heartbeatTimer = void 0;
    }
    for (const [id, context2] of this.subscriptions.entries()) {
      if (context2.pollTimer) {
        clearTimeout(context2.pollTimer);
      }
      this.subscriptions.delete(id);
    }
  }
};

// src/index.ts
var scheduled = /* @__PURE__ */ __name(async (controller, env2, ctx) => {
  const job = (async () => {
    const currentHour = (/* @__PURE__ */ new Date()).getUTCHours();
    const currentDay = (/* @__PURE__ */ new Date()).getUTCDay();
    try {
      const changed = await setInactiveUsersOffline(env2, 15);
      if (changed > 0) {
        console.log(`[presence-cron] Marked ${changed} users offline.`);
      }
    } catch (error48) {
      console.error("[presence-cron] Failed to update inactive users", error48);
    }
    try {
      const delivered = await processScheduledNotifications(env2);
      if (delivered > 0) {
        console.log(`[notifications-cron] Delivered ${delivered} scheduled notifications.`);
      }
    } catch (error48) {
      console.error("[notifications-cron] Failed to process scheduled notifications", error48);
    }
    if (currentHour === 20) {
      try {
        const created = await createStudyReminderNotifications(env2);
        if (created > 0) {
          console.log(`[study-reminder-cron] Created ${created} study reminder notifications.`);
        }
      } catch (error48) {
        console.error("[study-reminder-cron] Failed to create study reminders", error48);
      }
    }
    if (currentDay === 0 && currentHour === 21) {
      try {
        const created = await createGoalProgressNotifications(env2);
        if (created > 0) {
          console.log(`[goal-progress-cron] Created ${created} goal progress notifications.`);
        }
      } catch (error48) {
        console.error("[goal-progress-cron] Failed to create goal progress notifications", error48);
      }
    }
  })();
  ctx.waitUntil(job);
}, "scheduled");
var API_VERSION = "v1";
var app8 = new Hono2();
app8.use("*", errorHandler3);
app8.use(errorTrackingMiddleware);
app8.use(analyticsMiddleware);
app8.use("*", async (c, next) => {
  const corsOrigin = c.env?.CORS_ORIGIN || "http://localhost:3000";
  const allowedOrigins = corsOrigin.split(",").map((o) => o.trim());
  const corsMiddleware = cors({
    origin: /* @__PURE__ */ __name((origin) => {
      if (!origin) return corsOrigin;
      if (allowedOrigins.some((allowed) => origin.startsWith(allowed))) {
        return origin;
      }
      return allowedOrigins[0];
    }, "origin"),
    allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowHeaders: ["Content-Type", "Authorization", "X-Request-ID", "X-API-Key"],
    exposeHeaders: ["Content-Length", "X-Request-ID", "X-RateLimit-Limit", "X-RateLimit-Remaining"],
    maxAge: 86400,
    credentials: true
  });
  return corsMiddleware(c, next);
});
app8.get("/ws/chat", (c) => {
  const id = c.env.CHAT_HUB.idFromName("global");
  const stub = c.env.CHAT_HUB.get(id);
  return stub.fetch(c.req.raw);
});
app8.get("/ws/notifications", (c) => handleNotificationWebSocket(c));
app8.get("/", (c) => {
  return successResponse(c, {
    name: "STUDYMATE API",
    version: API_VERSION,
    status: "operational",
    documentation: "/api/docs",
    endpoints: {
      health: "/health",
      levelTest: `/api/${API_VERSION}/level-test`,
      webrtc: `/api/${API_VERSION}/room`,
      upload: `/api/${API_VERSION}/upload`,
      whisper: `/api/${API_VERSION}/whisper`,
      llm: `/api/${API_VERSION}/llm`,
      images: `/api/${API_VERSION}/images`,
      cache: `/api/${API_VERSION}/cache`,
      transcribe: `/api/${API_VERSION}/transcribe`,
      analytics: `/api/${API_VERSION}/analytics`,
      translate: `/api/${API_VERSION}/translate`
    }
  });
});
app8.get("/health", (c) => {
  return successResponse(c, {
    status: "healthy",
    environment: c.env?.ENVIRONMENT,
    version: API_VERSION,
    services: {
      ai: "operational",
      storage: "operational",
      cache: "operational",
      durableObjects: "operational"
    }
  });
});
app8.get("/metrics", (c) => {
  return c.text(`# HELP http_requests_total Total number of HTTP requests
# TYPE http_requests_total counter
http_requests_total{method="GET",endpoint="/health"} 1
`);
});
var v1 = new Hono2();
v1.route("/auth", auth_default);
v1.route("/login", auth_default);
v1.route("/users", users_default);
v1.route("/onboarding", onboarding_default);
v1.route("/sessions", sessions_default);
v1.route("/notifications", notifications_default);
v1.route("/group-sessions", groupSessions_default);
v1.route("/group-sessions/ai", groupSessionsAI_default);
v1.route("/presence", presence_default);
v1.route("/matching", matching_default);
v1.route("/achievements", achievements_default);
v1.route("/chat", chat_default);
v1.route("/settings", settings_default);
v1.route("/pronunciation", pronunciation_default);
v1.route("/level-test", levelTestRoutes);
v1.route("/room", webrtcRoutes);
v1.route("/upload", uploadRoutes);
v1.route("/whisper", whisper_default);
v1.route("/llm", llm_default);
v1.route("/images", images_default);
v1.route("/cache", cache_default);
v1.route("/transcribe", transcribe_default);
v1.route("/translate", translate_default);
v1.route("/analytics", app7);
v1.route("/internal", internal_default);
app8.route(`/api/${API_VERSION}`, v1);
app8.get(`/api/${API_VERSION}/health`, (c) => {
  return successResponse(c, {
    status: "healthy",
    environment: c.env?.ENVIRONMENT,
    version: API_VERSION,
    services: {
      ai: "operational",
      storage: "operational",
      cache: "operational",
      durableObjects: "operational"
    }
  });
});
app8.get("/login/oauth2/code/:provider", async (c) => {
  const provider = c.req.param("provider");
  const code = c.req.query("code");
  const state = c.req.query("state") || void 0;
  if (!code) {
    return c.json({
      success: false,
      error: {
        message: "Missing OAuth code",
        code: "INVALID_OAUTH_CALLBACK"
      }
    }, 400);
  }
  const { handleOAuthCallback: handleOAuthCallback2 } = await Promise.resolve().then(() => (init_auth(), auth_exports));
  const { AppError: AppError2 } = await Promise.resolve().then(() => (init_errors(), errors_exports));
  try {
    const result = await handleOAuthCallback2(
      c.env,
      provider,
      { code, state },
      {
        userAgent: c.req.header("User-Agent") || void 0,
        ipAddress: c.req.header("CF-Connecting-IP") || c.req.header("X-Forwarded-For") || c.req.header("X-Real-IP") || void 0
      }
    );
    const acceptsJson = (c.req.header("Accept") || "").includes("application/json");
    if (!acceptsJson) {
      const redirectTarget = result.callbackUrl || result.redirectUri;
      if (!redirectTarget) {
        return successResponse(c, result);
      }
      const redirectUrl = new URL(redirectTarget);
      redirectUrl.searchParams.set("accessToken", result.accessToken);
      redirectUrl.searchParams.set("refreshToken", result.refreshToken);
      redirectUrl.searchParams.set("provider", provider);
      if (state) {
        redirectUrl.searchParams.set("state", state);
      }
      if (result.redirectUri && result.redirectUri !== redirectTarget) {
        redirectUrl.searchParams.set("redirect", result.redirectUri);
      }
      return c.redirect(redirectUrl.toString());
    }
    return successResponse(c, result);
  } catch (error48) {
    if (error48 instanceof AppError2) {
      throw error48;
    }
    const message = error48 instanceof Error ? error48.message : "Authentication failure";
    throw new AppError2(message, 500, "AUTH_OPERATION_FAILED");
  }
});
app8.notFound(notFoundHandler2);
var fetchHandler = /* @__PURE__ */ __name((request, env2, ctx) => app8.fetch(request, env2, ctx), "fetchHandler");
var worker = {
  fetch: fetchHandler,
  scheduled
};
var index_default = worker;
export {
  ChatHub,
  UserPresence,
  WebRTCRoom,
  app8 as app,
  index_default as default,
  scheduled
};
//# sourceMappingURL=index.js.map
